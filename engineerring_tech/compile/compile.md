# compile

​		编译与链接的过程可以分为四个阶段：

- `Prepressing` 预处理
- `Compilation` 编译
- `Assembly` 汇编
- `linking` 链接



## 预处理

​		针对于某个翻译单元（源码文件及引入的相关头文件），被预处理器预处理成一个`.i`文件。

​		预处理主要处理翻译单元中以`#`开始的预处理指令。处理后的`.i`文件不包含任何宏定义，引入的头文件中的符号被全量拷贝。

> gcc：`gcc -E hello.c -o hello.i`
>
> -E 执行预处理器，输出预处理结果
>
> 无法判断宏定义是否正确或者头文件包含是否正确时，可以通过查看`.i`文件来确定结果。



1. 将所有`#define`定义的宏展开为其定义

   ​	`#undef`之后的宏不再展开

2. 处理所有条件编译指令

   ​	`#if / #ifdef / #ifndef / #elif / #else / #endif`

3. 将`#include`引入的头文件插入到该预处理指令的位置，并且这个过程是递归的。

4. 过滤注释`//`和` /**/`

5. 添加行号和文件名标识，如`#2 "test.c" 2`，便于编译时编译器生成调试信息和编译器的错误信息

6. 保留所有的`#pragma`编译器指令，以供编译器使用它们



## 编译

​		编译过程就是把预处理完的文件进行 词法分析、语法分析、语义分析以及优化，然后产生相应的汇编代码，编译器是将高级语言翻译到汇编语言的工具。

> gcc：`gcc -S hello.i -o hello.s`
>
> -S 执行编译器，输出汇编代码。
>
> -s直接生成和使用`strip`生成同样效果的可执行文件（删除了所有符号信息）

`array[index] = (index+5)*(2+7)`

1. 扫描 ，即词法分析

   ​	生成token。将源代码输入到扫描器，使用类似于有限状态机的算法将源代码的字符序列分割成一系列的记号。

   ​    记号一般分为：关键字、标识符、字面量、特殊记号（操作符）

   > array   [  	index	]		= 		(	index	+		5		)	 *	 	(		2		+		7		)
   >
   > id       op 	id		op  	op	op 	id		op	num	op	op	op		num	op	num	op
   >
   > - id = identifer
   > - op = operator

   ​	标识符会存放到符号表中，数字、字符串常量存放到文字表中。`lex`程序可以实现词法扫描哦，按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。

2.  语法分析

   ​	将所有token生成AST（abstract syntax tree）抽象语法树

   ​	语法分析使用上下文无关的分析手段，对扫描器产生的记号进行语法分析，产生以表达式为节点的抽象语法树。

   > 一般以中缀表达式的方式解析
   >
   > ![image-20230405170522182](../../../../AppData/Roaming/Typora/typora-user-images/image-20230405170522182.png)

   ​	表达式不合法，如括号不匹配，表达式缺少操作符等，编译器就会在语法分析阶段内报告错误。`yacc`程序可以根据用户给定的语法规则对输入的记号进行解析构建语法树。

3. 语义分析

   ​	由语义分析器将AST生成带变量的语法树。

   ​	对于在语法上合法，但不符合语言定义的逻辑。编译器能够进行分析的语义是静态语义，包括声明、类型等。动态语义如除零等。

   ​	经过语义分析阶段后，整个语法树的表达式都会被标记上类型，需要进行隐式转换的节点，语义分析程序会插入相应的转换节点，并更新符号表中的符号类型。

   > ![image-20230405171758682](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20230405171758682.png)

4. 源代码优化

   ​		中间表达（IR）。现代编译器有很多层次的优化，在源代码级别会有一个优化过程。如将2+7 优化为9，避免后续的计算。

   ​		直接在语法树上进行这类优化比较困难，源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示，已经非常接近目标代码，但没有绑定到目标机器和运行时环境的信息如数据尺寸、变量地址和寄存器名字等。

   ​		中间表达使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端则负责将中间代码住哪换成目标机器代码。对于一些可以跨平台的编译器而言，他们可以针对不同的平台使用同一个前端和针对不同的机器平台的多个后端。

5. 代码生成

   ​	目标代码从

6. 目标代码优化

   ​	最终目标代码



## 汇编

​		将汇编语言翻译成机器语言

​		

​		