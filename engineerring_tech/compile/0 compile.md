# compile

​		编译与链接的过程可以分为四个阶段：

- `Prepressing` 预处理
- `Compilation` 编译
- `Assembly` 汇编
- `linking` 链接



## 预处理

​		针对于某个翻译单元（源码文件及引入的相关头文件），被预处理器预处理成一个`.i`文件。

​		预处理主要处理翻译单元中以`#`开始的预处理指令。处理后的`.i`文件不包含任何宏定义，引入的头文件中的符号被全量拷贝。

> gcc：`gcc -E hello.c -o hello.i`
>
> -E 执行预处理器，输出预处理结果
>
> 无法判断宏定义是否正确或者头文件包含是否正确时，可以通过查看`.i`文件来确定结果。



1. 将所有`#define`定义的宏展开为其定义

   ​	`#undef`之后的宏不再展开

2. 处理所有条件编译指令

   ​	`#if / #ifdef / #ifndef / #elif / #else / #endif`

3. 将`#include`引入的头文件插入到该预处理指令的位置，并且这个过程是递归的。

4. 过滤注释`//`和` /**/`

5. 添加行号和文件名标识，如`#2 "test.c" 2`，便于编译时编译器生成调试信息和编译器的错误信息

6. 保留所有的`#pragma`编译器指令，以供编译器使用它们



## 编译

​		编译过程就是把预处理完的文件进行 词法分析、语法分析、语义分析以及优化，然后产生相应的汇编代码，编译器是将高级语言翻译到汇编语言的工具。

> gcc：`gcc -S hello.i -o hello.s`
>
> -S 执行编译器，输出汇编代码。
>
> -s直接生成和使用`strip`生成同样效果的可执行文件（删除了所有符号信息）

`array[index] = (index+5)*(2+7)`

1. 扫描 ，即词法分析

   ​	生成token。将源代码输入到扫描器，使用类似于有限状态机的算法将源代码的字符序列分割成一系列的记号。

   ​    记号一般分为：关键字、标识符、字面量、特殊记号（操作符）

   > array   [  	index	]		= 		(	index	+		5		)	 *	 	(		2		+		7		)
   >
   > id       op 	id		op  	op	op 	id		op	num	op	op	op		num	op	num	op
   >
   > - id = identifer
   > - op = operator

   ​	标识符会存放到符号表中，数字、字符串常量存放到文字表中。`lex`程序可以实现词法扫描哦，按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。

2.  语法分析

   ​	将所有token生成AST（abstract syntax tree）抽象语法树

   ​	语法分析使用上下文无关的分析手段，对扫描器产生的记号进行语法分析，产生以表达式为节点的抽象语法树。

   > 一般以中缀表达式的方式解析
   >
   > ![image-20230405170522182](../../../../AppData/Roaming/Typora/typora-user-images/image-20230405170522182.png)

   ​	表达式不合法，如括号不匹配，表达式缺少操作符等，编译器就会在语法分析阶段内报告错误。`yacc`程序可以根据用户给定的语法规则对输入的记号进行解析构建语法树。

3. 语义分析

   ​	由语义分析器将AST生成带变量的语法树。

   ​	对于在语法上合法，但不符合语言定义的逻辑。编译器能够进行分析的语义是静态语义，包括声明、类型等。动态语义如除零等。

   ​	经过语义分析阶段后，整个语法树的表达式都会被标记上类型，需要进行隐式转换的节点，语义分析程序会插入相应的转换节点，并更新符号表中的符号类型。

   > ![image-20230405171758682](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20230405171758682.png)

4. 源代码优化

   ​		中间表达（IR）。现代编译器有很多层次的优化，在源代码级别会有一个优化过程。如将2+7 优化为9，避免后续的计算。

   ​		直接在语法树上进行这类优化比较困难，源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示，已经非常接近目标代码，但没有绑定到目标机器和运行时环境的信息如数据尺寸、变量地址和寄存器名字等。

   ​		中间表达使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端则负责将中间代码住哪换成目标机器代码。对于一些可以跨平台的编译器而言，他们可以针对不同的平台使用同一个前端和针对不同的机器平台的多个后端。

   ​		源代码优化器产生中间表达意味着接下来的过程都是编译器后端。包括代码生成器和目标代码优化器。

5. 代码生成

   ​		将中间代码转换成目标机器代码，依赖于目标机器的不同字长、寄存器、整数数据类型和浮点数类型等。

6. 目标代码优化

   ​		目标优化器对上述生成的代码进行优化，比如选择合适的寻址方式、使用位移代替乘法等。

​		经过上述编译步骤，产生的目标代码还有一个问题，变量的地址如何确定。如果变量定义在当前编译的翻译单元里，编译器就会在当前编译单元为其分配空间，确定它们的地址。如果是定义在其他的翻译单元中的全局变量和函数，其最终运行时的绝对地址都要等到链接各个翻译单元的时候才能确定。

## 汇编

​		将汇编语言翻译成机器语言。

​		程序`as`进行汇编，从`.s`生成`.o`文件。

## 链接

​		把独立的源代码模块按一定的规则组合在一起。主要工作是把各个模块之间相互引用的部分都处理好。

​		从原理上说，链接的工作是把指令对其他符号地址的引用加以修正，主要包括地址和空间分配、符号决议和重定位等。

​		链接过程中，对定义在其他目标文件中的函数调用和全局变量的指令需要重新调整地址，地址修正的过程叫做重定位。

​		每个目标文件除拥有自己的数据和二进制代码外，还提供三个表：

- 未解决符号表 ： 提供所有在该翻译单元里引用的，但定义在外部单元的符号和符号地址
  - `extern`声明的变量置入未解决符号表
- 导出符号表 ： 提供本翻译单元具体定义的，且声明为外部链接（可被外部单元引用）的符号和符号地址
  - `static`声明的全局变量不置入未解决符号变，也不置入导出符号表，内部链接
  - 全局声明的普通变量和函数置入导出符号表（默认外部链接，但不加`extern`不会置入未解决符号表）
- 地址重定向表：提供本翻译单元中所有对自身地址的引用和记录

### 库

​		程序库是一组目标文件的包，是一些功能代码编译成目标文件后打包的文件。

​		库的链接方式分为静态链接和动态链接，在这个意义上讲，各个源码翻译单元都是以静态链接的方式进行的。

#### 静态链接

​		对库的链接是在编译时完成的，库中相关的目标文件和涉及到的符号都被链接合成一个可执行文件。运行时不再依赖该库，因为库中相关的信息已经全部被复制到可执行文件的相关位置。

- 一个最基本的静态库程序链接过程

![image-20230406212716840](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20230406212716840.png)

- 由多个目标文件`*.o`创建静态库文件使用`ar`

  `ar cr libxxx.a a.o b.o...`

  `ar tv libxxx.a` 用于查看库文件中的`*.o`

  - `r`：在库中插入模块，当模块已经存在则替换。
  - `c`：创建一个库，无论库是否已经存在。
  - `tv`：显示库文件的组成

- 指定要链接的库

  - `-I` 指定库的头文件目录
  - `-L` 指定库所在目录
  - `-l`要连接的库名字，去除`lib /.a`只保留名字
  - `gcc -o main main.cpp a.cpp -L. -lxxx`



#### 动态链接

​		动态链接技术可以把库的链接推迟到程序运行时。

`gcc -fPIC -o a.o -c a.cpp`

`gcc -shared -o libxxx.so a.o`

`gcc -fPIC -shared -o libxxx.so a.o`

- `-fPIC`：编译成位置独立的代码。

  ​	否则编译后的代码是位置相关的，动态载入是通过代码复制的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。

- 链接库的指定和静态库的相同

- 运行时目录搜索

  ​	程序在部署后，对动态库的搜索会按照下述顺序进行：

  - `-L`指定的路径

    > 坑一般在这里，编译环境和部署环境中动态库位置不同

  - 环境变量`LD_LIBRARY_PATH`指定的动态库搜索路径

  - 配置文件`/etc/ld.so.conf`中指定的动态库搜索路径

    - 添加后直行`ldconfig`生效

  - 默认系统动态库搜索路径`/lib`

  - 默认用户动态库搜索路径`/usr/lib`

  - 可以通过`-rpath`指定运行时搜索路径

#### 对比

- 动态库利于进程间共享

  ​		在运行程序的机器中，操作系统在某个库中某个片段首次被任意程序需要时加载进内存，然后被所有需要该库该片段的所有进程共享。

- 动态库使程序升级变得简单

  ​		静态库在发生变化时，要使用更新就需要重新编译使用该静态库的程序。对于动态库来说，只要使用动态库的接口原型没有改变，就无须编译依赖该库的程序，只需重新生成动态库，替换原来的库文件就可以了。

- 可以真正做到链接载入由程序员在程序代码中控制

  ​		可以在代码中明确指明什么时候或者什么情况下，链接载入哪个动态库接口。可以做到在大型软件中，由于不同的操作需求，只有一小部分程序被载入内存。

  ​		如读写不同类型的文件，用动态库来实现，所需文件类型的读写在需要时才被载入，而不是一次性在开始时载入而很长时间并没有使用，造成低效。

- 静态库在编译时以复制的方式装载到可执行程序，使用静态库的程序体积更大，但速度更快。动态库在使用时，先装载才能使用。





