# 预处理器

C语言/语法/预处理器

---

​		预处理器在**翻译阶段 4**执行，在编译之前进行。

​		预处理的结果将作为单个文件传递给实际编译器.



## 预编译指令

​		预处理指令控制预处理器的行为，每个指占据一行，且有下列各式：

- `#` 字符

- 预处理指令（ `define` 、 `undef` 、 `include` 、 `if` 、 `ifdef` 、 `ifndef` 、 `else` 、 `elif` 、 `endif` 、 `line` 、 `error` 、 `pragma` 之一）

  > ​		这些是标准定义的指令。标准不定义其他指令的行为。
  >
  > >  		非标准扩展指令可能被忽略，或拥有有用的含义，或令程序为病式。
  > >
  > > ​		即使在被忽略的情况下，在预处理器完成时也将它们从源代码移除。
  > >
  > > 一个常见的非标准扩展是指令 `#warning` ，它在编译中发出用户定义的信息。

- 实参（依赖于指令）

- 换行符

允许空指令（跟随换行符的 `#` ），而它无效果。



## 能力

### 源文件翻译能力

#### 条件性

> 依据条件，有选择的编译源文件的部分。 
>
> 指令包括`#if / #ifdef / #ifndef / #else / #elif / #endif`。

​		条件预处理块以`#if / #ifdef / #ifndef` 开始，然后可选的包含任意数量的`#elif`指令，然后可选的包含最多一个`#else`指令，并以`#endif`指令结束。

​		任何内部条件预处理块都是分开处理的。

​		每个`#if / #elif / #else / #ifdef / #ifndef` 指令控制到第一个不属于任何内部条件预处理块的`#elif / #else / #endif`指令位置的代码块。

​		`#if / #ifdef / #ifndef ` 指令测试指定条件， 如为true，则编译其控制的代码块。这种情况下会忽略后续的`#else`和`#elif`指令。如果为`false`，则跳过其控制的代码块，处理后续的`#else / #elif`指令。`#else`无条件编译，而`#elif` 如同`#if`一样。最后以`#endif`指令终止。

##### #if / #elif

​		表达式为常量表达式，仅适用常量和用`#define`指令定义的标识符。

> 任何非常量，没有以`#define`指令定义的标识符，求值都为0.

​		表达式可以含有形式为`defined 标识符` 或`defined (标识符)` 的一元运算符，如果用`#define`指令定义了该标识符，则返回1，否则返回0.、

​		如果表达式求值为非零值，则包含该控制代码块并跳过其他。若所用的任何标识符不是常量，则用0替换它。

> （C23）预处理语境中，`__has_c_attribute`表达式检测给定属性记号是否受支持及其受支持版本。
>
> ps：C语言/语言/声明/属性

> 注： DR 412 前，“`#if cond1` ... `#elif cond2`”和“`#if cond1` ... `#else`”后面跟着“`#if cond3`”是不同的，因为当 `cond1` 为真时第二个 `#if` 将被跳过，且 `cond3` 并不需要是良构的，而 #elif 中的 `cond2` 则必须是合法的表达式。 DR 412 开始，引领跳过的代码块的 #elif 也被跳过。

##### #ifdef / #ifndef

​		检查是否用`#define`指令定义了标识符。

​		`#ifdf 标识符`本质上等价于`#if defined 标识符`

​		`#ifndef 标识符`本质上等价于`#if !defined 标识符`

#### 替换

​		替换文本宏，可以连接或加引标识符。

​		指令包括`#define / #undef / # / ##`

> `#define 标识符 替换列表(可选)`
>
> `#define 标识符(形参) 替换列表`
>
> `#define 标识符(形参, ...) 替换列表`
>
> `#define 标识符(...) 替换列表`
>
> `#undef 标识符`

##### #define指令

​		#define指令把标识符定义为宏，可以有选择性的增加附加处理。

​		若标识符已经定义为任何类型的宏，则程序为病式，除非定义相同。

> **宏：**
>
> ​		指示编译器将所有后续出现的对应标识符替换为 替换列表 列出的内容。

###### 仿对象宏

​		`#define 标识符 替换列表(可选)`

​			用替换列表替换所有 所定义的标识符。

###### 仿函数宏

​		用替换列表替换所有 所定义的标识符，并接受若干参数，会替换替换列表中对应的形参。

​		仿函数宏的调用语法与函数调用语法相似，每个宏名实例后跟一个与处理了记号`(`，向替换列表中替换形参，然后由`)`终止，跳过中间已经匹配的`()`小括号对。

​		实参数量必须与宏定义中形参的的数量相同，否则程序为病式。如果标识符不在函数记号中（自身不后随括号），则决不替换它。

`#define 标识符(形参) 替换列表`				简单仿函数宏

`#define 标识符(形参, ...) 替换列表`		有可变参数的仿函数宏，能用`__VA_ARGS__`标识符访问额外实参，然后该标识符被实参替换。

`#define 标识符(...) 替换列表`				 有可变参数的仿函数宏，但没有常规参数。只能用`__VA_ARGS__`标识符访问实参，然后该标识符被实参替换。

> **注意：**
>
> ​		若仿函数宏的实参包含逗号，且没有被成对的`()`所保护，则将逗号带入，称为宏实参分隔符，最终因实参数量不合导致编译失败。
>
> ```c
> macro(array[x = y, x + 1]);
> atomic_store (p, (struct S){ a, b });
> ```



##### # 与 ## 运算符

###### #

​		`#`为字符串化运算符，在仿函数中，替换列表里的 `#`运算符，对它后随的 标识符进行形参替换，并用双引号使结果变成字符串字面量。

>  如果标识符中存在双引号，预处理器会对其添加`\`进行转义，即`\"`。
>
> `#` 会移除所有标识符中前后的空白符，且将标识符中间部分的连续多个空白符序列改为单个空格，但如果标识符内部有字符串字面量则按字符串字面量的文本原样。

​		如果字符串化的结果不是合法字符串字面量，则行为未定义。

![image-20210818235610501](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210818235610501.png)



###### ##

​		`##`为连接（记号粘贴）运算符，将替换列表中任意两个在`##`前后的标识符进行参数替换后连接为一个新的标识符。

​		连接后的标识符必须是合法的标识符、合法的数字序列、+=运算符。

> 不能通过`##`将`/`和`*`连接创建注释，因为注释被认为在宏替换前已经被移除了。
>
> 如果连接的结果不是合法的标识符，则行为未定义。
>
> **NOTE：**
>
> ​		一些编译器允许`##`出现在逗号和`__VA_ARGS__`中间，此时当`__VA_ARGS__`不为空时无效，为空时移除逗号。这样就可以定义
>
> ```c
> fprintf(stderr, format, ##__VA_ARGS__)
> ```
>
> 这样的宏。

##### #undef

​		将已定义的标识符卸载定义，取消先前`#define` 对标识符的引入。如果标识符没有与之关联的宏，则忽略此指令。



```c
// make function factory and use function
#define FUNCTION(name , a) int fun_##name(int x) { return (a)*x; }

FUNCTION( quadruple, 4 );
FUNCTION( double, 2 );

#undef FUNCTION

#define FUNCTION 34
#define OUTPUT(a) puts( #a )

void test_2()
{
    printf( "quadruple(13): %d\n", fun_quadruple( 13 ) );
    printf( "double(21): %d\n", fun_double( 21 ) );
    printf( "%d\n", FUNCTION );
    OUTPUT( million );
}
```





#### 包含

​		把另一文件引入，并展开到当前源文件中`#include`指令下一行的位置。

​		`#include <文件名>`

> ​		搜索实现控制下的文件（操作系统包含目录），典型的实现为仅搜索标准包含目录。标准C++库和标准C库被隐式包含于这些标准包含目录。用户通常能通过编译器选项控制标准包含目录里。

​		`#include "文件名"`

> ​		搜索不在实现控制下的文件，典型实现为首先搜索当前文件所在的目录，然后在找不到的情况下在上述的标准包含目录搜索。

​		如果文件找不到，程序为病式。

> 可以包含任意文件并替换内容，但要注意所替换的文件是否能够与当前文件组成有效的翻译单元。



#### 引起错误

​		显示给定的错误消息，并令程序为病式。

​		`#error 错误消息`

> 实现在遇到`#error`指令后，显示错误消息，并使得程序为病式，停止编译。
>
> 错误消息 可以由多个词组成，不必在引号中。

```c
#if __STDC__ != 1
#error "Not a standard compliant compiler"
#endif

#include <stdio.h>

int main( void )
{
    printf( "It is a standard compiler conforming to ISO C standard !!" );
}
```





### 预处理器控制能力

#### 实现定义

​		由 `#pragma` 指令控制实现定义行为。以指令`#pragma`及运算符`_Pragma`控制。

​		pragma 指令控制编译器的实现指定行为，如禁用编译器警告或更改对齐要求。忽略任何不被识别的 pragma 。

​		`#pragma 语用形参`

> 以实现定义方式行动（除非 *语用形参* 是后述的标准 pragma 之一）。

​		`_Pragma ( 字符串字面量 )`

> 移除 *字符串字面量* 的编码前缀（若存在）、外层引号，及开头/尾随空白符，将每个 `\"` 以 `"` ，每个 `\\` 以 `\` 替换，然后记号化结果（如[翻译阶段 3](https://zh.cppreference.com/w/c/language/translation_phases) 中），再如同在 (1) 中输出到 `#pragma` 一般使用结果。

##### 标准pragma

​		语言标准定义下列三个 pragma ：

​		`#pragma STDC FENC_ACCESS 实参`

> 若设为 `ON` ，则告知编译器程序将访问或修改浮点环境，这意味着禁用可能推翻标志测试和模式更改（例如，全局共用子表达式删除、代码移动，及常量折叠）的优化。默认值为实现定义，通常是 `OFF` 。

​		`#pragma STDC FP_CONTRACT 实参`

>  允许*缩略*浮点表达式，即忽略舍入错误和浮点异常的优化，被观察成表达式以如同书写方式准确求值。例如，允许 (x*y) + z 的实现使用单条融合乘加CPU指令。默认值为实现定义，通常是 `**ON**` 。

​		`#pragma STDC CX_LIMITED_RANGE 实参`

> ![image-20210819010454014](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210819010454014.png)

注意：不支持这些 pragma 的编译器可能提供等价的编译时选项，例如 gcc 的 `-fcx-limited-range` 和 `-ffp-contract` 。

##### 非标准pragma

​		`#pragma once`

> ​		受大部分现代编译器支持，当某个头文件中包含它时，指示编译器只对其分析一次，即使它在同一源文件中（直接或间接）被包含了多次也是如此。即文件**防卫式声明**。
>
> > **防卫式声明：**
> >
> > ​		阻止同一头文件的多次包含的标准方式是使用[包含防护](https://en.wikipedia.org/wiki/Include_guard)
> >
> > ```c
> > #ifndef LIBRARY_FILENAME_H
> > #define LIBRARY_FILENAME_H
> > // 头文件的内容
> > #endif /* LIBRARY_FILENAME_H */
> > ```
> >
> > ​		从而在任何翻译单元中，该头文件除首次以外被包含时都被排除出编译。所有现代编译器都记录头文件使用了包含防护的事实，只要该防护仍有定义，再遇到该头文件时就不再分析它。
>
> ​		使用`` #pragma once`` 时，同一个头文件可以变为
>
> ```c
> #pragma once
> // 头文件的内容
> ```
>
> ​		不同于头文件防护，这条语用使得错误地在多个文件中使用相同的宏名变得不可能。
>
> ​		另一方面，因为带 ``#pragma once`` 的文件是基于其文件系统层次的身份所排除的，而不是文件内容，所以若头文件在项目中有多个位置，则这不能防止包含它两次。

​		`#pragma pack`

> ​		此 pragma 族控制后继定义的结构体和联合体的最大对齐。
>
> ​		``#pragma pack(实参)`` , 设置当前对齐为值 *实参* 。
>
> ​		`#pragma pack()`,   设置当前对齐为默认值（由命令行选项指定）
>
> ​		`#pragma pack(push)`,  推入当前对齐的值到内部栈。
>
> ​		`#pragma pack(push, 实参)`,  推入当前对齐的值到内部栈然后设置当前对齐为值 *实参* 。
>
> ​		`#pragma pack(pop)`，从内部栈弹出顶条目然后设置（恢复）当前对齐为该值。
>
> > 实参是 2 的幂，指定以字节计的新对齐。
> >
> > `#pragma pack` 可以指定结构体的对齐，然而它不能使结构体过对齐。
>
> 

#### 文件名与行信息·

​		在预处理器中更改当前行号和文件名，指令`#line`。

​		`#line 行号`

> 更改当前预处理器行号为 所指定的行号 。从此点开始，宏 ``__LINE__`` 的出现会展开成 *行号* 加上自此遇到的实际代码行数。

​		`#line 行号 "文件名"`

> 亦将当前预处理器文件名更改为 *文件名* 。此点后宏 ``__FILE__`` 的每次出现将生成 *文件名* 。

​		任何预处理器记号（宏常量及表达式）都允许出现为 `#line` 的参数，只要它们展开成合法的十进制整数，可以后随一个合法的字符串。

​		*行号* 必须是至少有一个十进制位的序列（否则程序为病式），并且始终按十进制转译（即使它以 `0` 开始）。

​		若 *行号* 为 0 或大于 32767 (C99 前)2147483647 (C99 起) ，则行为未定义。

> 一些自动代码生成工具从以其他语言书写的文件产生 C 源文件，它们会使用此指令。
>
> 该情况下，它们可能插入引用原始（人类可读）源文件的行号和文件名的 `#line` 指令到生成的 C 文件中。

​		后随指令``#line __LINE__ ``的行号是实现定义的（该情况下 ``__LINE__`` 能展开成二个可选值：到此为止所见的换行符数，或到此为止所见的换行符数加上结束 `#line` 指令的换行符）

```c
#include <assert.h>
#define FNAME "test.c"
int main(void)
{
#line 777 FNAME
        assert(2+2 == 5);
}
```



## 预定义宏

​		下列宏预定义在每个翻译单元中：

`__STDC__`， 展开成整数常量1。，此宏是用来指示一致实现的。

`__STDC_VERSION__`， 展开成`long`类型的整数常量，其值随着C标准的版本不同:

> - c95, `199419L`
> - C99, `199901L`
> - C11, `201112L`
> - C17, `201710L`

`__STDC_HOSTED__`，如果在操作系统宿主上运行，则展开成整数常量 1.如果是独立实现，则展开成 0.

`__FILE__`，展开成当前文件名，为字符串字面量，可用`#line`指令更改

`__LINE__`，展开成源文件行号，为整数常量，可用`#line`指令更改

`__DATE__`，展开成翻译的日期，格式为`Mmm dd yyyy`的字符串字面量，月份名如同以 `asctime`生成，而若月之日期小于 10 则 "dd" 的首字符为空格

`__TIME__`，展开成翻译的时间，格式为`hh:mm:ss`的字符串字面量，如同`asctime()`所生成

​		下列宏可能会依据实现的不同，预定义在翻译单元中：

![image-20210819003239260](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210819003239260.png)



​		这些宏的值（除了 `__FILE__` 和 `__LINE__` ）在整个翻译单元中保持常量。尝试重定义或解除定义这些宏导致未定义行为。

​		预定义对象 `__func__` （细节见[函数定义](https://zh.cppreference.com/w/c/language/function_definition#func)）不是预处理器宏，尽管有时与 `__FILE__` 及 `__LINE__` 一同使用它，例如通过 `assert` 。