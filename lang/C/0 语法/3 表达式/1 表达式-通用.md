# 表达式-通用

C语言/语法/表达式/通用

---

​		表达式是运算符及其操作数的序列，它指定一个运算。

​		表达式求值可以产生结果，并可以指代对象或函数，可能会产生其他功能性的复效应（如求值表达式`printf("%d,4")`时，还会将4发送到标准输出流。

​		表达式包括带参数的运算符、函数调用、常量、变量名等。

​		每个表达式以两个独立属性 类型和 值类别来刻画。

## 值类别

​		值类别将表达式以其值分类为：左值、非左值对象、函数指代器。

### 左值表达式

​		任何不是void类型的对象类型，隐含的指代一个对象。

> ​		左值表达式求值得到一个对象标识。
>
> ​		左值在求值时不实际指代一个对象时，行为未定义。
>
> ​		“左值”是历史遗留的名称，放映了在CPL中，左值表达式作为赋值运算符的左运算数。

​		左值表达式可以用于左值语境：

- 取址运算符的运算数

  > 但不包括位域 或 声明为`register`的左值。
  >
  > > 位域不单独占用以字节为单位的存储空间，无法使用以字节编址的地址。
  > >
  > > `register`将左值加载到cpu缓存中，脱离内存地址范畴。

- 前后自增运算符的运算数

- 成员访问运算符的左运算数

- 赋值及复合赋值运算符的左运算符



​		 除去上述运算符和`sizeof`和`_Alignof`运算符，左值表达式在其他运算符中使用则会使得任何完整类型的 非数组左值经历左值转换。这模仿的是从对象位置到其值的内存加载。

> **左值转换：**
>
> ​		任何非数组类型的左值表达式，如果有`const / volatile / restrict` 限定符及原子属性，会失去这些限定符或原子属性，但保持类型相同。
>
> ps：C语言/语言/表达式/通用/转换/值变换/左值转换
>
> > `const / volatile / restrict` 限定符及原子属性的语义仅适用于左值。

​		在除`sizeof / _Alignof`、取址运算符 和 字符串字面量初始化数组之外，数组左值会经历数组到指针的退化转换。



​		左值表达式：

- 标识符

  > 包括具名函数形参，只要声明为指代对象（而非函数）

- 字符串字面量

- 复合字面量

- 括号表达式

  > 如果其无括号版本是左值则成立

- 成员访问运算符的结果

  > 如果左操作数是左值

- 指针访问成员运算符的结果

- 间接使用运算符（一维 * )作用域指向对象指针

- 下标运算符的结果



#### 可修改左值表达式

​		任何完整类型、非数组、且非`const `限定的左值表达式 是一个可修改左值表达式。而且如果它是结构体或联合体，则递归地不包含任何`const`限定的成员。

​		只有可修改左值表达式可用作自增运算符的参数，赋值和复合赋值运算符的左参数。

​	

### 非左值对象表达式

​		通常称作右值。非左值表达式是一种对象类型表达式，但不指代对象，而是指代没有对象身份或存储位置的值。

​		不能对非左值表达式取址。

​		

​		非左值对象表达式：

- 整数、字符、浮点数常量

- 所有不返回左值的运算符

  - 函数表达式

  - 转换类型表达式

    > 与之相似的复合字面量是左值

  - 非左值结构体或联合体的成员访问运算符

    > `f().x, (x, s1).a, (s1=s2).m`

  - 所有算数、关系、逻辑及位运算符

  - 自增和自减运算符

    > 前置的版本在c++中是左值

  - 赋值及复合赋值运算符

    > 在c++中是左值

  - 条件运算符

    > c++中可能是左值

  - 逗号表达式

    > c++中可能是左值

  - 取址运算符

    > 即使用 一元 * 运算符的结果中和，仍然是右值

> 特殊情况，
>
> ​		void类型表达式被假设为非左值对象表达式，得到一个不存在表示 并且 不要求存储的值。

​		拥有一个数组类型成员（可嵌套）的结构体或联合体右值实际上指代一个拥有临时生存期的对象。此对象可以通过由索引数组元素组成的左值表达式，或解引用该数组的 数组到指针的转换 得的指针访问。



### 函数指代器表达式

​		由函数声明引入的标识符，即函数指代器，是函数类型的表达式。当在除取址运算符、`sizeof / _Alignof` 之外的语境中，函数指代器始终转换成指向函数的非左值指针。

> 注意函数调用运算符是对函数指针定义的，非不是对函数指代器自身定义的。
>
> 在`sizeof / _Alignof` 中使用函数指代器，会发生编译错误。



## 求值顺序与定序

​		参数和子表达式的求值顺序决定了会得到什么样的表达式中间结果。

> ​		除本节说明的情况之外的C运算符的运算顺序，包括函数调用表达式的函数参数求值顺序，以及任何表达式的子表达式的求值顺序都是未指定的。编译器可能以任意顺序对其求值，且同一表达式多次求值的顺序可能并不一致。
>
> ​		C 中没有从左到右或从右到左求值的概念，这不会与运算符的从左到右或从右到左结合性混淆：表达式 `f1() + f2() + f3()` 被分析成 `(f1() + f2()) + f3()` ，因为 operator+ 的从左到右结合性，但运行时对 `f3` 的函数调用可以最先、最后，或在 `f1()` 与 `f2()` 之间求值。

### 求值

​		每个表达式或子表达式的求值都可能产生两种结果：

- 值计算（value computation）， 计算表达式所返回的值。

  > 可以涉及到 确定对象身份（左值求值）， 或读取之前赋值给对象的值（右值求值）

- 副效应（side effect），可能产生如下影响：

  读写以`volatile`左值指代的对象，修改对象、原子同步、修改文件、修改浮点环境或调用进行上述操作的函数。



​		如果表达式不产生副效应，且编译器能确定其值不被使用，则表达式可以不求值。

### 排序

​		**先序**是一种在线程内 求值的部队向、传递性、成对的关系。如果进行内存保护（原子类型、内存屏障，则可以拓展到线程之间）。

- 如果在子表达式 1， 2之间存在序列点，则 1 的值计算和副效应都 先序 于 2 的所有值计算和副效应

  > *序列点（ [sequence point](https://en.wikipedia.org/wiki/Sequence_point) ）*

  （下述C11起）

- 如果求值 1 先序于 2 ， 则求值 1 将在求值 2 开始前完成

- 如果求值 1 不先序于 2 ， 并且求值2 先序于 1， 则求值 2 将在求值 1 开始前完成

- 如果求值1 不先序与 2， 并且求值 2 不先序于 1， 则

  - 求值1 ，2 无序，顺序是随机的，并且可以交错（在单一线程中，分时间片交错的写入 构成 1 和 2 的CPU指令）
  - 求值1， 2 非确定顺序，顺序是随机的，但不可以交错，要么是1先完成，要么是2先完成。



### 规则

1. 函数参数和函数指代器求值后，函数调用前，有一个序列点

2. `&& / || / ,` 三个二元运算符的左操作数求值后，右操作数求值前，有一个序列点

3. 条件运算符`?:`的左运算数求值后，并列的右运算数（2/3）求值前，有一个序列点

4. 完整表达式求值后，下个完整表达式求值前，有一个序列点

   > 非子表达式的表达式，典型的是以分号为结尾的，或者`if / switch / while / do`的控制语句

5. 完整声明器的结尾有一个序列点

6. 紧接库函数返回之前，有一个序列点

7. 格式化I/O中，关联到每个转换指定符的动作后，有一个序列点

   > 转换指定符，就是format格式列表中每个以`%`引导的格式符。
   >
   > 特别是`scanf`写入同一变量的不同域时，`printf`读取并以超过一次的使用`%n`修改同一变量是良式的。
   
8. 在每次通过库函数`qsort`和`bsearch`调用比较函数前后，各有一个序列点，`qsort`调用比较函数和移动对象之间也有序列点。

   （以下C11起）

9. 运算数的值计算 先序于运算符的值计算（非副效应）

10. 直接复制运算符和所有复合赋值运算符 左右参数的值计算（非副效应）先序于运算符的副效应（修改左参数）

11. 后自增和后自减运算符的值计算先序于其副效应

12. 不先序也不后序于另一函数调用的函数调用是非确定顺序的

    > 构成不同函数调用的 CPU 指令不可能交错，即使函数被内联

13. 在初始化器列表表达式中，所有求值都是非确定顺序的

14. 考虑到非确定顺序的函数调用，复合赋值运算符，自增减运算符的前后缀形式都是单独求值。

### 未定义行为

​		如果对一个标量对象的复效应和另一个对同一标量对象的副效应相对无顺序，则行为未定义

```c
i = ++i + i++;	// UB
i = i++ + 1; 	// UB
f(++i, ++i); 	// UB
f(i = -1, i = -1); // UB
```

​		如果一个标量对象上的副效应与另一个使用同一标量对象之间的值计算相对无序，则行为未定义

```c
f(i, i++); // UB
a[i] = i++; // UB
```

​		只要至少一个子表达式的排序允许这种无顺序副效应，就应用上述规则。

## 转换



## 泛型选择

​		

