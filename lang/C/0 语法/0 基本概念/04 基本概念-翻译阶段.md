# 翻译阶段

C语言/语言/基本概念/翻译阶段

---

​		编译器处理C源文件时，严格下列的顺序进行各个阶段的处理。



## 1  字符翻译

### <1> ASCII 码字符翻译

​		（以实现定义方式）将源文件的各个单独字节，映射为*基本源字符集*的字符。特别是，操作系统相关的行尾指示符均被替换为换行字符。

​		源文件通常是以某种 多字节字符编码的文本文件，比如utf8编码的文本文件。

**基本源字符集（The *basic source character set* ）96个：**

- 空白符 5个

  - 空格符（space）
  - 水平制表符（horizontal tab）
  - 垂直制表符（vertical tab）
  - 换页（form feed）
  - 换行（new-line）

- 数字字符 10个

  从```‘0’```到```‘9’```

- 大小写英文字母 52个

  从```a```到```z```以及```A```到```Z```

- 标点符号 29个

  ```_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '```



### <2> 三标符翻译

​		将各个**三标符序列**替换为其对应的单字符表示.

> **三标符序列：**
>
> ps：C语言/语言/基本概念/字符处理/三标符



## 2 代码行辨识

### <1> 合并代码行

​		当反斜杠出现于行尾（其后紧跟换行符）时，删除该反斜杠和换行符并将两个物理源码行组合成一个逻辑源码行。

​		这是单趟操作：如果有一行以两个反斜杠结束且后随一个空行，这三行不会合为一行。

### <2> 行末辨识

​		若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则其行为未定义 。



## 3 辨识注释和字符串字面量

### <1> 分解源文件文本

​		将源文件切分为 **注释**、**空白符**、**预处理记号**

> **预处理记号：**
>
> 1. 头文件名，如 ```<iostream> ```或 ```"myfile.h"```
> 2. 标识符
> 3. 预处理数字（整型常量和浮点常量，但也包括一些非法记号，如``1..E+3.foo`` 或 ``0JBK``
> 4. 包括用户自定义的字符与**字符串字面量（literal）**
> 5. 运算符与标点（包括**代用记号**），如 +、<<=、<%、## 或 and
> 6. 不属于任何其他类型的单独单独非空白字符
>
> > **代用记号：**
> >
> > ​		部分符号的代用写法。
> >
> > ps: c语言/语言/基本概念/字符处理
> >
> > **字面量：**
> >
> > ​		直接表达逻辑含义的值。
> >
> > ps: c语言/语言/表达式/字面量
>
> 对于预处理记号的辨识有如下要点：
>
> - 最大吞噬
>
>   若一个给定字符前的输入已被解析为预处理记号，下一个预处理记号通常会由能构成预处理记号的最长字符序列够成，即使这样处理会导致后续分析失败。
>
>   ```c
>   int foo = 1;
>   int bar = 0xE+foo;   // 错误：非法的预处理数字 0xE+foo
>   int baz = 0xE + foo; // OK
>   
>   int quux = bar+++++baz; // 错误：bar++ ++ +baz，而非 bar++ + ++baz。
>   ```
>
>   对于最大吞噬，有一个例外：
>
>   > - 头文件名预处理记号仅在#include 指令中和 #pragma 指令中的实现定义位置形成
>   >
>   >   ```c++
>   >   #define MACRO_1 1
>   >   #define MACRO_2 2
>   >   #define MACRO_3 3
>   >   #define MACRO_EXPR (MACRO_1 <MACRO_2> MACRO_3) // OK ： <MACRO_2> 不是头文件名
>   >   ```
>   >
>   > 
>   >
>   > 
>   >
>   > **原始字符串字面量：**
>   >
>   > ​	原始字符串字面量，即裸字符串。声明```R“()”```包裹的字符串，期间的任何字符都将作为字符串字面量的一部分而存在，不会对其间引起字符串结束的符号进行辨识。
>   >
>   > ​	ps : c++/基础语法/表达式/字面量

### <2> 以一个空格字符替换每段注释

### <3> 保留换行符

​		由实现定义未是否可将非换行的空白字符序列缩减成单个空格字符。



## 4 预处理阶段

### <1> 执行预处理器

### <2> #include指令所引入的每个文件都 递归的 经历从1到4的处理阶段

### <3> 此阶段结束时，从源码移除所有预处理指令



## 5 源代码字符转换到执行字符

### <1> 字符的字符集转换

​		将字符常量及字符串字面量中所有字符和转义序列，从源字符集转换成执行字符集。

​		执行 字符集可以是utf-8这样的多字节字符集，只要来自阶段1中所列的基本源字符集的96个字符都在该字符集中拥有对应的单字节表示。

​		若转义序列所指定到的字符不是执行字符集的成员，则结果是实现定义的，但保证不是空（宽）字节。

> **Note：**
>
> ​		某些实现中，能以命令行选项控制此阶段所进行的转换： gcc 和 clang 用 -finput-charset 指定源字符集的编码，用 -fexec-charset 和 -fwide-exec-charset 指定无编码前缀的 (C11 起)字符串字面量和字符常量中的执行字符集的编码。

## 6 拼接系那个令的字符串字面量

```c
const char* s3 = "\n"
                 "Hello\n"
                 "  World\n";

-> const char* s3 = "\nHello\n  World\n";
```



## 7 编译阶段

​		进行编译：将各个预处理记号转换成记号。

​		将所有记号当做一个独立的编译实体，将它们进行语法和语义分析翻译成翻译单元。

> **翻译单元：**
>
> ​	一个经预处理过后的源代码文件（.c/.cpp/.hpp...)，会被编译器当做一个独立可单独编译的最小单元，编译它所需的所有依赖都会通过`#include`和源代码声明的方式引入。一个翻译单元经过编译后，会形成一个目标文件（.o)。
>
> ​		注意，此时说的依赖，都是指编译时的名字依赖，即只需要其声明。当链接时，会需要查找所有名字的定义，进而查找本翻译单元的定义或外部链接的定义。
>
> https://www.dazhuanlan.com/2019/09/28/5d8ed410d7003/
>
> **编译时错误**
>
> 在编译器发现的错误叫编译时错误。链接器发现的错误叫链接时错误。运行时才发现的错误叫做运行时错误或逻辑错误。



## 链接阶段

​		由链接器，将翻译单元和为满足外部引用所需的库组件汇集成一个程序映像，它含有在其执行环境中（OS）执行所需的信息。























