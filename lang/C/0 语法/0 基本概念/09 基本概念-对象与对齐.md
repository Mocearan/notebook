# 对象与对齐

C语言/语法/基本概念/对象与对齐

---

​		一个对象时执行环境中**数据存储**的一个区域，其内容可以表示**值**。

> **数据存储：**
>
> ​		C程序的数据存储（内存）是一个或多个连续字节的序列。
>
> **值：**
>
> ​		值是对象的内容转译为特定类型时的含义。

​		每个对象拥有：

- 大小

  `sizeof` 确定

- 对齐要求

  `_Alignof` 确定

- 存储期

  自动、静态、动态、线程局部

- 生存期

  等于存储期或临时

- 有效类型

- 值

- 可选项

  表示该对象的标识符



 		对象由声明、分配函数、字符串字面量、复合字面量，及返回拥有数组类型的结构体或联合体的非左值表达式创建。



## 对象表示

​		除了**位域**对象，每个可以被复制到`unsigned char[n]`类型数组中的对象，都由一个多个字节组成，每个字节由`CHAR_BIT`个位组成。这样的`unsigned char[n]`数组称为对象表示。

> **位域：**
>
> ​		拥有以位数表示的显式宽度的成员。
>
> ps：C语言/语言/声明/位域
>
> **CHAR_BIT：**
>
> ​		每个字节的位数。位于数值极限中定义。

> **对象相等：**
>
> ​		如果两个对象拥有相同的对象表示，则它们之间进行比较则相等（除了是浮点NaN的情况）。
>
> ​		两个进行比较相等的对象可以拥有不同的对象表示，因为并非对象表示的每一位都需要参与其值，这些不参与表示值的位可能是进行对齐的填充位、等同性检测、指示陷阱等。

> **指示陷阱：**
>
> ​		如果一个对象表示不表征该对象类型的任何值，则它被称为陷阱表示。
>
> ​		不以 字符类型左值表达式 的方式访问陷阱表示是未定义行为。
>
> ​		即便任意一个成员的值是陷阱表示，结构体和联合体的值始终不是陷阱表示。

> **单字节对象表示：**
>
> ​		对于`char`、`signed char`、`unsigned char` 类型的对象，对象表示的每一位都要参与值表示，而且每种可能的位模式都表示不同的值（不允许填充位、陷阱位或多重表示）

> **整数类型的对象表示：**
>
> ​		`short、int、long、long long`，对象占用多个字节时，这些字节的用法是计算平台实现定义的，不过两种主要使用的实现是
>
> - 大端（big-endian），在（POWER、Sparc、Itanium）上
>
> - 小段（littel-endian），在（x86、x86-64）上
>
>   ​	大端平台将对象表示的最高位字节，存储在所占存储空间的低位地址上。
>
>   ​	小端平台将对象表示的最高位字节，存储在所占存储空间的高位地址上。
>
> > https://en.wikipedia.org/wiki/Endianness
>
> ​		尽管大多数实现都不允许整数的陷阱表示、填充位或多重表示，也还存在例外；例如 Itanium 上的整数类型值[就可以是陷阱表示](https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003)

​	

## 有效类型

​		每个对象都拥有有效类型，它决定什么样的左值访问合法，什么样的违法你严格别名使用规则。

​		如果对象是由声明创建的，则该对象的声明类型就是对象的有效类型。

​		如果对象是由动态分配函数创建的，则它没有声明类型，这种对象以下列方式获得有效类型：

- 第一次通过非字符类型的左值写入该对象

  ​	无论何时该左值的类型都会成为该对象此次写入和后续所有读取的有效类型。

- memcpy和memmove复制另一个对象到该对象

  ​	无论何时源对象的有效类型都会成为该对象此次写入和后续所有读取的有效类型。

- 任何其他对无声明类型的对象的访问

  ​	有效类型是访问所有的左值类型

## 严格别名使用

​		对于一个拥有有效类型T1的对象，用不同类型的T2的左值表达式（如解引用指针）访问它是未定义行为，除非

- T2和T1是兼容类型
- T2的cvr限定类型与T1兼容
- T2的有符号和无符号类型与T1兼容
- T2是聚合体或联合体类型，成员中包含一个上述类型（递归的包括子聚合体或被包含联合体的成员）
- T2是字符类型（`char`、`signed char`、`unsigned char`）

```c
int i = 7;
char *pc = (char *)(&i);
if (pc[0] == '\x7')
{ // 通过 char 别名使用是 OK 的
    puts("This system is little-endian");
}
else
{
    puts("This system is big-endian");
}

float *pf = (float *)(&i);
float d = *pf; // UB ： float 左值 *p 不能用来访问 int
```

​		这些规则控制接受两个指针的函数，在通过一个指针写入后，是否必须重新读取另一个：

```c
// int* 与 double* 不能别名使用
void f2(int *pi, double *pd, double d)
{
    // 从 *pi 的读取可以只做一次，在循环前
    for (int i = 0; i < *pi; i++) {
        *pd++ = d;
        printf("%f ", *pd);
    }
}

struct S
{
    int a, b;
};
// int* 和 struct S* 可以别名使用，因为 S 拥有 int 类型的成员
void f3(int *pi, struct S *ps, struct S s)
{
    // 从 *pi 的读取必须在每次通过 *ps 写入后进行
    for (int i = 0; i < *pi; i++){
        *ps++ = s;
        printf("%d %d\n", (*ps).a, (*ps).b);
    }
}

int main(void) 
{
    int i = 10;
    double d = 3;
    // f2(&i, &d, 2); Segmentation fault
    struct S s = {
        .a = 1,
        .b = 2
    };
    struct S s2 = {
        .a = 2,
        .b = 3
    };
    f3(&i, &s, s2);  // 10 0
				   //  1074266112 0
}
```

> 第一个指针参数成了第二个指针参数的别名？
>
> **注意：**
>
> ​		restrict 限定符可用于指示二个指针不用作别名使用，即使规则允许它们如此
>
> ​		注意类型双关也可以通过联合体的非活跃成员进行

## 对齐

​		每个完整对象类型拥有对齐要求，它是一个size_t类型的整数值，表示此类型对象可以分配的连续地址之间的字节数。

​		合法的对齐值是2的非负整数次幂。

​		类型的对齐要求可以通过`_Alignof`获得。

​		为了满足结构体所有对象的对齐要求，一些成员后面可能会插入填充位。

```c
#include <stdio.h>
#include <stdalign.h>
 
// struct S 的对象可以分配于任何地址
// 因为 S.a 和 S.b 可以分配于任何地址
struct S
{
    char a; // 成员对象大小： 1 ，对齐： 1
    char b; // 成员对象大小： 1 ，对齐： 1
}; // 结构体对象大小： 2 ，对齐： 1
 
// struct X 的对象必须分配于 4字节边界
// 因为 X.n 必须分配于 4 字节边界
// 因为 int 的对齐要求（通常）是 4
struct X
{
    int n;  // 成员对象大小： 4 ，对齐： 4
    char c; // 成员对象大小： 1 ，对齐： 1
    // 剩余的三个字节进行空位填充
}; // 结构体对象大小： 8 ，对齐： 4
 
int main(void)
{
    printf("sizeof(struct S) = %zu\n", sizeof(struct S));
    printf("alignof(struct S) = %zu\n", alignof(struct S));
    printf("sizeof(struct X) = %zu\n", sizeof(struct X));
    printf("alignof(struct X) = %zu\n", alignof(struct X));
}
```

​		每个对象类型的对齐要求是强制的。所有类型中，最严格的基础对齐是`max_align_t`的对齐，最弱的对齐是字符类型（`char/signed char/unsigned char`的对齐，且等于1）.

> ​		若用 `_Alignas` 令一个对象的对齐严格于（大于） max_align_t ，则它拥有**扩展对齐要求**。
>
> ​		结构体或联合体的成员拥有扩展对齐，则结构体或联合体称为*过对齐类型*。是否支持过对齐类型是实现定义的，而且对于每种存储期的支持可以不同。

## 内存模型

​		为了C的抽象机制目的，定义计算机内存存储的语义。

​		C程序的数据存储（内存）是一个或多个连续字节的序列，内存中每个字节拥有唯一的地址。

### 字节

​		字节是内存的最小可寻址单元。它是一系列连续的位，字节足以容纳任何基础执行字符集（要求96个字符是单字节， 单字节子集的*基本源字符集*）。

​		C 支持大小为8或更多位的字节。

​		`char/ unsigned char / signed char`类型的存储和值表示，都使用一个字节，字节的位数可以用`CHAR_BIT`访问。

​		对于用字节表示其他基础类型的（包含大端和小端内存布局），见对象表示。

### 内存位置

​		内存位置是一个标量类型的对象（算数类型、指针类型、枚举类型）或非零长位域的最大连续序列。

```c
struct S {
    char a;     // 内存位置 #1
    int b : 5;  // 内存位置 #2
    int c : 11, // 内存位置 #2 （连续）
          : 0,
        d : 8;  // 内存位置 #3
    struct {
        int ee : 8; // 内存位置 #4
    } e;
} obj; // 对象“ obj ”由 4 个分离的内存位置组成
```



### 线程及数据竞争

​		执行的线程是一个程序中的控制流，它以调用顶层函数`thrd_create`或其他方法开始。

​		任意线程有可能访问程序中的任意对象

> 自动和线程局部存储期的对象也能通过指针被另一个线程访问

​		不同线程始终允许同时访问（读写）不同的内存位置，没有竞争和同步要求

> ​		如果所有声明在结构体中的成员都是位域（非零长），同时更新两个同一结构体内的非原子位域是不安全的，不管那些插入的位域大小是多少。

​		一个表达式的求值写入一个内存位置，而另一个求值读写同一内存位置时，我们称这两个表达式竞争同一数据，除非：

- 两个竞争求值时原子操作

- 一个竞争和另一个竞争有先后顺序（`memory_order`）

  ​	如果发生数据竞争，则程序未定义

> ​		特别是，`mtx_unlock`和另一线程的`mtx_lock`，从而解锁先于另一线程的加锁，这使得可以用互斥锁保证避免数据竞争。

> **内存顺序：**
>
> ​		线程从一个内存位置读取值时，它可能看到初始值、被同一线程写入的值，或被其他线程写入的值。
>
> ​		关于线程所做的写入对其他线程变得可见的顺序细节，见`memory_order`









