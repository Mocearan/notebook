# 类型系统

C语言/语言/基本概念/类型系统

> 本节只描述类型系统的结构，具体关于算数类型和类型支持的细节，查看：
>
> ​		C语言/语法/基本概念/算数类型
>
> ​		C语言/标准库/类型支持
>
> 关于各种类型的声明细节，查看：	
>
> ​		C语言/语法/声明/*

---

​		对象、函数和表达式拥有称为类型的属性，它确定存储于对象或表达式求值所得的二进制值的转移方式。

## 类型分类

​		对于下列每个类型，还有三个限定符中一个或多个的组合：const、volatile、restrict。

​		需在限定符语义允许的地方才能使用限定符。

> **限定符：**
>
> ​		限定类型的访问属性。
>
> ps：C语言/语言/声明/限定符

### void

### 基本类型

- 类型 `char`

- 有符号整数类型

  - 标准：`signed char`、`short`、`int`、`long`、`long long`
  - 扩展：由实现定义，如`__int128`

- 无符号整数类型

  - 标准： `_Bool`、`unsigned char`、`unsigned short`、`unsigned int`

    ​				、`unsgined long`、`unsgined long long`

  - 扩展：由实现定义，例如`__uint128`

- 浮点类型

  - 实浮点类型：`float`、`double`、`long double`
  - 复数类型：`float _Complex`、`double _Complex`、`long double _Complex`
  - 虚数类型：`float _Imaginary`、`double _Imaginary`、`long double _Imaginary`

### 枚举类型

​		

### 派生类型

- 数组类型
- 结构体类型
- 联合体类型
- 函数类型
- 指针类型
- 原子类型

## 类型组别

按照类型的不同属性，对类型进行分组

- 对象类型：所有不是函数类型的类型
- 字符类型：`char`、`signend char`、`unsigned char`
- 整数类型：`char`、有符号整数类型、无符号整数类型、枚举类型
- 实数类型：整数类型和实浮点类型
- 算数类型：整数类型和浮点类型
- 标量类型：算数类型和指针类型
- 聚合类型：数组类型和结构体类型
- 派生声明器类型：数组类型、函数类型和指针类型

## 兼容类型

​		不同翻译单元中如果有对同一对象或函数的声明，这些声明之间不必拥有相同的类型。它们只需要拥有相似的类型，即兼容类型。

​		同样的规则可以应用到函数调用和左值访问。实参类型必须与形参类型兼容，而左值表达式类型必须与被访问对象的类型兼容。	

> 如果涉及同一个对象或函数的两个声明不使用兼容类型，则程序的行为未定义。

### 兼容规则

两个类型兼容：

- 是同一类型（同类型名或由`typedef`引入的类型别用）

- 是兼容的无限定类型，相等同的cvr限定

- 是指针类型，并指向兼容类型

- 是数组类型，

  - 元素类型兼容

  - 如果都拥有常量大小，大小须相同。

    > 位置边界数组与任何兼容元素类型的数组兼容。
    >
    > VLA与任何兼容元素类型的数组兼容。

- 都是结构体/联合体/枚举类型时，

  - 其一以标签声明，另一必须以同一标签声明
  - 如果都是完整类型，则成员必须在数量上准确对应，以兼容类型声明，并拥有匹配的名称。
  - 如果都是枚举类型，则对应成员也必须拥有相同值。
  - 如果它们都是结构体或联合体，
    - 对应元素必须以同一顺序声明（结构体时）
    - 对应的位域必须拥有相同宽度

```c
// 翻译单元 1
struct S {int a;};
extern struct S *x;  // 与 TU2 的 x 兼容，但不与 TU3 的 x 兼容
// 翻译单元 2
struct S;
extern struct S *x; // 与两个 x 兼容
// 翻译单元 3
struct S {float a;};
extern struct S *x; // 与 TU2 的 x 兼容，但不与 TU1 的 x 兼容
 
// 行为未定义
```



- 其一为枚举类型，另一为该枚举的底层类型
- 函数类型时，
  - 返回值类型兼容
  - 都使用参数列表，参数数量相同（包括省略号）。
    - 对应参数，进行数组退化到指针，函数退化到指针的类型调整，去除顶层限定符后，须拥有相同类型
  - 其一是旧式（无参数）定义，另一有参数列表，
    - 参数列表不使用省略号，每个参数（函数参数类型调整后）都与**默认参数**提升后的对应旧式参数兼容。
  - 一个是旧式（无参数）声明，另一个拥有参数列表，参数列表不使用省略号，而所有参数（在函数参数类型调整后）不受默认参数提升影响。

> `char`与`signed char`兼容，但不和`unsigned char`兼容

```c
// 翻译单元 1
#include <stdio.h>
struct s {int i;}; // 与 TU3 的 s 兼容，但不与 TU2 的 s 兼容
extern struct s x = {0}; // 与 TU3 的 x 兼容
extern void f(void); // 与 TU2 的 f 兼容
int main()
{
   f();
   return x.i;
}
// 翻译单元 2
struct s {float f;}; // 与 TU4 的 s 兼容，但不与 TU1 的 s 兼容
extern struct s y = {3.14}; // 与 TU4 的 y 兼容
void f() // 与 TU1 的 f 兼容
{
   return;
}
// 翻译单元 3
struct s {int i;}; // 与 TU1 的 s 兼容，但不与 TU2 的 s 兼容
extern struct s x; // 与 TU1 的 x 兼容
// 翻译单元 4
struct s {float f;}; // 与 TU2 的 s 兼容，但不与 TU1 的 s 兼容
extern struct s y; // 与 TU2 的 y 兼容
 
// 行为良好定义：只有对象或函数的多个声明，而非类型自身必须拥有兼容类型
```



## 合成类型

​		合成类型能从两个兼容的类型进行构造，它是满足两个类型兼容，并满足：

- 如果两个类型均为数组类型，则

  - 一个类型是常量大小数组，则合成类型为该大小的数组
  - 一个类型是VLA，对求值其大小的表达式尚未求值，则行为未定义。
  - 一个类型是已指定大小的VLA，则合成类型为该大小的VLA
  - 一个类型为未指定大小的VLA，则合成类型为未指定大小的VLA
  - 两个数组类型都大小位置，合成类型为未知大小的数组

  合成类型的元素类型是两个数组元素类型的合成类型

- 如果一个类型是有参数列表的函数类型，则合成类型为有该参数列表的函数原型

- 如果两个类型均为有参数列表的函数类型，则合成类型的参数列表中的每个参数类型，是对应参数的合成类型。

> 这些规则递归的应用在两个类型的派生来源类型。

```c
// 给定一下二个文件作用域声明：
int f(int (*)(), double (*)[3]);
int f(int (*)(char *), double (*)[]);
// 生成的函数合成类型为：
int f(int (*)(char *), double (*)[3]);
```

​		如果已经声明了内部或外部链接的标识符，在可见该标识符的作用域中，再次声明该标识符，就成为合成类型。

## 不完整类型

​		缺乏足以确定其对象大小的信息的对象类型。不完整类型可以在翻译单元的某些点完整。

- void， 此类型不能完整

- 未知大小的数组，之后指定大小的声明能使其完整。

  ```c
  extern char a[]; // a 的类型不完整（这通常出现于头文件）
  char a[10];      // a 的类型现在完整（这通常出现于源文件）
  ```

- 内容位置的结构体或联合体类型，在同一作用域的后面，定义同一结构体或联合体的内容的声明能使之完整。

  ```c
  struct node {
    struct node *next; // struct node 在此点不完整
  }; // struct node 在此点完整
  ```

  

## 类型名

​		类型可能需要在除声明语句之外的语境中指定类型。在这些情况下使用类型名，从语法上来说，它与类型说明符和类型限定符，后随声明符的列表完全相同，用于声明该类型的单个对象和函数。除了省略掉标识符。

```c
int n; // 声明 int 
sizeof(int); // 使用类型名
 
int *a[3]; // 声明 3 个指向 int 指针的数组
sizeof(int *[3]); // 使用类型名
 
int (*p)[3]; // 声明指向 3 个 int 的数组的指针
sizeof(int (*)[3]); // 使用类型名
 
int (*a)[*] // （在函数参数中）声明指向 VLA 的指针
sizeof(int (*)[*]) // （在函数参数中）使用类型名
 
int *f(void); // 声明函数
sizeof(int *(void)); // 使用类型名
 
int (*p)(void); // 声明指向函数指针
sizeof(int (*)(void)); // 使用类型名
 
int (*const a[])(unsigned int, ...) = {0}; // 声明指向函数指针的数组
sizeof(int (*const [])(unsigned int, ...)); // 使用类型名
```

​		除了围绕标识符的冗余括号在类型名中有意义外，还表示 不指定参数的函数。

```c
int (n); // 声明 int 类型的 n
sizeof(int ()); // 使用类型“返回 int 的函数”
```

​		类型名用于下列场合：

- 转型运算符

- sizeof

- 复合字面量

- 泛型选择

- ``_Alignof``

- `_Atomic`，用于类型指定符时

  ​	类型名可引入新类型

```c
void* p = (void*)(struct X {int i;} *)0;
// 用于转型表达式的 "struct X {int i;}*"
// 引入新类型 "struct X"
struct X x = {1}; // struct X 现在在作用域中
```











