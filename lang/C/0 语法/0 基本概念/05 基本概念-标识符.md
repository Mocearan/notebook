# 标识符

C语言/语言/基本概念/标识符

---

​		标识符是一个字符序列，由数字字符、下划线、大小写拉丁字母和大多数Unicode字符进行任意长度的组合。长度不限，大小写敏感。

> 是否在标识符中允许未处理（未转义）的 Unicode 字符是实现定义的： c99起
>
> ```c
> char *\U0001f431 = "cat"; // 受支持
> char *🐱 = "cat"; // 实现定义（ Clang 可用，但版本 10 前的 GCC 不可）
> ```

标识符能指代下列类型的实体：

- 对象
- 函数
- 标签（ struct、union 或枚举）
- 结构体或联合体成员
- 枚举常量
- typedef名
- 标号名
- 宏名
- 宏形参名

> ​		宏名或宏形参名以外的每个标识符都拥有作用域属于命名空间，并且可以拥有链接。相同的标识符可以在程序的不同作用域指代不同实体，或若实体在不同的命名空间中，则可在相同点指代不同实体。

## 保留标识符

下列标识符被*保留*

>  不可在程序中声明（这么做会引起未定义行为）

- 关键词标识符不能用于其他目的

  具体而言，不允许 #define 或 #undef 等同于关键词的标识符。

- 单个下划线开始的外部标识符

- 单下划线后随一个大写字母或另一下划线开始的标识符

  这些保留标识符允许库使用大量幕后的非外部宏及函数

- 标准库所定义的所有外部标识符（在有宿主环境中）

  这表示不允许用户提供的外部名称匹配任何库名称，即使是声明等同于库函数的函数也不允许。

- 声明为标准库为未来使用保留的标识符，即

  - 函数名

    > - `<complex.h>`中，`cerf` 、 `cerfc` 、 `cexp2` 、 `cexpm1` 、 `clog10` 、 `clog1p` 、 `clog2` 、 `clgamma` 、 `ctgamma` 及其 -f 和 -l 后缀变体
    > - `<ctype.h>`和`<wctype.h>`中，以 `is` 或 `to` 后随一个小写字母开始者
    > - `<stdlib.h>`中，以 `str` 后随一个小写字母开始者
    > - `<string.h>`中，以 `str` 、 `mem` 或 `wcs` 后随一个小写字母开始者
    > - `<wchar.h>`中，以 `wcs` 后随一个小写字母开始者
    > - `<stdatomic.h>`中，以 `atomic_` 后随一个小写字母开始者
    > - `<threads.h>`中，以 `cnd_` 、 `mtx_` 、 `thrd_` 或 `tss_` 后随一个小写字母开始者

  - typedef名

    > - `<stdint.h>`中，以 `int` 或 `uint` 开始并以 `_t` 结束者
    > - `<stdatomic.h>`中，以 `atomic_` 或 `memory_` 后随一个小写字母开始者
    > - `<threads.h>`中，以 `cnd_` 、 `mtx_` 、 `thrd_` 或 `tss_` 后随一个小写字母开始者

  - 宏名

    > - `<errno.h>` 中，以 `E` 后随一个数字或大写字母开始者
    > - `<fenv.h>`中，以 `FE_` 后随一个大写字母开始者
    > - `<stdint.h>`中，以 `INT` 或 `UINT` 开始并以 `_MAX` 、 `_MIN` 或 `_C` 结束者
    > - `<stdint.h>`中，以 `PRI` 或 `SCN` 后随小写字母或字母 `X` 开始者
    > - `<locale.h>`中，以 `LC_` 后随一个大写字母开始者
    > - `<signal.h>`中，以 `SIG` 或 `SIG_` 后随一个大写字母开始者
    > - `<time.h>`中，以 `TIME_` 后随一个大写字母开始者
    > - `<stdatomic.h>`中，以 `ATOMIC_` 后随一个大写字母开始者

  - 枚举常量

    > - `<stdatomic.h>`中，以`memory_order_`后随一个小写字母开始者
    > - `<threads.h>`中，以`cnd`_、`mtx`_、`thrd_`或`tss_`后随一个小写字母开始者

所有其他标识符均可用，无需担心从一个编译器和库移动程序到另一个时有不期待的冲突。

注意： C++ 中，在任何位置有双下划线的标识符都受保留； C 中，只有以双下划线开始的标识符受保留。



## 翻译限制

​		尽管标识符长度上无特定的限制，一些早期编译器还是在标识符中的有效起始字符数上有限制，而链接器在带外部链接的名称上加上了更严格的限制。 C 要求任何服从标准的实现支持下列极限：

![image-20210721000053788](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210721000053788.png)



## 查找与命名空间

### 命名空间

​		在标识符的查找点，贵根据使用方式确定标识符所属的命名空间。

- goto语句运算数的标识符（goto 后跟的标号量），会在标号命名空间中查找。
- 后随关键字 struct、union、enum的标识符，会在标签命名空间中查找。
- 后随成员访问(.)或通过指针的成员访问运算符的标识符（->），会在类型成员命名空间中查找，该类型的成员访问运算符由左运算数确定（结构体或结构体指针）。
- 直接出现于属性说明符(`[[...]]`)中的标识符，会在全局属性命名空间中查找（C23）
- 后随属性前缀之后的(`::`)中的标识符，会在属性前缀所引入的命名空间中查找（C23）
- 所有其他标识符，会在通常命名空间中查找

### 标识符查找

​		在 C 程序中遇到标识符时，会查找定位该标识符，验证当前在作用域内的声明，将其引入到当前翻译单元内。

​		若同一标识符的多个声明属于称作命名空间的相异类别，则 C 允许它们同时在作用域内：

1) 标号命名空间：所有声明为标号的标识符。

2) 标签名：所有声明为 struct 、 union及枚举类型名称的标识符。注意所有这三种标签共享同一命名空间。

3) 成员名：所有声明为至少为一个 struct或 union成员的标识符。每个结构体和联合体引入它自己的这种命名空间。

4) 全局属性命名空间：标准定义的属性记号或实现定义的属性前缀。（C23）

5) 非标准属性名：后随属性前缀的属性名。每个属性前缀拥有分离的、它所引入的实现定义属性所在的命名空间。（C23）

6) 所有其他标识符，称之为*通常标识符*以别于 (1-5) （函数名、对象名、 typedef 名、枚举常量）。



```c
void foo (void) { return; } // 通常命名空间，文件作用域
struct foo {      // 标签命名空间，文件作用域
    int foo;      // 此 struct foo 的成员命名空间，文件作用域
    enum bar {    // 标签命名空间，文件作用域
        RED       // 通常命名空间，文件作用域
    } bar;        // 此 struct foo 的成员命名空间，文件作用域
    struct foo* p; // OK ：使用标签/文件作用域名称 "foo"
};
enum bar x; // OK ：使用标签/文件作用域 "bar"
// int foo; // 错误：通常命名空间已有 foo
//union foo { int a, b; }; // 错误：标签命名空间已有 foo 在作用域中
 
int main(void)
{
    goto foo; // OK 从标号命名空间/函数作用域使用 "foo"
 
    struct foo { // 标签命名空间，块作用域（于文件作用域中隐藏）
       enum bar x; // OK ，从标签命名空间/文件作用域使用 "bar"
    };
    typedef struct foo foo; // OK ：从标签命名空间/块作用域使用 foo
                            // 定义块作用域通常命名空间的 foo （隐藏于文件作用域）
    (foo){.x=RED}; // 使用通常命名空间/块作用域 foo 和通常命名空间/文件作用域 RED
 
foo:; // 标号命名空间，函数作用域
}
```



> ​		宏名不是任何命名空间的一部分，因为语义分析前，预处理器会替换它们。
>
> ​		一个常见举措是将 struct/union/enum 名称注入通常命名空间，以 typedef声明：
>
> ```c
> struct A { };       // 于标签命名空间中引入名称A
> typedef struct A A; // 首先，对"struct"后A的查找找到标签命名空间的一个
>                     // 然后将名称A引入通常命名空间
> struct A* p;        // OK，此A于标签命名空间中查找
> A* q;               // OK，此A于通常命名空间中查找
> ```
>
> > 众所周知的一个同一标识符横跨两个命名空间使用的示例，是 POSIX 头文件 `sys/stat.h` 中的标识符 stat 。它用作通常标识符时[指名一个函数](http://pubs.opengroup.org/onlinepubs/9699919799/)，而在用作标签时[指代一个结构体](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html)。
>
> ​		不同于 C++ 中，枚举常量不是结构体成员，而且其命名空间是通常标识符的命名空间，故而 C 中无结构体作用域，其作用域是出现结构体声明的作用域：
>
> ```c
> struct tagged_union 
> {
>    enum {INT, FLOAT, STRING} type;
>    int integer;
>    float floating_point;
>    char *string;
> } tu;
>  
> tu.type = INT; // C 中 OK ， C++ 中错误
> ```
>
> ​		若不支持标准属性、属性前缀或非标准属性名，则忽略非法的属性自身而不导致错误。  (C23 起)

```c
void foo (void) { return; } // 通常命名空间，文件作用域
struct foo {      // 标签命名空间，文件作用域
    int foo;      // 此 struct foo 的成员命名空间，文件作用域
    enum bar {    // 标签命名空间，文件作用域
        RED       // 通常命名空间，文件作用域
    } bar;        // 此 struct foo 的成员命名空间，文件作用域
    struct foo* p; // OK ：使用标签/文件作用域名称 "foo"
};
enum bar x; // OK ：使用标签/文件作用域 "bar"
// int foo; // 错误：通常命名空间已有 foo
//union foo { int a, b; }; // 错误：标签命名空间已有 foo 在作用域中
 
int main(void)
{
    goto foo; // OK 从标号命名空间/函数作用域使用 "foo"
 
    struct foo { // 标签命名空间，块作用域（于文件作用域中隐藏）
       enum bar x; // OK ，从标签命名空间/文件作用域使用 "bar"
    };
    typedef struct foo foo; // OK ：从标签命名空间/块作用域使用 foo
                            // 定义块作用域通常命名空间的 foo （隐藏于文件作用域）
    (foo){.x=RED}; // 使用通常命名空间/块作用域 foo 和通常命名空间/文件作用域 RED
 
foo:; // 标号命名空间，函数作用域
}
```



# 作用域

C语言/语法/基本概念/作用域

---

​		C程序中标识符可见，并有效映射实体的区域，称为作用域。作用域可能不连续。

​		在作用域内，标识符如果只在不同命名空间中，才可以指代多于一个实体。

C拥有四中作用域：

- 块作用域（局部作用域）

  > ​		因为C是面向过程的语言，程序的组织是通过函数的组合在一起的。所以在一个编译单元内，相对于文件的全局作用域来说，函数的作用域即为局部作用域。
  >
  > ​		包括复合语句通过大括号引起的作用域。

- 文件作用域（全局作用域）

  > ​		全局是指，每个.c文件在编译时作为独立的编译单元，不同的编译单元在编译完成后通过链接器链接在一起形成可执行程序。而在编译过程中，每个编译单元除非通过extern来引入外部符号，所有的标识符符号都需要在编译单元内声明定义并引用。
  >
  > ​		所以文件作用域就是全局作用域。

- 函数作用域

  > ​		特指对于函数内部声明的标号来说，无论在函数内部更深的块作用域 中，名称也都从属于整个函数作用域中。

- 函数原型作用域

  > ​		在函数原型声明语句中，参数列表中的名称在函数声明结束后就消亡。



## 声明点

​		声明的标识符生效的开始点。

### 结构体、联合体、枚举标签

​		声明该标识符的类型指定符中的标识符出现后，立即开始作用域，

```c
struct Node {
    struct Node* next; // Node标识符声明后，立即开始其有效的作用域。 
};
```

### 枚举常量

​		在枚举项列表中，标识符出现后立即开始。

```c
enum { x = 12 };
{
    enum { x = x + 1, // 新 x 在逗号前不在作用域中，初始化 x 为 13
           y = x + 1  // 新枚举项 x 现在在作用域中，初始化 y 为 14
         };
}
```

### 其他标识符

​		正好再起声明器结束后，初始化器之前开始（如果存在初始化器）

```c
int x = 2; // 第一个 'x' 的作用域开始
{
    int x[x]; // 新声明的 x 的作用域在声明器 （ x[x] ）后开始。
              // 在声明器内，外层 'x' 仍在作用域中。
              // 这声明 2 个 int 的 VLA 数组。
}
 
unsigned char y = 32; // 外层 'y' 的作用域开始
{
    unsigned char y = y;
            // 内层 'y' 的作用域在初始化器（ = y ）前开始
            // 这不会以值 32 初始化内层 'y' ，
            // 这以其自身的不确定值初始化内层 'y'
}
 
unsigned long factorial(unsigned long n)
// 声明器结束， 'factorial' 从此点开始在作用域中
{
   return n < 2 ? 1 : n * factorial(n - 1); // 递归调用
}
```

> 作为特殊情况，非标识符声明的**类型名**的作用域，被认为正好假如在类型名内未省略标识符，则标识符会出现的位置之后开始。



## 块作用域

​		块作用域中的标识符，从声明点开始，到所在的块或语句的结尾结束。

- 复合语句
  - 函数体
  - if
  - switch
  - for
  - while
  - do-while
- 函数定义的参数列表

任何出现在以上的表达式、声明或语句中的标识符，拥有块作用域。

```c
void f(int n)  // 函数参数 'n' 的作用域开始
{         // 函数体开始
   ++n;   // 'n' 在作用域中并指代函数参数
// int n = 2; // 错误：不能在同一作用域重声明标识符
   for(int n = 0; n<10; ++n) { // 循环局域的 'n' 的作用域开始
       printf("%d\n", n); // 打印 0 1 2 3 4 5 6 7 8 9
   } // 循环局域的 'n' 的作用域结束
     // 函数参数 'n' 回到作用域
   printf("%d\n", n); // 打印参数的值
} // 函数参数 'n' 的作用域结束
int a = n; // 错误：名称 'n' 不在作用域中



/// C99 前，选择和迭代语句不建立其自身的块作用域（尽管若在语句中使用复合语句，则它拥有其通常的块作用域）：

enum {a, b};
int different(void)
{
    if (sizeof(enum {b, a}) != sizeof(int))
        return a; // a == 1
    return b; // C89 中 b == 0 ， C99 中 b == 1
}
```

> **NOTE：**
>
> ​		块作用域中声明的对象默认**无链接**并拥有**自动存储期**。
>
> ​		注意非 VLA 局部对象的存储期在进入块时开始，但在见到声明前，该标识符不在作用域中且不能访问。



## 文件作用域

​		在任何块或参数列表外声明的的所有标识符，都具有文件作用有。从声明点开始，到翻译单元尾结束。

```c
int i; // i 的作用域开始
static int g(int a) { return a; } // g 的作用域开始（注意 "a" 拥有块作用域）
int main(void)
{
    i = g(2); // i 和 g 在作用域中
}
```

> **NOTE：**
>
> ​		文件作用域的标识符默认具有**外部连接**和**静态存储期**。



## 函数作用域

​		函数内部声明的标号，无论在函数中的任何嵌套作用域中，都在函数体内部作用域内。

> **NOTE：**
>
> ​		注意：任何语句前的冒号字符前的标识符，若不用于其他用途，则隐式声明一个标号。

```c
void f()
{
   {   
       goto label; // label 在作用域中，尽管之后才声明
label:;
   }
   goto label; // 标号忽略块作用域
}
 
void g()
{
    goto label; // 错误： g() 中 label 不在作用域中
}
```



## 函数原型作用域

​		函数声明的参数列表中引入的 名称，在函数声明语句结束时结束。

```c
int f(int n,
      int a[n]); // n 在作用域中并指代第一参数
```

> **Note:**
>
> ​		若声明中有多个或嵌套声明器，则作用域在最近的外围函数声明器的结尾结束：
>
> ```c
> void f ( // 函数名 'f' 在文件作用域
> long double f,            // 标识符 'f' 现在在函数原型作用域中，屏蔽文件作用域的 'f'
> char (**a)[10 * sizeof f] // 'f' 指代第一参数，它在函数原型作用域中
> );
> 
> enum{ n = 3 };
> int (*(*g)(int n))[n]; // 函数参数 'n' 的作用域在其函数声明器的结尾结束
>                     // 数组声明器中，n是全局作用域下的 n
> // （这声明指向返回 3 个 int 的数组的指针的函数的指针）
> ```
>
> 



## 嵌套作用域

​		允许通过引起新的内层作用域的方式，用相同的标识符来表征不同的实体。

​		内层作用域中的声明隐藏外层作用域中的 声明。

```c
// 此处的命名空间为通常标识符。
 
int a;   // 名称 a 的文件作用域始于此
 
void f(void)
{
    int a = 1; // 名称 a 的块作用域始于此；隐藏文件作用域的 a
    {
      int a = 2;         // 内层 a 的作用域始于此，隐藏外层 a 
      printf("%d\n", a); // 内层 a 在作用域中，打印 2
    }                    // 内层 a 的块作用域终于此
    printf("%d\n", a);   // 外层 a 在作用域中，打印 1
}                        // 外层 a 的作用域终于此
 
void g(int a);   // 名称 a 拥有函数原型作用域；隐藏文件作用域的 a
```



## 注意

​		C89 前，拥有外部链接的标识符在块中引入时，拥有文件作用域。

> ​	因此不要求 C89 编译器诊断已离开作用域的 extern 标识符的使用（这种使用是未定义行为）。

​		C 中，循环体内的局部对象，能隐藏声明于 for循环的初始化子句中的对象（其作用域为嵌套的），但 C++ 中不能如此。

​		不同于 C++ ， C 无结构体作用域。声明于 struct/union/enum 声明内的名称和结构体声明拥有相同作用域（只是数据成员在其成员命名空间中而已）：

```c
struct foo {
    struct baz {};
    enum color {RED, BLUE};
};
struct baz b; // baz 在作用域中
enum color x = RED; // color 和 RED 在作用域中
```



# 生存期、存储期与链接

C语言/语法/基本概念/生存期、存储期与链接

---

## 生存期		



​		C 中每个**对象**存在、拥有**常地址**、保有其最近一次存储值（除非其值不确定），对于 VLA 还有保有其大小 (C99 起)的程序执行部分，被称作该对象的*生存期*。

> **对象：**
>
> ​		C中，一个对象时执行环境中数据存储的一个区域，其内容可以表示值（值是对象的内容转义为特定类型时的含义）。
>
> **常地址：**
>
> ​		固有表示一块存储区域的地址，不同于指针变量所表示的存储可变地址的含义。

​		在生存期外访问对象是未定义行为。

### 块生存期

​		对于声明有

- 自动

- 静态

- 线程

  存储期的对象，生存期等于其存储期

​		（注意非 VLA 和 VLA 自动存储期的区别）。

```c
int* foo(void) {
    int a = 17; // a拥有自动存储期
    return &a;
}  // a的生存期结束
```



### 动态生存期

​		对于拥有分配存储期的对象，其生存期始于分配函数的返回（包含从 `realloc`返回），终于 `realloc`或解分配函数的调用。

> **注意:**
>
> ​		因为分配的对象没有声明类型，首次访问该对象所用的左值表达式类型会成为其**有效类型**
>
> **有效类型：**
>
> ​		它决定何种左值访问合法，何种违反严格别用使用规则。
>
> ps：C语言/语法/基本概念/对象与对齐/有效类型



```c
int* foo(void) {
    int a = 17; // a拥有自动存储期
    return &a;
}  // a的生存期结束
int main(void) {
    int* p = foo(); // p 指向生存期结束后的对象（“悬垂指针”）
    int n = *p; // 未定义行为
}
```

​		指向生存期结束的对象（或该对象后一位置）的指针拥有不确定值。

### 临时生存期

​		非左值表达式所指代的，拥有数组成员的，结构体和联合体对象，拥有临时生存期。

> 数组成员可以是直接成员，也可以是嵌套的结构体或联合体的成员

​		临时生存期开始于，对指代该对象的表达式的求值。

​		结束于：

- C11前，下一个求值序列点
- C11起，包含它的完整表达式或完整声明器结束

```c
struct T { double a[4]; };
struct T f(void) { return (struct T){3.15}; }
double g1(double* x) { return *x; }
void g2(double* x) { *x = 1.0; }
int main(void)
{
    double d = g1(f().a); // C99 ： UB 访问生存期结束于 g1 开序列点的 a[0]
                          // C11 ： OK ， d 为 3.15
    g2(f().a); // C99 ： UB 修改生存期结束于序列点的 a[0]
               // C11 ： UB 试图修改临时对象
}
```



## 存储期

​		每个对象都有称为存储期的属性，它限制对象的生存期。C中有四种存储期

- 自动存储期
- 静态存储期
- 动态存储期（分配存储期）
- 线程存储期

### 自动（块）存储期

​		如果对象声明在某个块中，则在进入该块伊始就分配对象的内存，以任意方式退出该块时解分配存储。

> 退出块的方式：
>
> - goto
> - return
> - 抵达块结尾

​		一个例外是VLA，在执行声明时才分配其存储，而不是在进入块时分配内存。在声明离开作用域是解分配存储，而不是在退出块时解分配存储。

​		如果递归的进入块，则每个递归层进行新的分配。

​		所有函数参数和非static的块作用域对象，用于块作用域的复合字面量，拥有此存储期。

> **复合字面量：**
>
> ​		`( type){ initializer-list }`
>
> ​		就地构造一个指定类型的无名对象，在只需要一次数组、结构体或联合体变量时使用。
>
> C语言/语法/表达式/常量及字面量/复合字面量

### 静态存储期

​		存储期是整个程序的执行过程。

​		在main函数调用之前，静态存储期的对象的值会被初始化一次。

​		所有声明为static对象和所有带内部或外部链接（但不声明为`_Thread_local`）的对象都拥有静态存储期。

### 动态存储期

​		用动态内存分配函数分配和解分配存储。

### 线程存储期

​		存储期是创建对象的线程的整个执行过程。

​		在启动线程时，线程存储期的对象的值会被初始化。

​		线程存储期的对象，在不同的线程中是独立拷贝的。访问某个线程存储期对象的表达式，在初始化该线程存储期对象之外的其他线程执行，则行为是实现定义的。

​		所有声明为`_Thread_local`的对象拥有此存储期。



## 链接

​		链接指的是在标识符声明的作用域外的其他作用域中指代该标识符（具名对象或函数）的能力。

> 具名对象或函数等才在编译阶段有意义。宏会在预处理阶段被替换。

​		如果多个作用域中声明有同一标识符的对象或函数，但不能从所有这些作用域指代它们，就会分别创建多个对象的实例。

### 无链接

​		只能在标识符所在的作用域进行指代。

​		所有函数参数和所有extern之外的块作用域对象（包含声明为static的）拥有此链接。

### 内部链接

​		能在当前翻译单元中所有的作用域指代该标识符。

​		所有static的文件作用域标识符（函数和对象）都拥有内部链接。

### 外部链接

​		能在整个程序的任何其他翻译单元指代该标识符。

​		所有任意作用域下的不是static的函数，所有文件作用域的不是static的对象，所有任意作用域下extern的对象（除非之前声明为static，则后续再声明为extern则不符合外部链接）拥有外部链接。

> ​		内部外部指的是翻译单元的内部和外部。
>
> ​		如果同意标识符在同一翻译单元中一同带内部和外部链接出现，则行为未定义。这在使用试探性定义时有可能。

















































