# TOML

放弃了括号或缩进的底层原理，而是采取了显式键名链的方式。

---

## 导言 - 配置文件

​		配置文件是一种非常基础的文件格式，但远没有数据文件格式（如 SQLite）、文档文件格式（如 Markdown）、编程语言（如 JavaScript）、甚至二进制文件格式（如 PNG）需求那么复杂。

　　只要严谨但不严苛、支持必要的数据类型和嵌套，又易于人类手工直接阅读和编辑就可以了。

　　但就是这样一种广泛需要而又简单的应用场景，却反而长期以来一直没有一种足够好的文件格式。

### INI

​		INI（`.ini`）文件是一种非常原始的基础形式，但各家有各家的用法，而且它最多只能解决一层嵌套。只适合非常非常简单的配置文件，一旦需要两层嵌套，或需要数组，就力不从心了。

```ini
; 最简单的结构

val_1 = val_1;
val_2 = val_2; 这些等号后面的值是字符串（句末分号不是必须的；它后面的都是注释）

; 稍微复杂一点的单层嵌套结构

[obj_1]

x = obj_1.x
y = obj_2.y

[obj_2]

x = obj_2.x
y = obj_2.y
```



### properties

​		其中# 开始的一行为注释信息；在等号“= ”左边的我们称之为key ；等号“= ”右边的我们称之为value 。（其实就是我们常说的键- 值对）key 应该是我们程序中的变量。而value 是我们根据实际情况配置的。

```properties
#以下为服务器、数据库信息
dbPort = localhost
databaseName = mydb
dbUserName = root
dbPassword = root
#以下为数据库表信息
dbTable = mytable
#以下为服务器信息
ip = 192.168.0.9
```



### json 

​		JSON（`.json`）是一种非常好的数据存放和传输的格式，但阅读和编辑它实在不方便。即便 JSON5（`.json5` - ECMAScript 5.1 JSON）这种扩展格式允许了你像写 JavaScript 对象那样书写裸键名、允许尾逗号，并且可以有注释，写多行字符串依然麻烦。即便它将来加上了多行字符串语法，依然不行，因为它虽然是基于括号嵌套语法的层级关系，在不缩进的情况下，却根本没法阅读。

```json
{
    "val_1": "val_1",
    "val_2": "val_2",
    "obj_1":{
        "x": "obj_1.x",
        "y": "obj_1.y"
    },
    "obj_2":{
        "x": "obj_2.x",
        "y": "obj_2.y"
    },
    "arr":[
        { "x":"arr[0].x", "y":"arr[0].y" },
        { "x":"arr[1].x", "y":"arr[1].y" }
    ]
}
```



### yaml

​		YAML（`.yaml` 或 `.yml`）干脆将 JSON 中有了不够、没有不行的括号结构去掉了，只保留缩进。但编辑和阅读它总令人非常慌张，生怕数错了层次（实际上，对于阅读，语法关键字并不是越小越好）。而且在不支持统一缩进、反缩进、自动在换行时缩进的编辑环境下，这非常麻烦——这本来对编程语言来说不是什么事，但配置文件最常用的使用场景却恰恰是这样。

　　另外，YAML 的语法实在太多了，而且不是循序渐进的，即便你不需要复杂的功能，为了保证自己的简单功能不出错，也要对那些复杂的语法有所了解并加以避免（比如究竟什么键名可以不加引号，什么字符串可以不加引号；你总不能为了避免歧义全都加上引号，那和 JSON 也就差球不多了）。更糟的是，纵使如此复杂，想要精确地配置一段多行字符串，却显得力不从心——除非倒退回单行 JSON 字符串表示法，否则其中的换行是否被保留、缩进是否被忽略、是否自动插入了空格、转义的解释等问题，实在令人心力交瘁。再加上各种实现对各种歧义的解释异常混乱……要说规范一点儿责任也没有，似乎是不可能的。

```yaml
val_1: abcd # string
val_2: true # boolean
val_3: TRUE # ?
val_4: True # ?
val_5: TrUE # ?
val_6: yes  # ?
val_7: on   # ?
val_8: y    # ?

obj_1:
  x: obj_1.x
  y: obj_1.y
obj_2:
  x: obj_2.x
  y: obj_2.y

arr:
  - x: arr[0].x
    y: arr[0].y
  - x: arr[1].x
    y: arr[1].y

str_1: "a
b"          # ?
str_2: "a
        b"  # ?
str_3: "a
         b" # ?
```



### toml

终于，TOML（`.toml`）横空出世。它彻底放弃了括号或缩进的底层原理，而是采取了显式键名链的方式。

　　为了方便（同时看起来更清楚——这种读和写的契合非常关键！），你可以指定小节名。妙的是，小节名也是可以链式声明的。

　　另外，某些数据可能使用内联数组或表更合适以避免臃肿，这也是支持的。

```toml
val_1 = "val_1"
val_2 = "val_2"

obj_1.x = "obj_1.x"
obj_1.y = "obj_1.y"

[obj_2]

x = "obj_2.x"
y = "obj_2.y"

[[arr]]

x = "arr[0].x"
y = "arr[0].y"

[[arr]]

x = "arr[1].x"
y = "arr[1].y"

[str.x]

y.z = "str.x.y.z"

[str.a]

b.c = """
    str
   .a
  .b
 .c
""" # 等价于 "    str\n   .a\n  .b\n .c\n"

[inline]
points = [
    { x=1, y=1, z=0 },
    { x=2, y=4, z=0 },
    { x=3, y=9, z=0 },
]
```



## 场景

​		书写**配置文件**。因为它为人类的可直接读写性而进行了深度设计，并作出了必要的取舍。
　　它比 `.ini` 文件更强大，比 YAML 格式更简单。
　　但如果您需要程序间的序列化/反序列化数据交换格式，那么 JSON 是目前更通行的选择。

　　另外，TOML 是**通用型**数据的配置文件格式。
　　在一些特定的功能场景下，肯定会有更有针对性和表现力的声明格式，比如用于 API 的 `.d.ts`（TypeScript），或用于前端模板的 `.md`、`.jade`，乃至表现语法规范本身的 `.abnf` 等。



## 语法

### 原子值

　	对于不是 TOML 特色的简单类型值，在此通称为原子值，并用正则表达式来简练地描述其语法（表达式中的换行和缩进，只是为了看上去更清楚）。

#### 布尔值

```regex
^(true|false)$
```

#### 两类数字

>   ※ TOML 0.3 开始允许 `+` 号

>   ※ TOML 0.4 开始可以在实值部分内加入下划线，以增强可读性

1.  **整数**

    -   十进制（不允许前导零，因为编程界界存在八进制歧义）

        ```regex
        ^
            [+-]?
            (0|[1-9][0-9]*(_[0-9]+)*)
        $
        ```

    -   十六进制（TOML 0.5 新增；不能为负数 ①）

        ```regex
        ^
            0x
            [0-9A-Fa-f]+(_[0-9A-Fa-f]+)*
        $
        ```

    -   八进制（TOML 0.5 新增；不能为负数 ①）

        ```regex
        ^
            0o
            [0-7]+(_[0-7]+)*
        $
        ```

    -   二进制（TOML 0.5 新增；不能为负数 ①）

        ```regex
        ^
            0b
            [01]+(_[01]+)*
        $
        ```

    >   ① TOML 1.0 中正式澄清，不能为负数的意思是这些非十进制表示法是无符号的，因此 `+` 也是不可以使用的。

2.  **浮点数**

    -   小数

        ```regex
        ^
            [+-]?
            (0|[1-9][0-9]*(_[0-9]+)*)
            
            \.
            [0-9]+(_[0-9]+)*
        $
        ```

    -   科学记数法（TOML 0.3 新增；TOML 1.0 开始支持指数部分的前导零）

        ```regex
        ^
            [+-]?
            (0|[1-9][0-9]*(_[0-9]+)*)
            
            (
                \.
                [0-9]+(_[0-9]+)*
            )?
            
            [eE]
            [+-]?
            [0-9]+(_[0-9]+)*
        $
        ```

        

    -   特殊浮点值（TOML 0.5 新增）

        ```regex
        ^
            [+-]?
            (inf|nan)
        $
        ```



#### 字符串

​		※ TOML 0.4 开始不再允许对 `/` 使用 `\/` 转义写法

>   ※ TOML 0.5 开始将字符串禁止直接包含的控制字符的范围，扩大至包含 U+007F

>   ※ TOML 1.0 开始允许基础字符串、多行基础字符串中包括 Tab

>   ※ TOML 1.0 开始，规定两种多行字符串均可以两个以内的引号结尾，而在此之前，这会造成字符串提前终止而构成语法错误

-   基础字符串

    >   ※ TOML 0.3 开始支持用 `\UXXXXXXXX` 来表示 UCS-4，同时开始限定 `\uXXXX` 和 `\UXXXXXXXX` 的值必须是完整、有效的 Unicode 码点（`0000`—`D7FF`，`E000`—`0010FFFF`）

    ```regex
    ^
        "
        (
            [^\\"\x00-\x1F\x7F]
            |
            \t
            |
            \\(
                [\\"btnfr]
                |
                u[0-9A-Fa-f]{4}
                |
                U[0-9A-Fa-f]{8}
            )
        )*
        "
    $
    ```

-   多行基础字符串（TOML 0.3 新增）

    >   ※ 开始标记后如果紧跟换行，那么这个换行会被剔除

    >   ※ 用 `\` 来转义换行时，这个 `\` 连同后面紧跟的所有换行、空格和 Tab 都会被剔除（TOML 0.5 开始，允许 `\` 和换行之间存在空格；TOML 1.0 将支持扩大至 Tab）

    ```regex
    ^
        """
        (
            [^\\"\x00-\x1F\x7F]
            |
            \t
            |
            \\(
                [\\"btnfr]
                |
                u[0-9A-Fa-f]{4}
                |
                U[0-9A-Fa-f]{8}
            )
            |
            (\\[ \t]*)?\r?\n
            |
            ""?
        )*
        """
    $
    ```

-   字面量字符串（TOML 0.3 新增）

    ```regex
    ^
        '
        (
            [^'\x00-\x1F\x7F]
            |
            \t
        )*
        '
    $
    ```

-   多行字面量字符串（TOML 0.3 新增）

    ```regex
    ^
        '''
        (
            [^'\x00-\x1F\x7F]
            |
            \t
            |
            \r?\n
            |
            ''?
        )*
        '''
    $
    ```



#### 四类时间

​		※ 各部分数值必须在实际上存在，否则依然会报错（例如 13 月，或非闰年的 2 月 29 日）；其中，“时”的范围是 00〜23（而非 01〜24），“分”“秒”的范围是 00〜59（而非 01〜60）

1.  **坐标日期时刻**

    >   ※ TOML 0.3 开始支持小数秒和除 `Z` 以外的时区偏移值

    >   ※ TOML 0.5 开始允许用空格代替 `T` 以增强可读性

    ```
    ^
        (?<年>\d\d\d\d)-(?<月>\d\d)-(?<日>\d\d)
        [T ]
        (?<时>\d\d>):(?<分>\d\d):(?<秒>\d\d)(\.\d+)?
        (
            Z
            |
            [+-](?<时>\d\d>):(?<分>\d\d)
        )
    $
    ```

2.  **各地日期时刻**

    >   ※ TOML 0.5 新增

    ```
    ^
        (?<年>\d\d\d\d)-(?<月>\d\d)-(?<日>\d\d)
        [T ]
        (?<时>\d\d>):(?<分>\d\d):(?<秒>\d\d)(\.\d+)?
    $
    ```

3.  **各地日期**

    >   ※ TOML 0.5 新增

    ```
    ^
        (?<年>\d\d\d\d)-(?<月>\d\d)-(?<日>\d\d)
    $
    ```

4.  **各地时刻**

    >   ※ TOML 0.5 新增

    ```
    ^
        (?<时>\d\d>):(?<分>\d\d):(?<秒>\d\d)(\.\d+)?
    $
    ```



### 哈希表

　首先，根层级本身就是一个哈希表，可以用以 `=` 分隔的键值对，来表示它的内容（每条独占一行）：

```
a="rootTable.a"
b="rootTable.b"
```

------

　　其中键名可以是符合正则表达式 `^[A-Za-z0-9_-]+$` 的“裸键”，也可以用基本字符串表示不符合这一规则的情况：① ②

```
"[.] =\t#"="rootTable['[.] =\t#']"
''="rootTable['']"
```

>   ① TOML 0.4 开始才对键名有此明确的字符限定。在此之前，键名的规则比较模糊，只要求不要有一些语法相关的字符，也没有提及如果需要出现这些字符，该如何表示。TOML 0.5 进一步增加了对空字符串键名的许可。

>   ② TOML 0.5 明确表示，也可以使用 TOML 0.3 加入的字面量字符串，来表示键名。

------

　　可以用以 `[` `]`（在英文中最醒目的符号）包围的小节名来表示子表（独占一行）：

```
a="rootTable.a"
b="rootTable.b"
[sectionA]
a="rootTable.sectionA.a"
b="rootTable.sectionA.b"
[sectionB]
a="rootTable.sectionB.a"
b="rootTable.sectionB.b"
```

------

　　小节名可以是以 `.` 分隔的多个键名：

```
a="rootTable.a"
b="rootTable.b"
[chapterA]
a="rootTable.chapterA.a"
b="rootTable.chapterA.b"
[chapterA.sectionA]
a="rootTable.chapterA.sectionA.a"
b="rootTable.chapterA.sectionA.b"
[chapterA.sectionB]
a="rootTable.chapterA.sectionB.a"
b="rootTable.chapterA.sectionB.b"
```

　　小节名始终是相对于根表的，因此需要书写完整的路径。这样，我们就获得了清楚地表示多层级的能力（而 `.ini` 只能套一层），同时避免了对缩进的依赖（像 YAML 或 JSON ③ 那样）。而不缩进，将大大简化编辑行为，尤其是在严谨地表示多行字符串时。

>   ③ JSON 的语法虽然不要求缩进，但那对于人的阅读是极不友好的。

------

　　对于这样表示很啰嗦的小表，从 TOML 0.4 开始可以用内联哈希表（不允许跨行，除非换行出现在子内联数组或多行字符串值内）表示：

```
a={x=1,y=1,z=1}
b={x=2,y=2,z=2}
c={x=3,y=3,z=3}
```

>   注意：不能使用键值对或小节语法，在外部对内联表进行追加操作；内联表一经定义就不可变动。

------

　　从 TOML 0.5 开始，键值对中的键，也可以像小节名一样用 `.` 分隔了：

```
title="title"
meta.charset="utf-8"
form.feedback={tagName="input",attrs.type="url",attrs.placeholder="https://"}
```

------

　　小节和点分隔键值对虽然赋予了使用者以更灵活、直观的书写能力，但随意穿梭却会造成负面效果。因此，规范规定：

1.  不能多次通过相同的路径打开同一个小节，避免同一部分内容被分散在多处；
2.  无序地把相近部分的内容分散定义的行为虽然不在规范层面禁止，但是是不建议的；
3.  通过点分隔**小节名**隐式创建的表，不能再通过**键值对**进行写入，避免相近部分的内容被分散定义在在各处；
4.  通过点分隔**键值对**隐式创建的表，不能直接作为**小节**打开，但在其中创建尚不存在的子表是可以的；
5.  存在父子关系的多个小节不强迫定义顺序，父表可以后置，用于补充一些相对次要的键。



### 数组

​		

```toml
Array=[]
Array_of_Booleans=[true,false]
Array_of_Integers=[1,0xFEFF,0o755,0b1010]
Array_of_Floats=[1.1,0.0,2e2,2.0e2,inf,nan]
Array_of_Strings=["a","""b""",'c','''d''']
Array_of_OffsetDateTimes=[
0000-01-01T00:00:00+23:59,
1970-01-01T00:00:00Z,
9999-12-31T23:59:59.999-23:59,
]
Array_of_LocalDateTimes=[
0000-01-01T00:00:00,
1970-01-01T00:00:00,
9999-12-31T23:59:59.999,
]
Array_of_LocalDates=[
0000-01-01,
1970-01-01,
9999-12-31,
]
Array_of_LocalTimes=[
00:00:00,
23:59:59.999,
]
Array_of_Arrays=[
[],
[true],[1],[1.1],["a"],
[1970-01-01T00:00:00Z],
]
```

　　其中换行和最后一个条目后的逗号都是可选的。

------

　　虽然 TOML 0.4 加入内联哈希表语法，所以你可以这样写哈希表的数组：

```
Array_of_Tables=[{x=1},{y=2}]
```

　　但这很可能意味着“一朝为数组，子孙全内联”的噩梦的开始。所以早在 TOML 0.2，就加入了块级表数组的语法，甚至还支持多层嵌套 ④：

```
[[chapters]]
a="rootTable.chapters[0].a"
b="rootTable.chapters[0].b"
[[chapters]]
a="rootTable.chapters[1].a"
b="rootTable.chapters[1].b"
[[chapters.sections]]
a="rootTable.chapters[1].sections[0].a"
b="rootTable.chapters[1].sections[0].b"
```

>   ④ 目前数组尚不能在块级层面，直接嵌套子数组。

------

>   注意：不能使用块级表数组语法，在外部对内联数组进行追加操作；内联数组一经定义就不可变动。

### 注释及空白

#### 注释

　　`#` 表示该行后续的内容为注释（显然不包括字符串里的）①：

```
["#这不是注释"."#这亦非注释"]#这是注释

#这是注释

"#这不是注释" = """#这不是注释
#这不是注释
"""#这是注释

"#这亦非注释" = [#这都是注释
#这都是注释
#这都是注释
]#这都是注释
```



>   ① TOML 1.0 明确指出了，即便是在注释中，也不允许出现除 Tab 以外的 Unicode 控制字符。由于其它位置从未允许过，所以至此终于可以简单地同一陈述：整个 TOML 文件中都不能出现除 Tab 和换行以外的任何控制字符。

#### 空白

　　TOML 允许在语法标记外使用空格或 Tab（以及在允许换行的地方敲更多的换行 ②），来使内容更加美观可读，但它不会改变文件解析的结果。

>   ② TOML 0.4 开始明确定义只有 LF（Linux、新 Mac OS X 等系统里的换行符）或 CR+LF（Windows 等系统里的换行符）才是换行。这意味着，单独出现的 CR（老 Mac OS 9 系统里的换行符）以及 Unicode 额外定义的 U+2028 行分隔符、U+2029 段分隔符，在 TOML 里算不算换行的问题，不再模棱两可。

```
# 不用的情况：
[a]#
x=1
y=2
[[a.b]]
a=+1.0e1
bbb_bbb='''
        bbb
     bbb
'''
[[a.b]]
c={x=1,y=2}
d=[1,2,3]
e=[['x'],['y']]
[[a.b]]
# 善用的情况：

[a] #

x = 1
y = 2

[[a.b]]

a = +1.0e1
bbb_bbb = '''
        bbb
     bbb
'''

[[a.b]]

c = { x = 1, y = 2 }
d = [ 1, 2, 3 ]
e = [
  [ 'x' ],
  [ 'y' ],
]

[[a.b]]
             # 滥用的情况：
[    a    ]  #
  x = 1

  y = 2

  [[ a. b ]]
    a       = +1.0e1
    bbb_bbb = '''
        bbb
     bbb
'''
  [[ a .b ]]
    c = {x  =1  ,y=  2}

d = [ 1 ,2
	,3
]
e = [

['x']

,['y']]
  [[ a . b ]]
# 错用的情况（下述所有的空格写法都会造成语法错误）：
[ [a.b] ]
a=+ 1 . 0 e 1
bbb _ bbb=1970 - 01 - 01   00 : 00 : 00 Z
```

　　简单来说，除非是包含换行的内联数组，否则不要进行缩进。
　　缩进子小节名会使得它们反而对不齐（因为路径本来就始终从根表开始），而缩进键值对会使得层级关系更加混乱、与相应小节名的关系也不再紧密、多行字符串的后续行位置变得糟糕。
　　毕竟，避免狂敲缩进，是 TOML 语法最大的优点和特色。



### 其他事项

　	TOML 0.4 指明 TOML 文件必须采用 UTF-8 编码，并且只能包含完整、有效的 Unicode 字符（这意味着即便在注释中，错误也不会被忽略）。

　　TOML 0.5 指明，标准的 TOML 文件扩展名应当为 `.toml`。

　　许多“智能”文本编辑器会自动剔除行末空白字符，这会破坏包含行末空白的多行字符串，可以借助 [`.EditorConfig`](https://editorconfig.org/) 统一阻止这种行为：

```
[*.toml]

trim_trailing_whitespace = false
```