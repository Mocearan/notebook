# inline functions

---

Writing functions provides many potential benefits, as code in a function:

- Is easier to read and understand in the context of the overall program.
- Is easier to use, as you can call the function without understanding how it is implemented.
- Is easier to update, as the code in a function can be updated in one place.
- Is easier to reuse, as functions are naturally modular.

However, one downside of using a function is that every time a function is called, there is a certain amount of performance overhead that occurs. 

>  CPU must store the address of the current instruction it is executing (so it knows where to return to later) along with the values of various CPU registers (so they can be restored upon returning). 
>
>  parameters must be instantiated and then initialized.
>
> the execution path has to jump to the code in the function.
>
> When the function ends, the program has to jump back to the location of the function call, and the return value has to be copied so it can be output.

对于规模较大的函数，这样的函数调用开销并不明显。但是对于功能相对简单的函数来说，这样的调用开销与函数本身的开销相比就不能忽视。



## 内联展开 inline expansion

 **Inline expansion** is a process where a function call is replaced by the code from the called function’s definition.

```c++
int min(int x, int y)
{
    return (x < y) ? x : y;
}

std::cout << min(5, 6) << '\n';
std::cout << min(3, 2) << '\n';

////////////////////////////////////
std::cout << ((5 < 6) ? 5 : 6) << '\n';
std::cout << ((3 < 2) ? 3 : 2) << '\n';
```

Beyond removing the cost of function call overhead, inline expansion can also allow the compiler to optimize the resulting code more efficiently.

> 如上述展开中，三目运算符对常量的运算可以直接优化为编译时常量硬编码在代码中。
>
> ```c++
> std::cout << 5 << '\n';
> ```

### performance of inline expansion

如果函数规模较大，则内联展开的代价其实会很高。因为在每个展开处，都需要完整的展开代码指令，文件的规模会随之增长。较大的文件因不适合缓存而导致编译变慢。

The decision about whether a function would benefit from being made inline，depending on the relative cost of a function call, the size of the function, and what other optimizations can be performed.

Inline expansion is best suited to simple, short functions (e.g. no more than a few statements), especially cases where a single function call is executed more than once (e.g. function calls inside a loop).



## inline functions

A function that is eligible to have its function calls expanded is called an **inline function**.

### when occurs

每个函数调用都可能会发生以下情况之一：

- Must be expanded.

- May be expanded (most functions are in this category).

  > ​		their function calls can be expanded if and when it is beneficial to do so. For functions in this category, a modern compiler will assess each function and each function call to make a determination about whether that particular function call would benefit from inline expansion. A compiler might decide to expand none, some, or all of the function calls to a given function.

- Can’t be expanded.

Modern optimizing compilers make the decision about when functions should be expanded inline.

### inline keyword

Historically, compilers either didn’t have the capability to determine whether inline expansion would be beneficial, or were not very good at it. 

`inline`, which was intended to be used as a hint to the compiler that a function would benefit from being expanded inline:

```c++
inline int min(int x, int y) // hint to the compiler that it should do inline expansion of this function
{
  return (x < y) ? x : y;
}

std::cout << min(5, 6) << '\n';
std::cout << min(3,2) << '\n';
```

in modern C++, the `inline` keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:

- 优化阶段过早，可能造成性能损害
- 只是一个提示，而编译器还有可能在没有inline提示的函数调用上进行内立案展开
- inline具有粒度级别可能存在误解，在定义上的`inline`却在每个调用处进行展开的决议，却没有语法在此处施加影响。

Modern optimizing compilers are typically very good at determining which functions should be made inline -- better than humans in most cases. As a result, the compiler will likely ignore or devalue any request you make to `inline` a function anyway.

> Do not use the `inline` keyword to request inline expansion for your functions.

### **inline** modernly

in modern C++, the `inline` concept has evolved to have a new meaning: multiple definitions are allowed in the program.

This is true for functions as well as variables. Thus, if we mark a function as inline, then that function is allowed to have multiple definitions (in different files), as long as those definitions are identical.

In order to do inline expansion, the compiler needs to be able to see the full definition of an inline function wherever the function is called. Therefore, inline functions are typically defined in header files, where they can be #included into any code file that needs to see the full definition of the function.

> Avoid the use of the `inline` keyword for functions unless you have a specific, compelling reason to do so.