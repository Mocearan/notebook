# type

​		We use a **data type** (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. 

​		给原本无意义的**位序列**提供了语义含义。

---

​		类型限制**对象、引用、函数（包括函数模板特化）和表达式**这些实体的操作，并给原本无意义的**位序列**提供了语义含义。

​		**类型对于不同的数据类型，应用不同的数据解译方案**，这就使得同样的数据（纯粹的二进制数据，即**位序列**），可以表达多种多样的含义，从而构建起了计算机抽象现实世界的基础。

## memory and type

​		The smallest unit of memory is a **binary digit** (also called a **bit**), which can hold a value of 0 or 1. 

​		Memory is organized into sequential units called **memory addresses** (or **addresses** for short). the memory address allows us to find and access the contents of memory at a particular location.

​		 the memory address allows us to find and access the contents of memory at a particular location.each memory address holds 1 byte of data.

​		We use a **data type** (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. 

> When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). 

​		most objects actually take up more than 1 byte of memory. A single object may use 2, 4, 8, or even more consecutive memory addresses. The amount of memory that an object uses is based on its data type.

​		we typically access memory through variable names (and not directly via memory addresses), the compiler is able to hide the details of how many bytes a given object uses from us. 



​		计算机以2的整数次幂个bit为单位划块来处理内存数据，可寻址的最小内存块称为“字节”（byte）。存储的基本单元称为“字”（word），通常由几个字节组成，视不同机器有所不同。

​		c++中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8bit构成，字则由32或64bit构成，也就是4或8字节。

​		计算机将内存中的每个字节与一个数字（address，地址）关联，在一个字节为8bit、字为32bit的机器上，我们可能看待一个字的内存区如图：

![image-20220608063536846](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220608063536846.png)

​		左侧地址，右侧是每个字节的8bit。

​		可以使用某个地址来表示从这个地址开始的大小不同的比特串。为了赋予内存中某个地址明确地含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

​		即，**内存只是简单的存放了二进制数据，对这些二进制数据的定义与解释依赖于类型，不同类型有对这个数据的不同的解释方式。导致同一数据在不同的类型上有不同的表现。**



## 类型的分类

### 按照声明分类

- 基础类型：`std::is_fundamental`
  - `void`类型：`std::is_void`
  - `std::nullptr_t`：`std::is_null_pointer`
  - 算数类型：`std::is_arithmetic`
    - 浮点类型（float、double、long double）：`std::is_floating_point`
    - 整数类型：`std::is_integral`
      - `bool`类型
      - 字符类型
        - 窄字符类型
          - 通常字符类型：`char、signed char、unsigned char`
          - `char8_t`
        - 宽字符类型：`char16_t、char32_t、wchar_t`
      - 有符号整数类型：`short int、long int、long long int`
      - 无符号整数类型：`unsigned short int、unsigned int、unsigned long int、unsigned long long int`
- 复合类型：`std::is_compound`
  - 引用类型：`std::is_reference`
    - 左值引用：`std::is_lvalue_reference`
      - 到对象的左值引用类型+
      - 到函数的左值引用类型
    - 右值引用：`std::is_rvalue_reference`
      - 到对象的右值引用类型
      - 到函数的右值引用类型
  - 指针类型：`std::is_pointer`
    - 指向对象的指针（对象指针）类型
    - 指向函数的指针（函数指针）类型
  - 指向成员的指针（成员指针）：`st d::is_member_pointer`
    - 指向数据成员的指针类型：`std::is_member_object_pointer`
    - 指向成员函数的指针类型：`std::is_member_function_pointer`
  - 数组类型：`std::is_array`
  - 函数类型：`std::is_function`
  - 枚举类型：`std::is_enum`
  - 类类型：
    - 非联合体类型：`std::is_class`、`struct`
    - 联合体类型：`std::is_union`

**对于除了引用和函数外的每个类型，类型系统还支持该类型的三个附加cv限定版本（const、volatile、const volatile）**

> **cv限定：**
>
> ​	类型说明符序列中，用以指定被声明对象的常量性或易变性。
>
> ps：c++/基础语言/声明/说明符/cv类型限定符



### 按照性质分类

​		根据类型的各项性质，将它们分组到不同的类别之中：

- 对象类型

  是非函数类型、非饮用类型且非`void`类型的（可有cv限定的）类型：`std::is_object`

- 标量类型

  可有cv限定的算数、指针、成员指针、枚举和`std::nullptr_t`类型：`std::is_scalar`

- 类型特征库中的具名要求类型

  - 平凡类型：`std::is_trivial`

  - POD类型：`std::is_pod`

  - 字面类型：`std::is_literal_type`

  - 其他类别

    > **类型支持：**
    >
    > ps：c++语言/标准库/语言支持库/类型支持
    >
    > **具名要求：**
    >
    > ​		C++标准的规范性文本中使用的具名要求，用以定义标准库的期待。
    >
    > ps：c++语言/标准库/具名要求

### 按照结构分类

> **Types in C++ are：**
>
> **Short version:** 
>
> -   Object types: scalars, arrays, classes, unions
> -   Reference types
> -   Function types
> -   (Member types) [see below]
> -   void
>
> ------
>
> **Long version**
>
> -   Object types
>     -   Scalars
>         1.  arithmetic (integral, float)
>         2.  pointers: T * for any type T
>         3.  enum
>         4.  pointer-to-member
>         5.  nullptr_t
>     -   Arrays: T[] or T[N] for any complete, non-reference type T
>     -   Classes: class Foo or struct Bar
>         1.  Trivial classes
>         2.  Aggregates
>         3.  POD classes
>         4.  (etc. etc.)
>     -   Unions: union Zip
> -   References types: T &, T && for any object or free-function type T
> -   Function types
>     -   Free functions: R foo(Arg1, Arg2, ...)
>     -   Member functions: R T::foo(Arg1, Arg2, ...)
> -   void
>
> Member types work like this. A member type is of the form T::U, but you can't have objects or variables of member type. You can only have member *pointers*. A member pointer has type T::* U, and it is a pointer-to-member-object if U is a (free) object type, and a pointer-to-member-function if U is a (free) function type.
>
> All types are complete except void, unsized arrays and declared-but-not-defined classes and unions. All incomplete types except void can be completed.
>
> All types can be const/volatile qualified.
>
> The <type_traits> header provides trait classes to check for each of these type characteristics.

c++支持广泛的数据类型，定义了内置数据类型也为程序员提供了自定义数据类型的机制。因此c++标准库定义了一些更加复杂的数据类型，比如可变长字符串和向量等。

> c++类型系统由语言支持的类型和标准库提供的类型支持共同构建。



## type aliases



### using

​		In C++, **using** is a keyword that creates an alias for an existing data type.

`using type_name_t = type;`

> Many type alias names use a “_t” or “_type” suffix to help decrease the chance of naming collisions with other identifiers.

```c++
using distance_t = double; // define distance_t as an alias for type double
distance_t milesToDestination{ 3.4 }; // defines a variable of type double
```

​		An alias does not actually define a new type -- it just introduces a new identifier for an existing type. An alias is completely interchangeable with the aliased type.

> This allows us to do things that are syntactically valid but semantically meaningless. For example:
>
> ```c++
> using miles_t = long; 
> using speed_t = long;
> 
> miles_t distance{5};
> speed_t mhz{3200};
> // both long
> 
> // The following is syntactically valid (but semantically meaningless)
> distance = mhz;
> ```
>
> ​		Because the compiler does not prevent these kinds of semantic errors for type aliases, we say that aliases are not **type safe**. In spite of that, they are still useful.
>
> > ​		Some languages support the concept of a **strong typedef** (or strong type alias). A strong typedef actually creates a new type that has all the original properties of the original type, but the compiler will throw an error if you try to mix values of the aliased type and the strong typedef. As of C++20, C++ does not directly support strong typedefs (though enum classes are similar), but there are quite a few 3rd party C++ libraries that implement strong typedef-like behavior.

​		Because scope is a property of an identifier, type alias identifiers follow the same scoping rules as variable identifiers: a type alias defined inside a block has block scope and is usable only within that block, whereas a type alias defined in the global namespace has file scope and is usable to the end of the file.

​		If you need to use one or more type aliases across multiple files, they can be defined in a header file and #included into any code files that needs to use the definition:

```c++
// mytypes.h
#ifndef MYTYPES
#define MYTYPES

	using miles_t = long;
	using speed_t = long;

#endif // MYTYPES
```

​		

### typedef

​		**typedef** (which is short for “type definition”) is a keyword with the same semantics as “using”, but reversed syntax.

`typedef type type_name_t;`

​		Typedefs are still in C++ for historical reasons, but their use is discouraged.

​		the syntax for typedefs can get ugly with more complex types. 

> ```c++
> typedef int (*fcn_t)(double, char); // fcn_t hard to find
> using fcn_t = int(*)(double, char); // fcn_t easier to find
> ```



### using type aliases for platform independent coding

​		One of the uses for type aliases is that they can be used to hide platform specific details. 

​		In order to make sure each aliased type resolves to a type of the right size, type aliases of this kind are typically used in conjunction with preprocessor directives:

```c++
#ifdef INT_2_BYTES
using int8_t = char;
using int16_t = int;
using int32_t = long;
#else
using int8_t = char;
using int16_t = short;
using int32_t = int;
#endif
```

> ​		The fixed-width integers (such as `std::int_fast16_t` and `std::int_least32_t`) and `size_t` type are actually just type aliases to various fundamental types.

### using type aliases to make complex types simple

```c++
using pairlist_t = std::vector<std::pair<std::string, int>>; // make pairlist_t an alias for this crazy type

bool hasDuplicates(pairlist_t pairlist) // use pairlist_t in a function parameter
{
    // some code here
    return false;
}

int main()
{
     pairlist_t pairlist; // instantiate a pairlist_t variable

     return 0;
}
```



### using type aliases for legibility

​		Type aliases can also help with code documentation and comprehension.

```c++
using testScore_t = int;
testScore_t gradeTest();
```



### using type aliases for easier code maintenance

​		However, if you use type aliases, then changing types becomes as simple as updating the type alias (e.g. from `using studentID_t = short;` to `using studentID_t = long;`).





# Fundamental data types

These are called **fundamental data types**, but are often informally called **basic types**, **primitive types**, or **built-in types**.

---

## 空类型

### void

空类型并非具有实际宽度的类型。variables can not be defined with a type of void:

或指明函数实体的类型（返回值类型）为空，或指明指针类型在编译阶段未定。

### std::nullptr_t

​		是空指针字面量 nullptr的类型。它是既非指针类型也不是指向成员指针类型的独立类型。

​	`typedef decltype(nullptr) nullptr_t; // <cstddef>` 

​		类型本身的定义是由``nullptr``字面值推导而来。这一点与普遍的类型抽象含义是不同的。

> **nullptr：**
>
> ​		关键词 `nullptr` 代表指针字面量，纯右值。
>
> ```c++
> #ifndef __cplusplus
> #define NULL ((void *)0)
> #else   /* C++ */
> #define NULL 0
> #endif  /* C++ */
> 
> #define NULL nullptr // may (void*)0
> // 如果是整型字面量0，是前述对象要素分析中，是不具有地址属性的。强制转换为(void*)，使其可寻址到虚拟内存空间起始处。
> ```
>
> 
>
> 基于上述代码，在没有通过`std::nullptr_t`将nullptr和`std::nullptr_t`进行类型匹配时，可能会因为空指针本身值属性的机制导致二义性。
>
> ```c++
> #include <cstddef>
> #include <iostream>
> 
> void f(int*)
> {
> std::cout << "Pointer to integer overload\n";
> }
> 
> void f(double*)
> {
> std::cout << "Pointer to double overload\n";
> }
> 
> void f(std::nullptr_t)
> {
> std::cout << "null pointer overload\n";
> }
> 
> int main()
> {
> int* pi {}; double* pd {};
> f(pi);
> f(pd);
> f(nullptr); // 无 void f(nullptr_t) 可能有歧义 //void* -> int* / double*
> // f(0);    // 歧义调用：三个函数全部为候选     //void* -> int* / double* / nullptr_t
> // f(NULL); // 若 NULL 是整数空指针常量则为歧义  //void* -> int* / double* / nullptr_t
>        // （如在大部分实现中的情况）
>    }
> ```
> 
>也就是 说，使用`std::nullptr_t`和`nullptr`能够避免`` NULL，0，void*``之间的歧义。

>   在c++中包含`<stddef.h>`而非`<cstddef>`仍然能够通过`::nullptr_t`的形式通过全局名字搜索来使用`nullptr_t`。

## 算数类型

整形（integral type， 包括字符和布尔类型在内）和 浮点型。	

算数类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。

c++标准规定了尺寸的最小值。同时允许编译器赋予这些类型更大的尺寸。

c++的字符和布尔类型其实也都属于整数类型范畴。只不过字符和布尔并不表示整数，而使用其各自的字符集查找方案或者标记替换一定尺寸的整数。

![image-20200915225845274](https://gitee.com/masstsing/picgo-picserver/raw/master/20200915225846.png)





### 整数类型

​		整数用于表示不同尺寸的整数。

​		c++语言规定：

-   int至少和short一样大

-   long至少和int一样大 (32位系统上，ling == int 32 bit, 64位系统上, 64bit)

    所以long的位数和系统位数，一般来说是一样的。在查看指针地址等有关于操作系统字长的数据时，应该使用long作为数据类型。

    [字长]([https://baike.baidu.com/item/%E5%AD%97%E9%95%BF/97660?fr=aladdin](https://baike.baidu.com/item/字长/97660?fr=aladdin))

-   long long至少和long一样大

其中数据类型long long是在c++11 中新定义的。

![image-20200915232056919](https://gitee.com/masstsing/picgo-picserver/raw/master/20200915232057.png)



#### 布尔类型

```c++
bool flag1 = true;
bool flag2 = false;

if(flag1 == true && flag2 == false)
    cout << "condition right" << endl;

//////////////////////////////////////////////////////////////

#include <iostream>

int main()
{
    std::cout << true << " " << false << std::endl;
    std::cout << std::boolalpha; // print bools as true or false

    std::cout << true << '\n';
    std::cout << false << '\n';
    return 0;
}
```

> 标准化之前的C++和c一样没有bool类型，在ANSI/ISO c++ standard后加入了bool。

-   `bool`， 其大小为1字节

-    c++中，布尔类型作为数值类型实现

     - true为1，false为0.

     - 可以与其他的算术类型进行运算
     
     - 当非零值（无论正负）赋给bool时，认为是真，且都成为true（1）0则为假
     
       ```c++
       #include <iostream>
       
       using namespace std;
       int main(void)
       {
       
         bool b = true;
         cout << sizeof(b) <<endl; //1
       
         bool bb = 10000000000;
         cout << sizeof(bb) << endl;//1
         cout << bb << endl;//1
         return 0;
       }
       ```
     
       



#### 字符类型

c++提供了几种字符类型，其中多数支持国际化。（以国际化的字符集表示法去解析该类型存储的数据）。

A **character** can be a single letter, number, symbol, or whitespace.

##### 窄字符类型

Similar to how a Boolean value `0` is interpreted as `false` and non-zero is interpreted as `true`, the integer stored by a `char` variable are intepreted as an `ASCII character`.

> **ASCII** stands for American Standard Code for Information Interchange, and it defines a particular way to represent English characters (plus a few other symbols) as numbers between 0 and 127 (called an **ASCII code** or **code point**).
>
> ![image-20220425153233160](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220425153233160.png)
>
> Codes 0-31 are called the unprintable chars, and they’re mostly used to do formatting and control printers. Most of these are obsolete now. If you try to print these chars, the results are dependent upon your OS (you may get some emoji-like characters).
>
> Codes 32-127 are called the printable characters, and they represent the letters, number characters, and punctuation that most computers use to display basic English text.

- 通常字符类型 `char 、signed char 、unsigned char`

  - 基本的字符类型是**char**
  
    ​	一个char的空间应确保可以存放机器基本字符集几种任意字符对应的数字值。
  
    ​	也就是说，**一个char的大小和一个机器字节一样**。使用ASCII编码。
  
    > ```c++
    > `‘0’`,  48
    > 
    > `‘A’`, 65
    > 
    > `‘a’`, 97
    > 
    > `‘\0’`, 0
    > 
    > // c++中并没有定义byte字节类型，（数据存储单位，并非表示字符，只用于存储一个字节大小的数据）。
    > // c++20 中通过类型支持库，引入了std::byte
    > 
    > // 所以在c++中，
    > // char的首要作用是表示0-127的标准ASCII码的字符集，表示字符数据；
    > // 另一个次要作用是，作为非常规的有符号字节存储单位来使用（存储8位有符号数据）。但是更为普遍的做法是，使用unsigned char来存储byte数据。
    >   
    >   
    >   char ch{5}; // initialize with integer 5 (stored as integer 5)
    > char ch{'5'}; // initialize with code point for '5' (stored as integer 53)
    > ```
  
    ```c++
    // 在c++中对于，ASCII码值和字符之间的转换使用
    //
    
    #include <iostream>
    
    using namespace std;
    
    int main(void)
    {
        // 将字符转换为ASCII码值，将其转换为整数类型即可。
        char c = '?';
        cout << (short)c << endl;
        cout << (int)';' << endl;
    
        // 将ASCII码值转换为字符，将其转换为字符类型即可。
        char cc = 60;
        cout << cc << endl;
        cout << (char)61 << endl;
    
        return 0;
    }
    ```
  
  - signed char / unsigned char
  
    - By default, a char may be signed or unsigned (though it’s usually signed).
    - If you’re using a char to hold small integers (something you should not do unless you’re explicitly optimizing for space), you should always specify whether it is signed or unsigned. A signed char can hold a number between -128 and 127. An unsigned char can hold a number between 0 and 255.

**拓展字符类型：其他的字符类型用于扩展字符集，`char8_t, char16_t, char32_t, wchar_t`**

- `char8_t （c++20）`

###### 转义字符

由于有些字符不能直接使用或有歧义，在表达该字符时需要使用‘\’进行换行。

An escape sequence starts with a ‘\’ (backslash) character, and then a following letter or number.

![image-20220425154532866](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220425154532866.png)





##### 宽字符类型 `char16_t/ char32_t / wchar_t`

other character encoding standards exist to map integers (of varying sizes) to characters in other languages.

The most well-known mapping outside of ASCII is the **Unicode standard**, which maps over 144,000 integers to characters in many different languages. 

> Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32).
>
>  However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).

- ```char16_t```：为Unicode， 使用时需要加前缀u

- ```char32_t```：为Unicode， 使用时需要加前缀U

  > `char16_t` and `char32_t` were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters
  >
  > You won’t need to use `char8_t`, `char16_t`, or `char32_t` unless you’re planning on making your program Unicode compatible.

- ```wchar_t```：32bit，用于确保可以存放机器最大扩展字符集中的任意一个字符。使用时需要加前缀L。

  > `wchar_t` **should be avoided in almost all cases** (except when interfacing with the Windows API). Its size is implementation defined, and is not reliable. **It has largely been deprecated.**

```c++
// 宽字符类型的使用
//

#include <iostream>
#include <string>
using namespace std;


int main(void)
{
    wchar_t c1 = L'中';

    char16_t c2 = u'龙';

    char32_t c3 = U'化';

    char c = 'a';
    char16_t ccc = u'a';
    char32_t cccc = U'a';
    wchar_t wc = L'a';

    cout << "char size " << sizeof(c) << endl;
    cout << "char16 size " << sizeof(ccc) << endl;
    cout << "char32 size " << sizeof(cccc) << endl;
    cout << "wchar size " << sizeof(wc) << endl;

    wcout << wc << endl;

    wchar_t e = L'我';
    cout << e << endl; // 得到unicode的编码值
    wcout << e << endl; // 输出中文, 这种方式还是有问题
    wcout << (wchar_t)e << endl;// 输出中文，这种方式也有问题
    cout << "\u4E2D" << endl; // 通过Unicode码使用字符，需要加\u进行编码指定

    return 0;
}
```



**字符处理函数 **

```c++
//  <cctype> 
//   源于C语言标准库中字符处理 ctype.h
namespace std
{
  using ::isalnum;	
  using ::isalpha;	
  using ::iscntrl;	
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
} // namespace std

#ifdef _GLIBCXX_USE_C99_CTYPE_TR1
#undef isblank
namespace std
{
  using ::isblank; // 是否空字符
} // namespace std
#endif // _GLIBCXX_USE_C99_CTYPE_TR1
```

![image-20201213165328434](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20201213165328434.png)

> *// Get rid of those macros defined in <ctype.h> in lieu of real functions.*
>
> c语言中的相关宏，被换成了真正的函数



#### 有符号和无符号整型

除布尔型和扩展的字符型外，其他的整型都可以划分为**带符号（signed）和无符号的（unsigned）**。

带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

> This attribute of being positive, negative, or zero is called the number’s **sign**.

##### 字符型

类型int、short、long和long long都是带符号的。加前缀unsigned可以得到无符号的。

字符型被分为了三种：char、signed char、unsigned char。

> **Note**：
>
> ​	char 和 signed char 并不一样。
>
> ​		尽管字符型有三种，但是字符的表现形式却只有两种：带符号和无符号的。
>
> ​		char实际上会表现为有无符号两种形式中的一种，具体是哪种由编译器来决定。(char 最终的编译是按照有符号还是无符号解析，是由编译器来决定的。)

无符号类型中的所有bit都用来存储值。

c++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。

因此，8bit的signed char 理论上应该可以表示-127值127区间内的值，大多数现代计算机将实际的表示范围定位-128到127.（因为存在正负0，所以当值为0时，将符号位0/1中的某一个与后续的所有`0`组合为-128（补码）。



##### signed integers

有符号整数类型``（short int、int、long int、long long int (C++11 起)）``

 C++ only guarantees that integers will have a certain minimum size, not that they will have a specific size.

![image-20220416100938067](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220416100938067.png)

All of the integers (except int) can take an optional *int* suffix，This suffix should not be used. 

> In addition to being more typing, adding the *int* suffix makes the type harder to distinguish from variables of type *int*. This can lead to mistakes if the short or long modifier is inadvertently missed.

The integer types can also take an optional *signed* keyword,this keyword should not be used, as it is redundant, since integers are signed by default.



###### integer overflow

For the math inclined, an n-bit signed variable has a range of -(2n-1) to 2n-1-1.

For the non-math inclined… use the table. :)

![image-20220416101541138](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220416101541138.png)

**Integer overflow** (often called *overflow* for short) occurs when we try to store a value that is outside the range of the type.

> Essentially, the number we are trying to store requires more bits to represent than the object has available. In such a case, data is lost because the object doesn’t have enough memory to store everything.

Signed integer overflow will result in undefined behavior.



##### unsigned integers

无符号整数类型``（unsigned short int、unsigned int、unsigned long int、unsigned long long int (C++11 起)）``

Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).

**Unsigned integers** are integers that can only hold non-negative whole numbers.

To define an unsigned integer, we use the *unsigned* keyword. 

###### Unsigned integer overflow

An n-bit unsigned variable has a range of 0 to (2n)-1.

Here’s a table showing the range for unsigned integers:

![image-20220416103035784](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220416103035784.png)

Any number bigger than the largest number representable by the type simply “wraps around” (sometimes called “modulo wrapping”)



###### controversy

- consider the subtraction of two unsigned numbers

  ```c++
  #include <iostream>
  
  int main()
  {
  	unsigned int x{ 3 };
  	unsigned int y{ 5 };
  
  	std::cout << x - y << '\n';  // 4294967294
  	return 0;
  }
  ```

- mix signed and unsigned integers

  ```c++
  signed int s { -1 };
      unsigned int u { 1 };
  
      if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
          std::cout << "-1 is less than 1\n";
      else
          std::cout << "1 is less than -1\n"; // this statement executes
  ```

- positive expected but negative given

  ```c++
  void doSomething(unsigned int x)
  {
      // Run some code x times
  
      std::cout << "x is " << x << '\n';
  }
  
  int main()
  {
      doSomething(-1); // C++ will freely convert between signed and unsigned numbers, but it won’t do any range checking to make sure you don’t overflow your type.
  
      return 0;
  }
  ```

###### when use

First, unsigned numbers are preferred when dealing with bit manipulation

Second, mainly those having to do with array indexing

use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.





### 浮点类型

#### 浮点精度

The **precision** of a floating point number defines how many *significant digits* it can represent without information loss.

- ```float```：单精度，1个机器字长（32bit / 64bit）。
- ```double```：双精度， 2个机器字长
- ```long double```：拓展精度， 3 或4个机器字长

一般来说，类型 float 和 double 分别有 7 和 16个有效位。long double则通常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

> On modern architectures, floating point representation almost always follows IEEE 754 binary format. In this format, a float is 4 bytes, a double is 8, and a long double can be equivalent to a double (8 bytes), 80-bits (often padded to 12 bytes), or 16 bytes.

![image-20220425105641898](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220425105641898.png)

```c++
float fValue;
double dValue;
long double ldValue;
```



#### 浮点字面值

When using floating point literals, always include at least one decimal place (even if the decimal is 0). 

floating point literals default to type double. An f suffix is used to denote a literal of type float.

```c++
int x{5}; // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
```

![image-20220425112444827](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220425112444827.png)

> The 80-bit floating point type is a bit of a historical anomaly. On modern processors, it is typically implemented using 12 or 16 bytes (which is a more natural size for processors to handle).
>
> It may seem a little odd that the 80-bit floating point type has the same range as the 16-byte floating point type. This is because they have the same number of bits dedicated to the exponent -- however, the 16-byte number can store more significant digits.

##### rounding error

123456792 is greater than 123456789. The value 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision (and the result of 123456792 is precise only to 7 significant digits). 

We lost some precision! When precision is lost because a number can’t be stored precisely, this is called a **rounding error**.

Rounding errors occur when a number can’t be stored precisely. 

```c++
double d{0.1};
std::cout << d << '\n'; // use default cout precision of 6
std::cout << std::setprecision(17);
std::cout << d << '\n';

// 0.1
// 0.10000000000000001


double d1{ 1.0 };
std::cout << d1 << '\n';

double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0
std::cout << d2 << '\n';

// 1
// 0.99999999999999989
```

the number is not *exactly* 0.1.

One last note on rounding errors: mathematical operations (such as addition and multiplication) tend to make rounding errors grow. So even though 0.1 has a rounding error in the 17th significant digit, when we add 0.1 ten times, the rounding error has crept into the 16th significant digit. Continued operations would cause this error to become increasingly significant.

避免舍入错误的一个方法是，将需要的有效小数位，通过乘以10^n放大到整数位上。

##### **NaN and Inf**

The first is **Inf**, which represents infinity. Inf can be positive or negative. The second is **NaN**, which stands for “Not a Number”.

```c++
#include <iostream>

int main()
{
    double zero {0.0};
    double posinf { 5.0 / zero }; // positive infinity
    std::cout << posinf << '\n';

    double neginf { -5.0 / zero }; // negative infinity
    std::cout << neginf << '\n';

    double nan { zero / zero }; // not a number (mathematically invalid)
    std::cout << nan << '\n';

    return 0;
}

// inf
// -inf
// -nan 
```

> Avoid division by 0 altogether, even if your compiler supports it.

## 基础类型的选择

与c一样，c++的设计准则之一也是尽可能地接近硬件。c++的算数类型必须满足各种硬件特质，所以它们常常显得繁杂而令人不知所措

事实上，大多数程序员能够（也应该）对数类型的使用作出限定从而简化选择的过程。

- 当明确知晓数值不可能为负时，选用无符号类型

- 使用int执行整数运算。

  在实际应用中，short常常显得太小而long一般和int有一样的尺寸。

  如果数值超过了int的表示是范围，选择用long long

- 在算数表达式中不要使用char 和 bool，只有才存放字符或者布尔值时才使用它们。

  因为类型char在不同机器上可能是有符号和无符号的，使用char进行运算可能会出现问题。如果需要一个不大的整数，明确指出是signed char还是unsigned char。

- 执行浮点运算选用double。

  这是因为float通常精度不够而且双精度浮点数和运算代价基本相同甚至更低。long double提供的精度一般情况下是没必要的。



## 基础类型的极限值

​	

```c++
 // <climits>
 //  https://zh.cppreference.com/w/cpp/header/climits

#define CHAR_BIT /* 见定义 */
#define SCHAR_MIN /* 见定义 */
#define SCHAR_MAX /* 见定义 */
#define UCHAR_MAX /* 见定义 */
#define CHAR_MIN /* 见定义 */
#define CHAR_MAX /* 见定义 */
#define MB_LEN_MAX /* 见定义 */
#define SHRT_MIN /* 见定义 */
#define SHRT_MAX /* 见定义 */
#define USHRT_MAX /* 见定义 */
#define INT_MIN /* 见定义 */
#define INT_MAX /* 见定义 */
#define UINT_MAX /* 见定义 */
#define LONG_MIN /* 见定义 */
#define LONG_MAX /* 见定义 */
#define ULONG_MAX /* 见定义 */
#define LLONG_MIN /* 见定义 */
#define LLONG_MAX /* 见定义 */
#define ULLONG_MAX /* 见定义 */
```

c++与C的类型系统并非完全相同，但可兼容。为此，c++有着更严格的类型检查。

```c++
// <limits>
//  https://zh.cppreference.com/w/cpp/header/limits

namespace std {
    template<class T> class numeric_limits;
 
    enum float_round_style {
        round_indeterminate         = -1,
        round_toward_zero           =  0,
        round_to_nearest            =  1,
        round_toward_infinity       =  2,
        round_toward_neg_infinity   =  3,
    };
 
    enum float_denorm_style {
        denorm_indeterminate = -1,
        denorm_absent        =  0,
        denorm_present       =  1
    };
 
 
    template<> class numeric_limits<bool>;
 
    template<> class numeric_limits<char>;
    template<> class numeric_limits<signed char>;
    template<> class numeric_limits<unsigned char>;
    template<> class numeric_limits<char8_t>;
    template<> class numeric_limits<char16_t>;
    template<> class numeric_limits<char32_t>;
    template<> class numeric_limits<wchar_t>;
 
    template<> class numeric_limits<short>;
    template<> class numeric_limits<int>;
    template<> class numeric_limits<long>;
    template<> class numeric_limits<long long>;
    template<> class numeric_limits<unsigned short>;
    template<> class numeric_limits<unsigned int>;
    template<> class numeric_limits<unsigned long>;
    template<> class numeric_limits<unsigned long long>;
 
    template<> class numeric_limits<float>;
    template<> class numeric_limits<double>;
    template<> class numeric_limits<long double>;
}
```



虽然定义了类型的极限值，但是在c++仍然允许类型数据溢出。但是由于计算机最终处理数据是以补码的形式处理，所以在极限值的溢出处理上遵循补码表示原则：[机器数编码](https://blog.csdn.net/dai_ma_dong/article/details/88853006)

```c++
#include <iostream>
#include <climits>

using namespace std;

int main(void)
{
    cout << "int max : " << INT_MAX  <<endl;
    cout << "uint max : " << UINT_MAX    <<endl;
    cout << "ull max : " <<  ULONG_LONG_MAX  <<endl;

    int val1 = INT_MAX + 1;
    cout << "int max + 1 :" << val1 << endl;
    val1 = INT_MAX + 2;
    cout << "int max + 2 :" << val1 << endl;
    unsigned int val2 = UINT_MAX + 1;
    cout << " uint max + 1 :" << val2 << endl;
    val2 = UINT_MAX + 2;
    cout << " uint max + 2 :" << val2 << endl;
    unsigned int val3 = -1;
    cout << " uint -1 :" << val3 << endl;


    return 0;
}



int max : 2147483647
uint max : 4294967295
ull max : 18446744073709551615
int max + 1 :-2147483648
int max + 2 :-2147483647
 uint max + 1 :0
 uint max + 2 :1
 uint -1 :4294967295
```





# 类型转换

​		The process of converting a value from one type to another type is called **type conversion**.

​		类型转换实际上是转换位序列的语义含义。

## 隐式转换

​		When the compiler does type conversion for us, we call this **implicit type conversion**.

​		Unsafe implicit conversions will typically either generate a compiler warning, or (in the case of brace initialization) an error.

 		Brace initialization will ensure we don’t try to initialize a variable with a initializer that will lose value when it is implicitly type converted:

## 显式转换

​		**Explicit type conversion** allow us (the programmer) to explicitly tell the compiler to convert a value from one type to another type, and that we take full responsibility for the result of that conversion (meaning that if the conversion results in the loss of value, it’s our fault).

### C风格转换

### static_cast

​		`static_cast<new_type>(expression)`

​		static_cast takes the value from an expression as input, and returns that value converted into the type specified by *new_type* (e.g. int, bool, char, double).

```c++
#include <iostream>

void print(int x)
{
	std::cout << x;
}

int main()
{
	print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int

	return 0;
}
```

​		When we pass in a variable, that variable is evaluated to produce its value, and that value is then converted to the new type. The variable itself is *not* affected by casting its value to a new type.

​		Old variable still holds the same value even after we’ve cast its value。

​		The static_cast operator will produce undefined behavior if the value being converted doesn’t fit in range of the new type.

### dynamic_cast

### const_cast

### reinterpret_cast



## 自定义转换









