# Module 模块

---

​		模块是c++20引入的在语言层面直接表达模块化的特性。

```C++
export module Vector;     // defining the module called "Vector"

export class Vector {
public:
        Vector(int s);
        double& operator[](int i);
        int size();
private:
        double* elem;          // elem points to an array of sz doubles
        int sz;
};

Vector::Vector(int s)
        :elem{new double[s]}, sz{s}             // initialize members
{
}

double& Vector::operator[](int i)
{
        return elem[i];
}

int Vector::size()
{
        return sz;
}

export bool operator==(const Vector& v1, const Vector& v2)
{
    if (v1.size()!=v2.size())
        return false;
    for (int i = 0; i<v1.size(); ++i)
        if (v1[i]!=v2[i])
            return false;
    return true;
}
```

​		The way we use this **module** is to **import** it where we need it. 

```c++
import Vector;                // get Vector's interface
#include <cmath>          // get the standard-library math function interface including sqrt()

double sqrt_sum(Vector& v)
{
        double sum = 0;
        for (int i=0; i!=v.size(); ++i)
                sum+=std::sqrt(v[i]);                  // sum of square roots
        return sum;
}
```

​		使用老式的include只是为了表明我们可以混合新旧。这种混合对于将旧代码从使用#include逐步升级到使用import至关重要。



## 模块声明

​		定义模块时，不必将声明和定义分离到单独的文件中。如果分离能够提升代码的组织性可以这样做，但不是必要的。

​		模块的接口由编译器通过`export`导出说明符从实现细节中来指定。因此模块的接口可以由编译器隐式的生成，且从未被用户显式的命名。

​		使用模块时不必为了向用户隐藏实现细节而使代码复杂化，模块将只对导出的声明授予访问权。

## 导入

## 导出



​		尽管模块std包含了整个标准库，信息量是＜iostream＞头的10倍多，但还是实现了对编译时间的提升。

> ​	模块只导出接口，而头将直接或间接包含的所有内容传递给编译器。
>
> ​	因此在使用大型模块时，不必记住要包含哪些令人困惑的头文件。
>
> ​	`import std;`在c++20中还未实现。
