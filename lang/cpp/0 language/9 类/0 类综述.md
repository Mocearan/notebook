# 类综述

---

​		c++中通过一个**类（class）**类定义了一个类型，即定义一个数据结构以及与其相关的一组操作。

​		类的使用者不必关心它是如何实现的，只需要知道类对象可以执行什么操作。每个类实际上都定义了一个新的类型。类的作者定义了类对象可以执行的所有操作。

```c++
struct DateStruct
{
    int year {};
    int month {};
    int day {};
};

class DateClass
{
public:
    int m_year {};
    int m_month {};
    int m_day {};
};
```

​		In C++, classes and structs are essentially the same.除了继承和成员的默认访问权限。

​		Just like a struct declaration, a class declaration does not allocate any memory. It only defines what the class looks like.

> **Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions.**

​		Functions defined inside of a class are called **member functions** (or sometimes **methods**).

​		members (variables and functions) of a class are accessed using the member selection operator (.):

```c++
class DateClass
{
public:
    int m_year {};
    int m_month {};
    int m_day {};

    void print()
    {
        std::cout << m_year << '/' << m_month << '/' << m_day;
    }
};
```

​		All member function calls must be associated with an object of the class.

​		`class`es can have **member types** or **nested types** (including type aliases).

```c++
class Calculator
{
public:
    using number_type = int; // this is a nested type alias

    std::vector<number_type> m_resultHistory{};

    number_type add(number_type a, number_type b)
    {
        auto result{ a + b };

        m_resultHistory.push_back(result);

        return result;
    }
};
```

​		

## 类的设计

​		让类尽量简单、“短小精悍”，只负责单一的功能。

- 应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。
- 类内部定义一些嵌套类，美其名曰“高内聚”。但恰恰相反，这些内部类反而与上级类形成了强耦合关系
  - 是名字空间该做的事情，用类来实现就有点“越权”了
  - 正确的做法应该是，定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度



## 访问控制

### 独立访问控制

​		**Public members** are members of a struct or class that can be accessed directly by anyone, including from code that exists outside the struct or class.

​		**Private members** are members of a class that can only be accessed by other members of the class (not by the public).

- class : members are private by default
- struct : members are public by default

​		**Access specifiers** determine who has access to the members that follow the specifier. Each of the members “acquires” the access level of the previous access specifier (or, if none is provided, the default access specifier).

​		C++ provides 3 different access specifier keywords: public, private, and protected. Public and private are used to make the members that follow them public members or private members respectively.

​		In general, member variables are usually made private, and member functions are usually made public. 

​		The group of public members of a class are often referred to as a **public interface**.  the public interface defines how programs using the class will interact with the class. 

​		Some programmers prefer to list private members first, because the public members typically use the private ones, so it makes sense to define the private ones first. However, a good counterargument is that users of the class don’t care about the private members, so the public ones should come first.



### 关联访问控制

​		structs inherit from other classes publicly and classes inherit privately。



## 数据成员



## 成员函数

### 特殊成员函数

---

​		一些成员函数是特殊的，它们决定类作为一个类型的语义性质。某些条件下，即使用户不定义，编译器也会定义它们。

- 默认构造函数
- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符
- 移动赋值运算符
- 析构函数



### 成员函数说明符

### default



​		重要的构造函数和析构函数，应该用``= defaul``的形式，明确地告诉编译器（和代码阅读者）：“应该实现这个函数，但我不想自己写。”

​		这样编译器就得到了明确的指示，可以做更好的优化。

```c++
class DemoClass final 
{
public:
    DemoClass() = default;  // 明确告诉编译器，使用默认实现
   ~DemoClass() = default;  // 明确告诉编译器，使用默认实现
};
```



### delete

​		如果需要禁用某个类的特殊语义或者功能，则使用`=delete`来显式的明确禁用函数。

> 不限于构造 / 析构，可以用于任何函数（成员函数、自由函数）。

```c++
class DemoClass final 
{
public:
    DemoClass(const DemoClass&) = delete;              // 禁止拷贝构造
    DemoClass& operator=(const DemoClass&) = delete;  // 禁止拷贝赋值
};
```



### explicit

​		C++ 有隐式构造和隐式转型的规则，如果你的类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“explicit”将这些函数标记为“显式”。

```c++

class DemoClass final 
{
public:
    explicit DemoClass(const string_type& str)  // 显式单参构造函数
    { ... }

    explicit operator bool()                  // 显式转型为bool
    { ... }
};

```



## OOP：封装、继承、多态

### 封装

​		In object-oriented programming, **Encapsulation** (also called **information hiding**) is the process of keeping the details about how an object is implemented hidden away from users of the object. 

​		Instead, users of the object access the object through a public interface. In this way, users are able to use the object without having to understand how it is implemented.

- **Benefit: encapsulated classes are easier to use and reduce the complexity of your programs**
- **Benefit: encapsulated classes help protect your data and prevent misuse**
- **Benefit: encapsulated classes are easier to change**
- **Benefit: encapsulated classes are easier to debug**



### Access functions：getter & setter

​		Access functions typically come in two flavors: getters and setters. 

​		**Getters** (also sometimes called **accessors**) are functions that return the value of a private member variable. 

​		**Setters** (also sometimes called **mutators**) are functions that set the value of a private member variable.

```c++
class Date
{
public:
    int getMonth() const { return m_month; } // getter for month
    void setMonth(int month) { m_month = month; } // setter for month

    int getDay() const { return m_day; } // getter for day
    void setDay(int day) { m_day = day; } // setter for day

    int getYear() const { return m_year; } // getter for year
    void setYear(int year) { m_year = year; } // setter for year
private:
    int m_month;
    int m_day;
    int m_year;
};
```

​		Getters should provide “read-only” access to data. Therefore, the best practice is that they should return by value or const reference (not by non-const reference). 

​		As you create your classes, consider the following:

- If nobody outside your class needs to access a member, don’t provide access functions for that member.
- If someone outside your class needs to access a member, think about whether you can expose a behavior or action instead (e.g. rather than a setAlive(bool) setter, implement a kill() function instead).
- If you can’t, consider whether you can provide only a getter.
