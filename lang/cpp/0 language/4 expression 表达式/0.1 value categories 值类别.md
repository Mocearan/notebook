# 值类别

​		The **value category** of an expression indicates whether an expression resolves to a value, a function, or an object of some kind.

---

​		Prior to C++11, there were only two possible value categories: `lvalue` and `rvalue`.In C++11, three additional value categories (`glvalue`, `prvalue`, and `xvalue`) were added to support a new feature called `move semantics`.



## History

### CPL

​		编程语言 [CPL](https://en.wikipedia.org/wiki/CPL_(programming_language)) 率先为表达式引入了值类别：

> ​		所有 CPL 表达式都能以“右侧模式 (right-hand mode)”求值，但只有某些类型的表达式在“左侧模式 (left-hand mode)”有意义。
>
> ​		在右侧模式中求值时，表达式被当做一条进行值的计算（右侧值，或*右值*）的规则。在左侧模式中求值时，表达式的效果是给出一个地址（左侧值，或*左值*）。“左”和“右”代表“赋值之左”和“赋值之右”。



### C

​		C 编程语言遵循相似的分类法，但赋值的作用不再重要：

> ​		C 的表达式被分为“左值 (lvalue) 表达式”和其他（函数和非对象值）。
>
> ​		其中“左值 (lvalue)”的含义为标识一个对象的表达式，即“定位器值 (locator value)”[[4\]](https://zh.cppreference.com/w/cpp/language/value_category#cite_note-4)。

### C++98

​		2011 年前的 C++ 遵循 C 模型，但恢复了对非左值表达式的“右值 (rvalue)”称呼，令函数为左值，并添加了引用能绑定到左值但唯有 const 的引用能绑定到右值的规则。

​		几种非左值的 C 表达式在 C++ 中成为了左值表达式。

### C++11

​		随着移动语义引入到 C++11 之中，值类别被重新进行了定义，以区别表达式的两种独立的性质[[5\]](https://zh.cppreference.com/w/cpp/language/value_category#cite_note-5)：

- *拥有身份 (identity)*：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址；
- *可被移动*：[移动构造函数](https://zh.cppreference.com/w/cpp/language/move_constructor)、[移动赋值运算符](https://zh.cppreference.com/w/cpp/language/move_assignment)或实现了移动语义的其他函数重载能够绑定于这个表达式。

C++11 中：

- 拥有身份且不可被移动的表达式被称作*左值 (lvalue)*表达式；
- 拥有身份且可被移动的表达式被称作*亡值 (xvalue)*表达式；
- 不拥有身份且可被移动的表达式被称作*纯右值 (prvalue)*表达式；
- 不拥有身份且不可被移动的表达式无法使用[[6\]](https://zh.cppreference.com/w/cpp/language/value_category#cite_note-6)。

​		拥有身份的表达式被称作“泛左值 (glvalue) 表达式”。左值和亡值都是泛左值表达式。

​		可被移动的表达式被称作“右值 (rvalue) 表达式”。纯右值和亡值都是右值表达式。

### C++17

​		C++17 中，某些场合强制要求进行[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)，而这要求将纯右值表达式从被它们所初始化的临时对象中分离出来，这就是我们现有的系统。要注意，与 C++11 的方案相比，纯右值已不再是可被移动。



## 一般意义上的 c++ L & R value

​		基本对象拥有唯一的身份——位于内存中，拥有唯一的内存地址，可以通过地址与其他具有相同值的对象区别。表示这种对象的的表达式被称为左值（lvalue）。

> 对象是一块连续的存储区域，左值是指向对象的一条表达式。

​		但编程概念中，存在一种没有身份的对象，不存在一个安全的内存地址以供索引。对应表示的表达式称为右值（rvalue）。

### Lvalue

​		An **lvalue** (pronounced “ell-value”, short for “left value” or “locator value”, and sometimes written as “l-value”) is an expression that evaluates to a function or object that has an identity.

> An object or function has an identity if it has an identifier (such as a variable or named function) or an identifiable memory address (one that can be retrieved using operator&)

​		 Identifiable objects persist beyond the scope of the expression.

```c++
int x{};
std::cout << x << '\n'; // x is an lvalue expression
```

​		Since the introduction of constants into the language, lvalues come in two subtypes:

- a **modifiable lvalue** is an lvalue whose value can be modified. 
- A **non-modifiable lvalue** is an lvalue whose value can’t be modified (because the lvalue is const or constexpr).

```c++
int x{};
const double d{};
```



### rvalue

​		An **rvalue** (pronounced “arr-value”, short for “right value”, and sometimes written as `r-value`) is an expression that is not an l-value. 

> Commonly seen rvalues include literals (except string literals, which are lvalues) and the return value of functions or operators. 

​		Rvalues only exist within the scope of the expression in which they are used.

```c++
int return5()
{
    return 5;
}


int x{ 5 }; // 5 is an rvalue expression
const double d{ 1.2 }; // 1.2 is an rvalue expression

std::cout << x << '\n'; // x is a modifiable lvalue expression
std::cout << d << '\n'; // d is a non-modifiable lvalue expression

std::cout << return5(); // return5() is an rvalue expression (since the result is returned by value)
std::cout << x + 1 << '\n'; // x + 1 is a rvalue
std::cout << static_cast<int>(d) << '\n'; // the result of static casting d to an int is an rvalue
/*  
	these expressions produce values that must be used immediately (within the scope of the expression) or they are discarded.
*/
```

​		In C++11, rvalues are broken into two subtypes: prvalues and xvalues

​		 lvalues can implicitly convert to rvalues, so an lvalue can be used wherever an rvalue is required.

```c++
int x { 2 };
x = x + 1;
```



> lvalues expressions are those that evaluate to variables or other identifiable objects that persist beyond the end of the expression.
> rvalues expressions are those that evaluate to literals or the returned value of functions and operators that are discarded at the end of the expression.



## 值类别

​		c++将右值概念发展为`不能以低开销进行移动的值`。

​		考察对象的要素和性质，其中有身份和可移动是很关键的属性：

- 有身份，对象可以被寻址。即有名字索引，或指针索引，或引用索引。可以判断两个对象是否同一。
- 可移动，对象的值可以被迁出到其他某处，对象的状态变为合法但未指定，这与拷贝不同。

​		其中，有身份称为泛左值，可移动称为右值。经典

​		由此，这两个属性可以组合成：

- 经典左值，有身份不可移动，因为可能在移动后还使用它
- 经典右值，无身份可移动，不具名对象等。
- 将亡值，有身份可移动，意味着从经典左值向经典右值的转变（调用`std::move`）
- 纯右值，无身份不可移动，字面量等。

​		于是，编程中左值右值的判定重点逐渐向身份的转移。

### Primary Categories 基本类别

### Mixed Categories 混合类别

### Special Categories 特殊类别



## 临时变量

​		An **anonymous object** is essentially a value that has no name. 

---

​		Because they have no name：

- there’s no way to refer to them beyond the point where they are created.

-  Consequently, they have “expression scope”

  ​	meaning they are created, evaluated, and destroyed all within a single expression.

### Temporary materialization 临时对象实质化

​		任何完整类型 `T` 的纯右值，可转换成同类型 `T` 的亡值。

​		此转换以该纯右值初始化一个 T 类型的临时对象（以临时对象作为求值该纯右值的结果），并产生一个代表该临时对象的亡值。 

> ​		如果 `T` 是类类型或类类型的数组，那么它必须有可访问且未被弃置的析构函数.

```c++
struct S { int m; };
int k = S().m; // C++17 起成员访问期待泛左值；
               // S() 纯右值被转换成亡值
```

#### 临时对象实质化的条件

- 绑定引用到纯右值
- 在类纯右值上进行成员访问
- 数组到指针的转换 ， 或在数组纯右值上使用下标
- 以花括号初始化器列表初始化`std::initializer_list<T>`类型的对象
- 对纯右值应用`typeid`（不求值表达式的一部分）
- 对纯右值应用`sizeof`（不求值表达式的一部分）
- 纯右值作为弃值表达式

> ​		临时量实质化在从纯右值初始化同类型对象（通过直接初始化或复制初始化）时不发生：这类对象直接从初始化器初始化。
>
> ​		这确保了“受保证的复制消除”。

### 临时对象的创建

​		`c++17`起，对临时对象的创建进行了定义：

​			对纯右值的实质化，从而能将它作为泛左值使用，就创建了临时对象。

> ​		Temporary objects are created  when a prvalue is materialized so that it can be used as a glvalue.

#### 创建临时对象的条件

```c++
class Cents
{
private:
    int m_cents{};

public:
    Cents(int cents)
        : m_cents { cents }
    {}

    int getCents() const { return m_cents; }
};
```



- 绑定引用到纯右值

  ```c++
  void print(const Cents& cents)
  {
     std::cout << cents.getCents() << " cents\n";
  }
  print(Cents{ 6 }); // Note: Now we're passing an anonymous Cents value
  ```

- 以花括号初始化器列表初始化`std::initializer_list<T>`类型的对象

- 函数返回纯右值

  ```c++
  int add(int x, int y)
  {
      return x + y; // an anonymous object is created to hold and return the result of x + y
  }
  std::cout << add(5, 3) << '\n';
  ```

- 创建纯右值的类型转换（包括`T(a,b,c)`和`T{}`）

- lambda表达式

- 要求对初始化器进行类型转换的复制初始化

- 将引用绑定到不同但可以转换的类型，或绑定到位域。

- 当对类类型的纯右值进行成员访问

- 当对数组纯右值进行数组向指针转换或者下标运算

- 对`sizeof`和`typeif`的不求值操作数

- 当纯右值被用作弃值表达式

- 某些实现支持的，在函数调用表达式中传递或返回可平凡复制的类型的对象

  > 这对应的是在 CPU 寄存器中传递结构体的情况，即按位复制。
  >
  > [C++ 具名要求：可平凡复制 (TriviallyCopyable)](https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable)

  ```c++
  void printValue(int value)
  {
      std::cout << value;
  }
  printValue(5 + 3);
  ```

> ​		临时对象的实质化通常会尽可能地被推迟，以免创建不必要的临时对象：参见[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)

### 临时对象的生命周期