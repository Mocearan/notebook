#  constant expression

​		在编译时由编译器进行求值的表达式

---

- 不能包含任何编译时未知的值
- 不能具有其他副作用
- 可以由常量（字面量和符号常量）或枚举值等成分，用运算符或者其他生成常量值的`constexpr`函数把这些成分组合在一起

​		

​		有些场合中，常量表达式是语言规则必须的：

- 数组边界
- case标签
- 某些模板实参
- constexpr声明的常量

​		也有些场合，使用常量来进行编译期求值，提高程序的性能。



​		对于`if / ?: / constexpr`来讲，它们都可以用作处理常量表达式，也可以用作处理非常量表达式。即，如果他们的运算对象如果在编译时没有被求值，那么它们就不必是一个常量表达式。

> 运算符`&& / ||`也是如此。

​		全局变量等静态存储的对象的地址是一个常量，但是该地址值是由链接器赋值的，而非编译器。因此，编译器无法获知静态存储的对象的地址，限制了指针或引用类型的常量表达式的范围：

```c++
constexpr const char* p1 = "asdf";
constexpr const char* p2 = p1; // ok
constexpr const char* p3 = p1 + 2; // err, p1本身编译阶段还未被分配存储地址，但“asdf”已经被编译器分配了地址。
constexpr char c = p1[2]; // ok, p1指向的"asdf"在编译阶段已经
```

