# 类综述

---





​		In C++, classes and structs are essentially the same.除了继承和成员的默认访问权限。

​		Just like a struct declaration, a class declaration does not allocate any memory. It only defines what the class looks like.

> **Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions.**

​		Functions defined inside of a class are called **member functions** (or sometimes **methods**).

​		members (variables and functions) of a class are accessed using the member selection operator (.):

```c++
class DateClass
{
public:
    int m_year {};
    int m_month {};
    int m_day {};

    void print()
    {
        std::cout << m_year << '/' << m_month << '/' << m_day;
    }
};
```

​		All member function calls must be associated with an object of the class.

​		`class` can have **member types** or **nested types** (including type aliases).

```c++
class Calculator
{
public:
    using number_type = int; // this is a nested type alias

    std::vector<number_type> m_resultHistory{};

    number_type add(number_type a, number_type b)
    {
        auto result{ a + b };

        m_resultHistory.push_back(result);

        return result;
    }
};
```

​		

## 类的设计原则

​		让类尽量简单、“短小精悍”，只负责单一的功能。

- 应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。
- 类内部定义一些嵌套类，美其名曰“高内聚”。但恰恰相反，这些内部类反而与上级类形成了强耦合关系
  - 是名字空间该做的事情，用类来实现就有点“越权”了
  - 正确的做法应该是，定义一个新的名字空间，把内部类都“提”到外面，降低原来类的耦合度和复杂度



​		在类的设计过程中，始终要关注两个方面，一个类外部能够进行的行为，一个是类内部能够限制的行为。



## 数据成员

### 静态数据成员

​		静态数据成员和所有的静态变量一样，拥有静态存储期，即其内存不建构在类对象的结构内，而存储在静态存储区。

​		由此，有两个特性：

- 静态成员大小不计入类的大小
- 静态成员被所有类对象所共享

### 常量数据成员



## 成员函数

### 静态成员函数

​		静态成员函数用以访问类的静态成员。

​		static member functions are not attached to any particular object. 

> ​		一般成员函数通过`hiden this pointer`建构了对象与操作的关系，而静态成员并非成员的一部分，因此通过这种关系并不能访问静态成员。

### 常成员函数

​		在成员函数声明后尾随`const`成员函数说明符，声明其为常成员函数。常成员函数由编译器检查，不能修改数据成员，且不能调用非常成员函数。

​		由`const`修饰的常成员函数与同名非常成员函数构成重载：

> ​		This works because the const qualifier is considered part of the function’s signature

​		The const version of the function will be called on any const objects, and the non-const version will be called on any non-const objects

```c++
class Something
{
private:
    std::string m_value {};

public:
    Something(const std::string& value=""): m_value{ value } {}

    const std::string& getValue() const { return m_value; } // getValue() for const objects (returns const reference)
    std::string& getValue() { return m_value; } // getValue() for non-const objects (returns non-const reference)
};

int main()
{
	Something something;
	something.getValue() = "Hi"; // calls non-const getValue();

	const Something something2;
	something2.getValue(); // calls const getValue();

	return 0;
}
```

> ​		Overloading a function with a const and non-const version is typically done when the return value needs to differ in constness. 

- Const member functions can also be called by non-const objects

  ​	but returns a const reference, to ensure we can’t modify the const object’s data.

- Non-const member function will only work with non-const objects,

  ​	but is more flexible in that we can use it to both read and write data member.

### 一般构造函数

​		构造函数，是类的一种特殊的非静态成员函数，用于初始化该类类型的对象。构造函数会在类对象被创建后由系统自动调用，用以初始化成员变量。

#### 转换构造函数

​		Constructors eligible to be used for implicit conversions are called **converting constructors** (or conversion constructors).

​		By default, C++ will treat any constructor as an implicit conversion operator. 

- 是否接受单个实参
- 是否发生隐式类型转换

```c++
class Fraction
{
private:
	int m_numerator;
	int m_denominator;

public:
	// Default constructor
	Fraction(int numerator = 0, int denominator = 1)
		 : m_numerator(numerator), m_denominator(denominator)
	{
		assert(denominator != 0);
	}

	// Copy constructor
	Fraction(const Fraction& copy)
		: m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)
	{
		// no need to check for a denominator of 0 here since copy must already be a valid Fraction
		std::cout << "Copy constructor called\n"; // just to prove it works
	}

	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
	int getNumerator() { return m_numerator; }
	void setNumerator(int numerator) { m_numerator = numerator; }
};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}

void printFraction(const Fraction& f)
{
	std::cout << f;
}

int main()
{
	printFraction(6);

	return 0;
}
```

> 虽然`pirntFraction`期望参数为`Fraction`，但给到类型为`int`。
>
> Because Fraction has a constructor willing to take a single integer, the compiler will implicitly convert the literal 6 into a Fraction object. 

### 特殊成员函数

​		一些成员函数是特殊的，它们决定类作为一个类型的语义性质。某些条件下，即使用户不定义，编译器也会定义它们。

- 默认构造函数
- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符
- 移动赋值运算符
- 析构函数



### 成员函数说明符

#### =default

​		重要的构造函数和析构函数，应该用``= defaul``的形式，明确地告诉编译器（和代码阅读者）：“应该实现这个函数，但我不想自己写。”

​		这样编译器就得到了明确的指示，可以做更好的优化。

```c++
class DemoClass final 
{
public:
    DemoClass() = default;  // 明确告诉编译器，使用默认实现
   ~DemoClass() = default;  // 明确告诉编译器，使用默认实现
};
```



#### =delete

​		如果需要禁用某个类的特殊语义或者功能，则使用`=delete`来显式的明确禁用函数。

> 不限于构造 / 析构，可以用于任何函数（成员函数、自由函数）。

```c++
class DemoClass final 
{
public:
    DemoClass(const DemoClass&) = delete;              // 禁止拷贝构造
    DemoClass& operator=(const DemoClass&) = delete;  // 禁止拷贝赋值
};
```

​		将构造函数私有能防止类外的访问，但不能防止类内部的访问。

#### explicit

​		C++ 有隐式构造和隐式转型的规则，如果你的类里有接受单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“explicit”将这些函数标记为“显式”。

```c++

#include <string>
#include <iostream>

class MyString
{
private:
	std::string m_string;
public:
	// explicit keyword makes this constructor ineligible for implicit conversions
	explicit MyString(int x) // allocate string of size x
	{
		m_string.resize(x);
	}

	MyString(const char* string) // allocate string to hold string value
	{
		m_string = string;
	}
    
    explicit operator bool()                  // 显式转型为bool
    { ... }

	friend std::ostream& operator<<(std::ostream& out, const MyString& s);

};

std::ostream& operator<<(std::ostream& out, const MyString& s)
{
	out << s.m_string;
	return out;
}

void printString(const MyString& s)
{
	std::cout << s;
}

int main()
{
	MyString mine = 'x'; // compile error, since MyString(int) is now explicit and nothing will match this
	std::cout << mine;

	printString('x'); // compile error, since MyString(int) can't be used for implicit conversions

	return 0;
}

```

​		note that making a constructor explicit only prevents *implicit* conversions. Explicit conversions (via casting) are still allowed:

```c++
std::cout << static_cast<MyString>(5); // Allowed: explicit cast of 5 to MyString(int)	
```



#### const 

#### override

#### virtual

#### ``=0``



### 成员函数的类外实现

​		Using an already-written class only requires understanding its public interface (the public member functions), not how the class works underneath the hood. The member function implementation details just get in the way.

​		C++ provides a way to separate the “declaration” portion of the class from the “implementation” portion. This is done by defining the class member functions outside of the class definition：prefix the class name to the function using the scope resolution operator (::) (same as for a namespace).

```c++
class Date
{
private:
    int m_year;
    int m_month;
    int m_day;

public:
    Date(int year, int month, int day);

    void SetDate(int year, int month, int day);

    int getYear() { return m_year; }
    int getMonth() { return m_month; }
    int getDay()  { return m_day; }
};

// Date constructor
Date::Date(int year, int month, int day)
{
    SetDate(year, month, day);
}

// Date member function
void Date::SetDate(int year, int month, int day)
{
    m_month = month;
    m_day = day;
    m_year = year;
}
```

> ​		access functions are often only one line, they are typically left in the class definition, even though they could be moved outside.
>
> ​		短小的成员函数在类内实现，使其隐含默认的可以成为内联函数。

#### 类的分离式编程

​		类的定义往往又单独抽离，放在`header file`中，形成完整的分离式编程结构。

> `header file`的文件名一般与类名相同，存放实现的文件又与该头文件相同。

```c++
// date.h
#ifndef DATE_H
#define DATE_H

class Date
{
private:
    int m_year;
    int m_month;
    int m_day;

public:
    Date(int year, int month, int day);

    void SetDate(int year, int month, int day);

    int getYear() { return m_year; }
    int getMonth() { return m_month; }
    int getDay()  { return m_day; }
};

#endif

// Date.cpp
#include "Date.h"

// Date constructor
Date::Date(int year, int month, int day)
{
    SetDate(year, month, day);
}

// Date member function
void Date::SetDate(int year, int month, int day)
{
    m_month = month;
    m_day = day;
    m_year = year;
}
```

> ​		为该头文件加上防卫式声明，那么在任意一个翻译单元中，类及相关的声明都不会违反`ODR`.
>
> ​		对于成员函数：It depends.
>
> ​		 Member functions defined inside the class definition are considered implicitly inline. Inline functions are exempt from the one definition per program part of the one-definition rule. This means there is no problem defining trivial member functions (such as access functions) inside the class definition itself.
>
> ​		Member functions defined outside the class definition are treated like normal functions, and are subject to the one definition per program part of the one-definition rule. Therefore, those functions should be defined in a code file, not inside the header. One exception is for template functions, which are also implicitly inline.

#### header / cpp file & inside / outside class

​		将所欲的成员函数定义都写在头文件的类内，首先造成类定义的复杂；其次当修改头文件中任何一种所有引用该头文件的翻译单元都会在编译期重新编译。

> ​		而如果存在头文件的实现cpp 文件，那么只有实现cpp会在编译期作为独立的翻译单元重新编译，链接期会将这个独立的翻译单元链接到其他引用了该头文件的翻译单元。
>
> ​		众所周知，cpp的编译期很长。

​		Therefore, we recommend the following:

- For classes used in only one file that aren’t generally reusable, define them directly in the single .cpp file they’re used in.
- For classes used in multiple files, or intended for general reuse, define them in a .h file that has the same name as the class.
- Trivial member functions (trivial constructors or destructors, access functions, etc…) can be defined inside the class.
- Non-trivial member functions should be defined in a .cpp file that has the same name as the class.



​		Default parameters for member functions should be declared in the class definition (in the header file), where they can be seen by whomever #includes the header.



## 关联数据和操作的秘密：hiden “this” pointer

​		c语言通过一个显式传递的数据结构指针常量，将对象和操作相关联。

```c
struct DateStruct
{
    int year {};
    int month {};
    int day {};
};

char* getDate(DateStruct* const this)
{
    // this->year to string
    // this->month to string
    // this->day to string
    // return ...;
}

DateStruct date;
getDate(&date);
```

​		C++将由编译器自动的将对象的指针常量，隐式的作为第一个参数传递给每个非静态成员函数。由此实现数据结构和操作的关联。

```c++
class DateClass
{
public:
    int m_year {};
    int m_month {};
    int m_day {};
    
private:
    // std::string getDate(DateClass * const this)
    std::string getDate()
    {
        return std::to_string(m_year) + std::to_string(m_date) + std::to_string(m_day);
		//return std::to_string(this->m_year) + std::to_string(this->m_date) + std::to_string(this->m_day);
    }
};

DateClass date;
date.getDate();
```

​		`this`指针不占用类对象的结构内存，而由编译器将指针作为参数，传递进调用的函数，在每个调用的成员函数栈帧中，this指针占用其局部存储。

​		通常无须显式的使用`this`指针，但当某些

情况下，成员函数的参数名与数据成员名相同时，为了消除二义性，对成员使用`this`指针

```c++
class Something
{
private:
    int data;

public:
    Something(int data)
    {
        this->data = data; // this->data is the member, data is the local parameter
    }
};
```

> ​		成员函数是由类的设计者编制的，这种同名冲突应该在代码编写中避免，一般赋予成员变量特殊的标识。

