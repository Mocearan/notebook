

# 类的关系

​		在单个类之外，类之间的多种关系造成了程序的复杂性，也提供了多种构建程序的可能性。

---



## Nested  内嵌

​		C++ will let you define other types within a class, such as enumerations， typedefs, type aliases, and even other classes!

​		类作为独立的作用域，高内聚的做法是将与类紧耦合的类型定义在类内，在语义和结构上都实现封装的思想。

​		Like any normal member of a class, nested classes have the same access to members of the enclosing class that the enclosing class does. However, the nested class does not have any special access to the “this” pointer of the enclosing class.

​		One other limitation of nested types -- they can’t be forward declared. However, this is rarely a problem in practice since the entire class definition (including the nested type) can generally be #included where needed.

​		Defining nested classes isn’t very common, but the C++ standard library does do so in some cases, such as with iterator classes.

### Nested enum

​		enumerations are probably the most common type that is nested inside a class。

```c++
enum class FruitType
{
	apple,
	banana,
	cherry
};

class Fruit
{
private:
	FruitType m_type {};
	int m_percentageEaten { 0 };

public:
	Fruit(FruitType type) : m_type { type }
	{ }

	FruitType getType() const { return m_type; }
	int getPercentageEaten() const { return m_percentageEaten; }
};

Fruit apple { FruitType::apple };

if (apple.getType() == FruitType::apple)
    std::cout << "I am an apple";
else
    std::cout << "I am not an apple";
```

​		To do this, you simply define the type inside the class, under the appropriate access specifier.

```c++

class Fruit
{
public:
	// Note: we've moved FruitType inside the class, under the public access specifier
	// We've also changed it from an enum class to an enum
	enum FruitType
	{
		apple,
		banana,
		cherry
	};

private:
	FruitType m_type {};
	int m_percentageEaten { 0 };

public:
	Fruit(FruitType type) :
		m_type { type }
	{
	}

	FruitType getType() const { return m_type; }
	int getPercentageEaten() const { return m_percentageEaten; }
};

int main()
{
	// Note: we access the FruitType via Fruit now
	Fruit apple { Fruit::apple };

	if (apple.getType() == Fruit::apple)
		std::cout << "I am an apple";
	else
		std::cout << "I am not an apple";

	return 0;
}
```

> ​		Note that because enum classes also act like namespaces, if we’d nested FruitType inside Fruit as an enum class instead of an enum, we’d access the enumeration via a Fruit::FruitType:: scope qualifier. This double-scoping is unnecessary, so we’ve used a normal enum.
>
> ​		enum具有内联性。

### Nested type

