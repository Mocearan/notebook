







## 委托构造

​		delegating constructor.

​		多个不同形式的构造函数之间不能复用成员初始化的代码。传统做法是抽取init() 函数里，构造函数去调用。

​		效率和可读性较差，`init()` 不是真正的构造函数，实际上是未定式和值的分离，不是真正的初始化。

​		构造函数可以直接调用另一个构造函数，把构造工作“委托”出去，简单高效。

```c++
class DemoDelegating final
{
private:
    int a;                              // 成员变量
public:
    DemoDelegating(int x) : a(x)        // 基本的构造函数
    {}  

    DemoDelegating() :                 // 无参数的构造函数
        DemoDelegating(0)               // 给出默认值，委托给第一个构造函数
    {}  

    DemoDelegating(const string& s) : // 字符串参数构造函数
        DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数
    {}  
};
```



