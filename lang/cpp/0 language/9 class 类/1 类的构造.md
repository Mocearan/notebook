# 类的构造

---

​		类的构造，是约束类对象的初始化形式。

> Always initialize all member variables in your objects.

## 类的构造方式

​		类的创建经由构造函数和成员初始化器列表来实现。

​		构造函数，是类的一种特殊的非静态[成员函数](https://zh.cppreference.com/w/cpp/language/member_functions)，用于初始化该类类型的对象。

​		成员初始化器列表，构造函数定义中指定各个直接基类、虚基类和非静态数据成员的初始化器。 

> 不同于 [std::initializer_list](https://zh.cppreference.com/w/cpp/utility/initializer_list)。

​		

### 构造函数

​		构造函数是一类特殊的非静态成员函数，会在类对象被创建后由系统自动调用，用以初始化成员变量。

​		在类对象创建而未调用构造函数时，类对象的状态未定，称为未定式。构造函数即用来明确类对象开始工作时的状态。

- 构造函数名与类名相同
- 构造函数没有返回值



#### 构造的两阶段

​		在开始执行组成构造函数体的复合语句之前，所有直接基类、虚基类和非静态数据成员的初始化均已结束。然后构造函数体调用。

```c++
class Something
{
private:
    int m_value1 {};
    double m_value2 {};
    char m_value3 {};

public:
    Something()
    {
        // These are all assignments, not initializations
        m_value1 = 1;
        m_value2 = 2.2;
        m_value3 = 'c';
    }
};
```

​		这个过程等同于：

```c++
int m_value1 {};
double m_value2 {};
char m_value3 {};

m_value1 = 1;
m_value2 = 2.2;
m_value3 = 'c';
```

​		将第一个阶段称为初始化阶段，第二个阶段称为赋值阶段。

​		这种机制虽然存在，但是效率并不高，`c++`推荐使用成员初始化器列表将初始值在初始化阶段设定。

​		另外，如常成员、引用类型成员等需要具有初始值的类型，可以在初始化阶段以构造初始化的任意形式进行初始化。

```c++
class Base
{
    public:
    const int n;
};   
 
int main()
{
    Base a{3};
    std::cout << a.n << '\n';
}
```

​		对于数组成员，在`c++11`之前，在初始化阶段只能进行零初始化，之后可以进行列表初始化。

```c++
class Something
{
private:
    const int m_array[5];

public:
    //Something(): m_array {} // zero initialize the member array
    Something(): m_array { 1, 2, 3, 4, 5 } // use uniform initialization to initialize our member array
    {
    }

};
```



#### 两阶段构造

​		一般只在构造函数中完成各个对象的创建，即保证各对象定义完整，类的内存模型的成功创建。

​		不做任何功能性的事件，以防止有成员对象创建失败而导致的功能异常。或因为功能性事件失败，但构造函数不能返回相应错误（可以通过抛出异常来中断，但往往禁用异常）。

​		https://www.cnblogs.com/AKUN-FYK/p/11062935.html

[为什么需要把初始化和反初始化放到构造和析构之外？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26820323/answer/34149932)

> ​		如果希望不调用初始化函数来完成启动功能，可以使用工程类或工厂方法来创建对象，调用完初始化功能后再返回对象。



### 构造初始化

​		构造初始化，是控制权在类自身的聚合初始化形式。

#### 类外初始化

​		考察一般的结构化类型，聚合初始化是其很重要的一个特性。而所有成员都声明为公共访问属性时，意味着类可以进行一般性的聚合初始化。

​		这种暴露成员，由类外控制类成员的初始化形式，是由C继承而来对结构化数据的一般性初始化方式。

```c++
class Foo {
    public:
    	int x{};
    	int y{};
}

int main()
{
 	Foo foo{6, 7}; // 类外列表初始化，list-initialization
}
```



#### 成员初始化器列表

​		当按照`c++`对类的封装性的要求，由类控制类的行为属性，通过将成员私有暴露接口的方式来实现这一目的，这时类外初始化不再可用。

​		但通过提供初始值列表来初始化一个结构化的数据类型是自然而符合直觉的行为，在保证封装性的前提下，实现这一目的的方式即，通过构造函数的构造接口，提供一种使用外部传入的参数来指定各个直接基类、虚基类和非静态数据成员的初始化器。

```c++
class Something
{
private:
    int m_value1 {};
    double m_value2 {};
    char m_value3 {};

public:
    Something() : m_value1{ 1 }, m_value2{ 2.2 }, m_value3{ 'c' } // Initialize our member variables
    {
    // No need for assignment here
    }

    void print()
    {
         std::cout << "Something(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
    }
};
```

​		成员初始化器列表往往会写的比较长，需要进行一定的格式优化。

```c++
// If the initializer list fits on the same line as the function name, then it’s fine to put everything on one line:
Something() : m_value1{ 1 }, m_value2{ 2.2 }, m_value3{ 'c' } // everything on one line
{}

// If the initializer list doesn’t fit on the same line as the function name, then it should go indented on the next line.
Something(int value1, double value2, char value3='c') // this line already has a lot of stuff on it
    : m_value1{ value1 }, m_value2{ value2 }, m_value3{ value3 } // so we can put everything indented on next line
{}

// If all of the initializers don’t fit on a single line (or the initializers are non-trivial), then you can space them out, one per line:
Something(int value1, double value2, char value3='c', float value4=34.6f) // this line already has a lot of stuff on it
    : m_value1{ value1 } // one per line
, m_value2{ value2 }
, m_value3{ value3 }
, m_value4{ value4 }
{
}
```

​		variables in the initializer list are not initialized in the order that they are specified in the initializer list. Instead, they are initialized in the order in which they are declared in the class.

1. Don’t initialize member variables in such a way that they are dependent upon other member variables being initialized first (in other words, ensure your member variables will properly initialize even if the initialization ordering is different).
2. Initialize variables in the initializer list in the same order in which they are declared in your class. This isn’t strictly required so long as the prior recommendation has been followed, but your compiler may give you a warning if you don’t do so and you have all warnings turned on.

#### 类内初始化

​		可以在类里声明变量的同时给它赋值，实现初始化。

- 不同构造函数不同初始化的成员不能类内初始化
- 类内初始化也不能依赖构造函数的参数。

​		类内初始化一方面是对成员初始化器列表的简化，一方面是相对于类外初始化的类对自身属性的控制。

```c++

class DemoInit final                  // 有很多成员变量的类
{
private:
    int                 a = 0;        // 整数成员，赋值初始化
    string              s = "hello";  // 字符串成员，赋值初始化
    vector<int>         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表
public:
    DemoInit() = default;             // 默认构造函数
   ~DemoInit() = default;             // 默认析构函数
public:
    DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值
};

```





### 成员函数缩减 constructors reduce

​		构造函数是`c++`中最常用函数重载的场景，使用默认实参来缩减重载数量的特性在构造函数场景中依然适用。

> 但工程上为了避免二义性，往往建议使用明确的重载形式来标定一种可能的调用形式。即少用默认实参，多用函数重载。

```c++
class Fraction
{
private:
    int m_numerator {};
    int m_denominator {};

public:
    // Default constructor
    Fraction(int numerator=0, int denominator=1)
    {
        assert(denominator != 0);

        m_numerator = numerator;
        m_denominator = denominator;
    }
};

Fraction zero; // will call Fraction(0, 1)
Fraction zero{}; // will call Fraction(0, 1)
Fraction six{ 6 }; // will call Fraction(6, 1)
Fraction fiveThirds{ 5, 3 }; // will call Fraction(5, 3)
```

​		因为`c++`没有指定参数赋值的特性，因此，实参只能按照调用惯例的规定进行参数的顺序赋值。所以，带默认实参的形参需要同一放置在形参列表最右侧，而且，实参列表的顺序赋值不能跳过某个形参。

```c++
class Something
{
public:
	// Default constructor
	Something(int n = 0, double d = 1.2) // allows us to construct a Something(int, double), Something(int), or Something()
	{
	}

	Something(double d)
	{
	}
};

int main()
{
	Something s1 { 1, 2.4 }; // calls Something(int, double)
	Something s2 { 1 }; // calls Something(int, double)
	Something s3 {}; // calls Something(int, double)

    // if non Something(double d), this call will not compile
	Something s4 { 2.4 }; // calls Something(double)

	return 0;
}
```





​		