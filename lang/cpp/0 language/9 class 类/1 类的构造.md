# 类的构造

---

​		类的构造，是约束类对象的初始化形式。

> Always initialize all member variables in your objects.

## 类的构造方式

​		类的创建经由构造函数和成员初始化器列表来实现。

​		构造函数，是类的一种特殊的非静态[成员函数](https://zh.cppreference.com/w/cpp/language/member_functions)，用于初始化该类类型的对象。

​		成员初始化器列表，构造函数定义中指定各个直接基类、虚基类和非静态数据成员的初始化器。 

> 不同于 [std::initializer_list](https://zh.cppreference.com/w/cpp/utility/initializer_list)。

​		

### 构造函数

​		构造函数是一类特殊的非静态成员函数，会在类对象被创建后由系统自动调用，用以初始化成员变量。

​		在类对象创建而未调用构造函数时，类对象的状态未定，称为未定式。构造函数即用来明确类对象开始工作时的状态。

- 构造函数名与类名相同
- 构造函数没有返回值

#### 两阶段构造

​		一般只在构造函数中完成各个对象的创建，即保证各对象定义完整，类的内存模型的成功创建。

​		不做任何功能性的事件，以防止有成员对象创建失败而导致的功能异常。

​		https://www.cnblogs.com/AKUN-FYK/p/11062935.html

> ​		如果希望不调用初始化函数来完成启动功能，可以使用工程类或工厂方法来创建对象，调用完初始化功能后再返回对象。



### 成员初始化器列表

​		成员初始化器列表在概念上，是控制权在类自身的聚合初始化形式。

#### 类外初始化

​		考察一般的结构化类型，聚合初始化是其很重要的一个特性。而所有成员都声明为公共访问属性时，意味着类可以进行一般性的聚合初始化。

​		这种暴露成员，由类外控制类成员的初始化形式，是由C继承而来对结构化数据的一般性初始化方式。

```c++
class Foo {
    public:
    	int x{};
    	int y{};
}

int main()
{
 	Foo foo{6, 7}; // 类外列表初始化，list-initialization
}
```



#### 初始化器列表

​		当按照`c++`对类的封装性的要求，由类控制类的行为属性，通过将成员私有暴露接口的方式来实现这一目的，这时类外初始化不再可用。

​		但通过提供初始值列表来初始化一个结构化的数据类型是自然而符合直觉的行为，在保证封装性的前提下，实现这一目的的方式即，通过构造函数的构造接口，提供一种使用外部传入的参数来指定各个直接基类、虚基类和非静态数据成员的初始化器。

```c++
class X {
    int a, b, i, j;
public:
    const int& r;
    
    X(int i)
      : r(a) // 初始化 X::r 以指代 X::a
      , b{i} // 初始化 X::b 为形参 i 的值
      , i(i) // 初始化 X::i 为形参 i 的值
      , j(this->i) // 初始化 X::j 为 X::i 的值
    {}
};
```



#### 类内初始化





### 成员函数缩减 constructors reduce

​		构造函数是`c++`中最常用函数重载的场景，使用默认实参来缩减重载数量的特性在构造函数场景中依然适用。

> 但工程上为了避免二义性，往往建议使用明确的重载形式来标定一种可能的调用形式。即少用默认实参，多用函数重载。

```c++
class Fraction
{
private:
    int m_numerator {};
    int m_denominator {};

public:
    // Default constructor
    Fraction(int numerator=0, int denominator=1)
    {
        assert(denominator != 0);

        m_numerator = numerator;
        m_denominator = denominator;
    }
};

Fraction zero; // will call Fraction(0, 1)
Fraction zero{}; // will call Fraction(0, 1)
Fraction six{ 6 }; // will call Fraction(6, 1)
Fraction fiveThirds{ 5, 3 }; // will call Fraction(5, 3)
```

​		因为`c++`没有指定参数赋值的特性，因此，实参只能按照调用惯例的规定进行参数的顺序赋值。所以，带默认实参的形参需要同一放置在形参列表最右侧，而且，实参列表的顺序赋值不能跳过某个形参。

```c++
class Something
{
public:
	// Default constructor
	Something(int n = 0, double d = 1.2) // allows us to construct a Something(int, double), Something(int), or Something()
	{
	}

	Something(double d)
	{
	}
};

int main()
{
	Something s1 { 1, 2.4 }; // calls Something(int, double)
	Something s2 { 1 }; // calls Something(int, double)
	Something s3 {}; // calls Something(int, double)

    // if non Something(double d), this call will not compile
	Something s4 { 2.4 }; // calls Something(double)

	return 0;
}
```





#### 类内初始化

​		可以在类里声明变量的同时给它赋值，实现初始化。

- 不同构造函数不同初始化的成员不能类内初始化
- 类内初始化也不能依赖构造函数的参数。

​		类内初始化一方面是对成员初始化器列表的简化，一方面是相对于类外初始化的类对自身属性的控制。

```c++

class DemoInit final                  // 有很多成员变量的类
{
private:
    int                 a = 0;        // 整数成员，赋值初始化
    string              s = "hello";  // 字符串成员，赋值初始化
    vector<int>         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表
public:
    DemoInit() = default;             // 默认构造函数
   ~DemoInit() = default;             // 默认析构函数
public:
    DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值
};

```





​		