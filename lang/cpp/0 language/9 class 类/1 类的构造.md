# 类的构造

---

## 类的构造方式

​		类的创建经由构造函数和成员初始化器列表来实现。

​		构造函数，是类的一种特殊的非静态[成员函数](https://zh.cppreference.com/w/cpp/language/member_functions)，用于初始化该类类型的对象。

​		成员初始化器列表，构造函数定义中指定各个直接基类、虚基类和非静态数据成员的初始化器。 

> 不同于 [std::initializer_list](https://zh.cppreference.com/w/cpp/utility/initializer_list)。



### 构造函数

​		构造函数是一类特殊的非静态成员函数，会在类对象被创建后由系统自动调用，用以初始化成员变量。

​		在类对象创建而未调用构造函数时，类对象的状态未定，称为未定式。构造函数即用来明确类对象开始工作时的状态。

- 构造函数名与类名相同
- 构造函数没有返回值

#### 两阶段构造

​		一般只在构造函数中完成各个对象的创建，即保证各对象定义完整，类的内存模型的成功创建。

​		不做任何功能性的事件，以防止有成员对象创建失败而导致的功能异常。

​		https://www.cnblogs.com/AKUN-FYK/p/11062935.html

> ​		如果希望不调用初始化函数来完成启动功能，可以使用工程类或工厂方法来创建对象，调用完初始化功能后再返回对象。



### 成员初始化器列表

​		成员初始化器列表在概念上，是控制权在类自身的聚合初始化形式。

#### 类外初始化

​		考察一般的结构化类型，聚合初始化是其很重要的一个特性。而所有成员都声明为公共访问属性时，意味着类可以进行一般性的聚合初始化。

​		这种暴露成员，由类外控制类成员的初始化形式，是由C继承而来对结构化数据的一般性初始化方式。

```c++
class Foo {
    public:
    	int x{};
    	int y{};
}

int main()
{
 	Foo foo{6, 7}; // 类外列表初始化，list-initialization
}
```



#### 初始化器列表

​		当按照`c++`对类的封装性的要求，由类控制类的行为属性，通过将成员私有暴露接口的方式来实现这一目的，这时类外初始化不再可用。

​		但通过提供初始值列表来初始化一个结构化的数据类型是自然而符合直觉的行为，在保证封装性的前提下，实现这一目的的方式即，通过构造函数的构造接口，提供一种使用外部传入的参数来指定各个直接基类、虚基类和非静态数据成员的初始化器。

```c++
{
    int a, b, i, j;
public:
    const int& r;
    X(int i)
      : r(a) // 初始化 X::r 以指代 X::a
      , b{i} // 初始化 X::b 为形参 i 的值
      , i(i) // 初始化 X::i 为形参 i 的值
      , j(this->i) // 初始化 X::j 为 X::i 的值
    {}
};
```



#### 类内初始化

​		可以在类里声明变量的同时给它赋值，实现初始化。

- 不同构造函数不同初始化的成员不能类内初始化
- 类内初始化也不能依赖构造函数的参数。

​		类内初始化一方面是对成员初始化器列表的简化，一方面是相对于类外初始化的类对自身属性的控制。

```c++

class DemoInit final                  // 有很多成员变量的类
{
private:
    int                 a = 0;        // 整数成员，赋值初始化
    string              s = "hello";  // 字符串成员，赋值初始化
    vector<int>         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表
public:
    DemoInit() = default;             // 默认构造函数
   ~DemoInit() = default;             // 默认析构函数
public:
    DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值
};

```



##  默认构造





## 委托构造

​		delegating constructor.

​		多个不同形式的构造函数之间不能复用成员初始化的代码。传统做法是抽取init() 函数里，构造函数去调用。

​		效率和可读性较差，init() 不是真正的构造函数，实际上是未定式和值的分离，不是真正的初始化。

​		构造函数可以直接调用另一个构造函数，把构造工作“委托”出去，简单高效。

```c++

class DemoDelegating final
{
private:
    int a;                              // 成员变量
public:
    DemoDelegating(int x) : a(x)        // 基本的构造函数
    {}  

    DemoDelegating() :                 // 无参数的构造函数
        DemoDelegating(0)               // 给出默认值，委托给第一个构造函数
    {}  

    DemoDelegating(const string& s) : // 字符串参数构造函数
        DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数
    {}  
};
```







## 拷贝构造

​		使得类具有在创建时的拷贝语义，即可以通过拷贝同类另一个对象值的方式来创建一个新对象。

```c++
Name ( const Name & );
```

​		可以显式的弃置拷贝构造，来去除类通过拷贝创建的语义，使本类及其聚类不能进行拷贝初始化。

```c++
Name ( const Name & ) = delete;		// C++11
```

​		如不显式的给出定义，则默认的对所有成员进行拷贝构造来完成新对象的创建。如果有成员去除了拷贝创建语义，则因成员不能完全创建，造成本类不能完成拷贝创建。

```c++
Name ( const Name & ) = default;	// c++11
```





​		