# 封装

​		In object-oriented programming,**Encapsulation** (also called **information hiding**) is the process of keeping the details about how an object is implemented hidden away from users of the object. 

---

​		Users of the object access the object through a public interface. In this way, users are able to use the object without having to understand how it is implemented.



## Benefit

- encapsulated classes are easier to use and reduce the complexity of your programs
- encapsulated classes help protect your data and prevent misuse
- encapsulated classes are easier to change
- encapsulated classes are easier to debug

## carrier of encapsulated: class

​		c++中通过一个**类（class）**类定义了一个类型，即定义一个数据结构以及与其相关的一组操作，并将这些操作与数据结构做强绑定。这就是一个对象的抽象。

```c
struct DateStruct
{
    int year {};
    int month {};
    int day {};
};

char* getDate(DateStruct* this)
{
    // this->year to string
    // this->month to string
    // this->day to string
    // return ...;
}
```

```c++
class DateClass
{
public:
    int m_year {};
    int m_month {};
    int m_day {};
    
private:
    std::string getDate()
    {
        return std::to_string(m_year) + std::to_string(m_date) + std::to_string(m_day);
	}
};
```

> ​		类的使用者不必关心它是如何实现的，只需要知道类对象可以执行什么操作。
>
> ​		每个类实际上都定义了一个新的类型。类的作者定义了类对象可以执行的所有操作。

## Way of encapsulate： Access Control

### 独立访问控制

​		**Public members** are members of a struct or class that can be accessed directly by anyone, including from code that exists outside the struct or class.

​		**Private members** are members of a class that can only be accessed by other members of the class (not by the public).

- class : members are private by default
- struct : members are public by default

​		**Access specifiers** determine who has access to the members that follow the specifier. Each of the members “acquires” the access level of the previous access specifier (or, if none is provided, the default access specifier).

​		C++ provides 3 different access specifier keywords: public, private, and protected. Public and private are used to make the members that follow them public members or private members respectively.

​		In general, member variables are usually made private, and member functions are usually made public. 

​		The group of public members of a class are often referred to as a **public interface**.  the public interface defines how programs using the class will interact with the class. 

​		Some programmers prefer to list private members first, because the public members typically use the private ones, so it makes sense to define the private ones first. However, a good counterargument is that users of the class don’t care about the private members, so the public ones should come first.



### 关联访问控制

​		structs inherit from other classes publicly and classes inherit privately。



### Access functions：getter & setter

​		Access functions typically come in two flavors: getters and setters. 

​		**Getters** (also sometimes called **accessors**) are functions that return the value of a private member variable. 

​		**Setters** (also sometimes called **mutators**) are functions that set the value of a private member variable.

```c++
class Date
{
public:
    int getMonth() const { return m_month; } // getter for month
    void setMonth(int month) { m_month = month; } // setter for month

    int getDay() const { return m_day; } // getter for day
    void setDay(int day) { m_day = day; } // setter for day

    int getYear() const { return m_year; } // getter for year
    void setYear(int year) { m_year = year; } // setter for year
private:
    int m_month;
    int m_day;
    int m_year;
};
```

​		Getters should provide “read-only” access to data. Therefore, the best practice is that they should return by value or const reference (not by non-const reference). 

​		As you create your classes, consider the following:

- If nobody outside your class needs to access a member, don’t provide access functions for that member.
- If someone outside your class needs to access a member, think about whether you can expose a behavior or action instead (e.g. rather than a setAlive(bool) setter, implement a kill() function instead).
- If you can’t, consider whether you can provide only a getter.



## chain member functions 链式调用

​		面向对象中有一种链式调用风格，通过成员函数返回对象的引用，来实现一个对象一连串的调用。

```c++
class Calc
{
private:
    int m_value{0};

public:

    void add(int value) { m_value += value; }
    void sub(int value) { m_value -= value; }
    void mult(int value) { m_value *= value; }

    int getValue() { return m_value; }
};

int main()
{
    Calc calc{};
    calc.add(5); // returns void
    calc.sub(3); // returns void
    calc.mult(4); // returns void

    std::cout << calc.getValue() << '\n';
    return 0;
}
```

​		if we make each function return *this, we can chain the calls together.

```c++
class Calc
{
private:
    int m_value{};

public:
    Calc& add(int value) { m_value += value; return *this; }
    Calc& sub(int value) { m_value -= value; return *this; }
    Calc& mult(int value) { m_value *= value; return *this; }

    int getValue() { return m_value; }
};


int main()
{
    Calc calc{};
    calc.add(5).sub(3).mult(4);

    std::cout << calc.getValue() << '\n';
    return 0;
}
```

