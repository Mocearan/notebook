# 类的语义

---

​		一个类是否能够进行实例化，意味着一个类是否具有对象语义。

​		而除此之外，类对象还可以支持值语义、拷贝语义、移动语义。

- 值语义 - 默认构造 
- 拷贝语义 - 拷贝构造、拷贝赋值运算符
- 移动语义 - 移动构造 、移动赋值运算符
- 析构语义 - 析构函数



## 隐式声明语义支持

​		如果没有在类类型（`struct`、`class` 或 `union`）中提供任何用户定义的语义支持函数，那么编译器将始终为其声明一个，作为类的 `inline public` 成员。

​		当提供了任意语义支持函数，其对应默认生成的语义支持函数将会被删除。

> ​		这在默认构造函数上有一些特别，因为默认构造函数在语义上支持值语义，在形式上是一般构造函数的特殊形式。因而，显式提供了任意构造函数，默认生成的默认构造函数都会被删除。

​		可以在这些语义支持函数上，使用`=default`来向编译器声明，即便提供了响应的语义支持函数，仍提供该默认的重载。

```c++
class Date
{
private:
    int m_year{ 1900 };
    int m_month{ 1 };
    int m_day{ 1 };

public:
    // Tell the compiler to create a default constructor, even if
    // there are other user-provided constructors.
    Date() = default;

    Date(int year, int month, int day) // normal non-default constructor
    {
        m_year = year;
        m_month = month;
        m_day = day;
    }
};

int main()
{
    Date date{}; // date is initialized to Jan 1st, 1900
    Date today{ 2020, 10, 14 }; // today is initialized to Oct 14th, 2020

    return 0;
}
```



## 值语义

###  默认构造

​		A constructor that takes no parameters (or has parameters that all have default values) is called a **default constructor**.

​		The default constructor is called if no user-provided initialization values are provided.

```c++
class Fraction
{
private:
    int m_numerator {};
    int m_denominator {};

public:
    Fraction() // default constructor
    {
        m_numerator = 0;
        m_denominator = 1;
    }
};
```

​		 在类对象上会执行值初始化，即调用默认构造函数。

> Although technically incorrect, this is often called **default initialization**.
>
> 默认构造不是规范的初始化语义，而是基于类的构造行为的习语。

​		一般通过是否带有括号来区别值初始化和默认初始化：

```c++
Fraction frac {}; // Value initialization using empty set of braces
Fraction frac; // Default-initialization, calls default constructor
```



## 拷贝语义

The purpose of the copy constructor and the assignment operator are almost equivalent -- both copy one object to another.

- If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).
- If a new object does not have to be created before the copying can occur, the assignment operator is used.

### 拷贝构造

​		使得类具有在创建时的拷贝语义，即可以通过拷贝同类另一个对象值的方式来创建一个新对象。

​		拷贝构造函数是一种特殊类型的构造函数，用于创建新对象作为现有对象(相同类型)的副本。

> ​		A **copy constructor** is a special type of constructor used to create a new object as a copy of an existing object (of the same type). 

#### 拷贝构造的形式

​		拷贝构造的参数必须是reference/const reference。

> ​		This makes sense: if the argument were passed by value, then we’d need the copy constructor to copy the argument into the parameter of the copy constructor (which would result in an infinite recursion).
>
> ​		否则是在定义拷贝时使用拷贝，造成无限递归。

- 一般形式

  ```c++
  Name ( const Name & );
  ```

- 显式弃置的拷贝构造

  ​	移除类通过拷贝创建的语义，使本类及其聚类（父类或被组合的类）不能进行拷贝初始化。

  ```c++
  Name ( const Name & ) = delete;		// C++11
  ```

  > 可以通过将构造函数私有来实现相同的功能。

- 显式默认的拷贝构造

  ​	如不显式的给出定义，则默认的对所有成员进行拷贝构造来完成新对象的创建。

  ```c++
  Name ( const Name & ) = default;	// c++11
  ```

​		如果有成员去除了拷贝创建语义，则因成员不能完全创建，h会造成本类不能完成拷贝创建。



#### 拷贝构造的默认行为

​		Because the compiler does not know much about your class, by default, the created copy constructor utilizes a method of initialization called memberwise initialization.

​		编译器不能深入的理解类的行为，于是默认的拷贝构造函数行为是逐成员初始化（memberwise initialization）。

> **Memberwise initialization** simply means that each member of the copy is initialized directly from the member of the class being copied. 

#### 构造中的复制消除

​		初始化匿名对象，然后使用该对象直接初始化定义的对象需要两个步骤(一个步骤创建匿名对象，一个步骤调用复制构造函数)。

​		在这种情况下，编译器可以选择不调用可哦被构造函数，进行直接初始化。为了性能目的而省略某些复制(或移动)步骤的过程称为复制消除。

​		c++17之前，编译器的复制消除行为是非强制可选的，这种情况下，即使消除了实际的拷贝过程，拷贝构造函数也必须是可访问的（非删除、非私有）。

​		c++17之后，编译器的一些复制消除行为是强制进行的，这些强制进行的复制消除行为保证不访问拷贝构造函数，因而不需要。

#### example

```c++
#include <cassert>
#include <iostream>

class Fraction
{
private:
    int m_numerator{};
    int m_denominator{};

public:
    // Default constructor
    Fraction(int numerator=0, int denominator=1)
        : m_numerator{numerator}, m_denominator{denominator}
    {
        assert(denominator != 0);
    }

    // Copy constructor
    Fraction(const Fraction& fraction)
        : m_numerator{fraction.m_numerator}, m_denominator{fraction.m_denominator}
        // Note: We can access the members of parameter fraction directly, because we're inside the Fraction class
    {
        // no need to check for a denominator of 0 here since fraction must already be a valid Fraction
        std::cout << "Copy constructor called\n"; // just to prove it works
    }

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}

int main()
{
	Fraction fiveThirds { 5, 3 }; // Direct initialize a Fraction, calls Fraction(int, int) constructor
	Fraction fCopy { fiveThirds }; // Direct initialize -- with Fraction copy constructor
	std::cout << fCopy << '\n';
    
    Fraction fiveThirds { Fraction{ 5, 3 } }; // copy elision
}
```



### 拷贝赋值运算符

​		The **assignment operator** (operator=) is used to copy values from one object to another *already existing object*.

#### 拷贝赋值运算符的形式

```
```

​		可以显式的弃置拷贝赋值运算符，来去除类拷贝赋值的语义，使本类及其聚类不能进行拷贝初始化。

```c++
Name operator=( const Name & ) = delete;// C++11
```



### shallow / deep copying 深浅拷贝

​		The default copy constructor and default assignment operators it provides use a copying method known as a memberwise copy (also known as a **shallow copy**). This means that C++ copies each member of the class individually (using the assignment operator for overloaded operator=, and direct initialization for the copy constructor). 

​		when designing classes that handle dynamically allocated memory, shallow copies of a pointer just copy the address of the pointer。

​		指针的赋值不会重新建立内存副本，只是建立了索引的副本。实际上成为了``shared pointers` 。

​		 A **deep copy** allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source. This way, the copy and source are distinct and will not affect each other in any way. 

```c++
// assumes m_data is initialized
void MyString::deepCopy(const MyString& source)
{
    // first we need to deallocate any value that this string is holding!
    delete[] m_data;

    // because m_length is not a pointer, we can shallow copy it
    m_length = source.m_length;

    // m_data is a pointer, so we need to deep copy it if it is non-null
    if (source.m_data)
    {
        // allocate memory for our copy
        m_data = new char[m_length];

        // do the copy
        for (int i{ 0 }; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = nullptr;
}

// Copy constructor
MyString::MyString(const MyString& source)
{
    deepCopy(source);
}

// Assignment operator
MyString& MyString::operator=(const MyString& source)
{
    // check for self-assignment
    if (this != &source)
    {
        // now do the deep copy
        deepCopy(source);
    }

    return *this;
}
```



## 移动语义

### 移动构造



### 移动赋值运算符



## 析构语义

### 析构函数

​		destructors are designed to help clean up,  executed when an object of that class is destroyed.

​		When an object goes out of scope normally, or a dynamically allocated object is explicitly deleted using the delete keyword, the class destructor is automatically called (if it exists) to do any necessary clean up before the object is removed from memory. 

> ​		destructors may safely call other member functions since the object isn’t destroyed until after the destructor executes.

​		析构函数是以`~`开始，以类名为函数名的无参无返回值函数，且一个类只能拥有一个析构函数。

```c++
class IntArray
{
private:
	int* m_array{};
	int m_length{};

public:
	IntArray(int length) // constructor
	{
		assert(length > 0);
        
		m_array = new int[static_cast<std::size_t>(length)]{};
		m_length = length;
	}

	~IntArray() // destructor
	{
		// Dynamically delete the array we allocated earlier
		delete[] m_array;
	}
};
```

​		Note that if you use the exit() function, your program will terminate and no destructors will be called. Be wary if you’re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).







