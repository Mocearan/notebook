# 类的语义

---

​		一个类是否能够进行实例化，意味着一个类是否具有对象语义。而除此之外，类对象还可以支持值语义、拷贝语义、移动语义。

- 值语义 - 默认构造 
- 拷贝语义 - 拷贝构造、拷贝赋值运算符
- 移动语义 - 移动构造 、移动赋值运算符
- 析构语义 - 析构函数



## 隐式声明语义支持

​		如果没有在类类型（`struct`、`class` 或 `union`）中提供任何用户定义的语义支持函数，那么编译器将始终声明一个，作为类的 `inline public` 成员。

​		当提供了任意语义支持函数，其对应默认生成的语义支持函数将会被删除。

> ​		这在默认构造函数上有一些特别，因为默认构造函数在语义上支持值语义，在形式上是一般构造函数的特殊形式。因而，显式提供了任意构造函数，默认生成的默认构造函数都会被删除。

​		可以在这些语义支持函数上，使用`=default`来向编译器声明，即便提供了响应的语义支持函数，仍提供该默认的重载。

```c++
class Date
{
private:
    int m_year{ 1900 };
    int m_month{ 1 };
    int m_day{ 1 };

public:
    // Tell the compiler to create a default constructor, even if
    // there are other user-provided constructors.
    Date() = default;

    Date(int year, int month, int day) // normal non-default constructor
    {
        m_year = year;
        m_month = month;
        m_day = day;
    }
};

int main()
{
    Date date{}; // date is initialized to Jan 1st, 1900
    Date today{ 2020, 10, 14 }; // today is initialized to Oct 14th, 2020

    return 0;
}
```





##  默认构造

​		A constructor that takes no parameters (or has parameters that all have default values) is called a **default constructor**.

​		The default constructor is called if no user-provided initialization values are provided.

```c++
class Fraction
{
private:
    int m_numerator {};
    int m_denominator {};

public:
    Fraction() // default constructor
    {
        m_numerator = 0;
        m_denominator = 1;
    }
};
```

​		 在类对象上会执行值初始化，即调用默认构造函数。

> Although technically incorrect, this is often called **default initialization**.
>
> 默认构造不是规范的初始化语义，而是基于类的构造行为的习语。

​		一般通过是否带有括号来区别值初始化和默认初始化：

```c++
Fraction frac {}; // Value initialization using empty set of braces
Fraction frac; // Default-initialization, calls default constructor
```



## 拷贝构造

​		使得类具有在创建时的拷贝语义，即可以通过拷贝同类另一个对象值的方式来创建一个新对象。

```c++
Name ( const Name & );
```

​		可以显式的弃置拷贝构造，来去除类通过拷贝创建的语义，使本类及其聚类（父类或被组合的类）不能进行拷贝初始化。

```c++
Name ( const Name & ) = delete;		// C++11
```

​		如不显式的给出定义，则默认的对所有成员进行拷贝构造来完成新对象的创建。如果有成员去除了拷贝创建语义，则因成员不能完全创建，造成本类不能完成拷贝创建。

```c++
Name ( const Name & ) = default;	// c++11
```



## 拷贝赋值运算符

​		可以显式的弃置拷贝赋值运算符，来去除类拷贝赋值的语义，使本类及其聚类不能进行拷贝初始化。

```c++
Name ( const Name & ) = delete;		// C++11
```



## 移动构造



## 移动赋值运算符



## 析构

​		destructors are designed to help clean up,  executed when an object of that class is destroyed.

​		When an object goes out of scope normally, or a dynamically allocated object is explicitly deleted using the delete keyword, the class destructor is automatically called (if it exists) to do any necessary clean up before the object is removed from memory. 

> ​		destructors may safely call other member functions since the object isn’t destroyed until after the destructor executes.

​		析构函数是以`~`开始，以类名为函数名的无参无返回值函数，且一个类只能拥有一个析构函数。

```c++
class IntArray
{
private:
	int* m_array{};
	int m_length{};

public:
	IntArray(int length) // constructor
	{
		assert(length > 0);
        
		m_array = new int[static_cast<std::size_t>(length)]{};
		m_length = length;
	}

	~IntArray() // destructor
	{
		// Dynamically delete the array we allocated earlier
		delete[] m_array;
	}
};
```

​		Note that if you use the exit() function, your program will terminate and no destructors will be called. Be wary if you’re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).







