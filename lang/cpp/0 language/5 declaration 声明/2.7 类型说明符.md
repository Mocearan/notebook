# 类型说明符

​		为一个类型的说明符序列指定名字。

---

​		声明所引入的每个实体都是这个类型，并可以被声明符修饰。

​		这个说明符序列也用于类型标识（`type-id`）。

​		类型说明符序列中说明符的顺序不限。



## 简单类型说明符

### 基础类型

>   char / char8_t / char16_t / char32_t / wchar_t / bool / short / int / long / signed / unsgined / float / double / void
>
>   ps：基本概念/实体/类型/基础类型/

### auto

​		占位类型说明符。

- 对于变量，指定要从其初始化器自动推导出其类型。
- 对于函数，指定要从其return语句推导出其返回类型。
- 对于非类型模板形参，指定要从实参推导出其类型。



#### type deduction

​		**Type deduction** (also sometimes called **type inference**) is a feature that allows the compiler to deduce the type of an object from the object’s **initializer**. 

​		Type deduction will not work for objects that do not have initializers or empty initializers. 

- type deduction drops const qualifiers

  ```c++
  const int x { 5};
  auto y {x}; // y will be type int (const is dropped)
  ```

  > want const, must supply the const explict
  >
  > ```c++
  > const auto z {x}; // const int
  > ```

- type deduction drops references

  ```c++
  std::string& getRef(); // some function that returns a reference
  auto ref { getRef() }; // type deduced as std::string (not std::string&)
  ```

  >  want  reference, reapply the reference at the point of definition
  >
  > ```c++
  > auto& ref2 { getRef() }; // std::string& (reference reapplied)
  > ```

  - only drops top-level consts. Low-level consts are not dropped.

  - If the initializer is a reference to const, the reference is dropped first (and then reapplied if applicable), and then any top-level const is dropped from the result.

    ```c++
    const std::string& getRef(); // some function that returns a reference to const
    // `const std::string&`, the reference is dropped first, leaving us with a `const std::string`. This const is now a top-level const, so it is also dropped, leaving the deduced type as `std::string`.
    
    auto ref1{ getRef() }; // std::string (reference dropped, then top-level const dropped from result)
    
    const auto ref2{ getRef() };  // const std::string (const reapplied, reference dropped)
    
    auto& ref3{ getRef() };       // const std::string& (reference reapplied, low-level const not dropped)
    // Normally the reference would be dropped, but since we’ve reapplied the reference, it is not dropped.  And since this const is a low-level const, it is not dropped.
    
    const auto& ref4{ getRef() }; // const std::string& (reference and const reapplied)
    // The ref4 case works similarly to ref3, Since the type is already deduced as a reference to const, us reapplying const here is redundant.
    // explicitly clear that our result will be const (whereas in the ref3 case, the constness of the result is implicit and not obvious).
    ```

    > If you want a const reference, reapply the `const` qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.

- type deduction does not drop pointers

  ```c++
  std::string* getPtr(); // some function that returns a pointer
  auto ptr1{ getPtr() }; // std::string*
  ```

  - We can also use an asterisk in conjunction with pointer type deduction

    ```c++
    auto* ptr2{ getPtr() }; // std::string*
    ```

  -  Just like with references, only top-level const is dropped during pointer type deduction.

    ```c++
    std::string* getPtr(); // some function that returns a pointer
    
    const auto ptr1{ getPtr() };  // std::string* const
    auto const ptr2 { getPtr() }; // std::string* const
    //  auto const or const auto, we’re saying, “make whatever the deduced type is const”
    // the deduced type is std::string*, and then const is applied
    
    const auto* ptr3{ getPtr() }; // const std::string*
    auto* const ptr4{ getPtr() }; // std::string* const
    // A const on the left means “make the deduced pointer type a pointer to const”, whereas a const on the right means “make the deduced pointer type a const pointer”.
    ```

  - const pointer to const

    ```c++
    const std::string* const getConstPtr(); // some function that returns a const pointer to a const value
    
    auto ptr1{ getConstPtr() };  // const std::string*
    auto* ptr2{ getConstPtr() }; // const std::string*
    // The low-level const is not dropped. 
    
    auto const ptr3{ getConstPtr() };  // const std::string* const
    const auto ptr4{ getConstPtr() };  // const std::string* const
    // The top-level const is dropped, but we’re reapplying it.
    // The low-level const is not dropped. 
    
    auto* const ptr5{ getConstPtr() }; // const std::string* const
    const auto* ptr6{ getConstPtr() }; // const std::string*
    // the top-level const is dropped.
    // ptr5, the auto* const reapplies the top-level const
    // ptr6, the const auto* applies const to the type being pointed to (which in this case was already const)
    
    const auto const ptr7{ getConstPtr() };  // error: const qualifer can not be applied twice
    // we’re applying the const qualifier twice to a specifier, which is disallowed, and will cause a compile error.
    const auto* const ptr8{ getConstPtr() }; // const std::string* const
    // we’re applying const on both sides of the pointer (which is allowed since auto* must be a pointer type)
    ```

    > If you want a const pointer, reapply the `const` qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.

- string literals will be type `const char*`

  ```c++
  auto s{"hello world"}; // const char*
  ```

  want `std::string / std::string_view`, need to use `s/sv` literal suffixs

  ```c++
  using namespace std::literals;
  auto s1{"goo"s}; // std::string
  auto s2{"moo"sv}; // std::string_view
  ```

​	

​		type deduction benefits:

- increase readability

  ```c++
  double x{5.0};
  auto x{5.0};
  ```

- avoid unintentionally uninitialized variables

  ```c++
  int x;
  auto y;
  ```

- avoid unintended conversions:

  ```c++
  double x{5};
  auto y {5};
  ```

​		

​		type decuction downsides:

- obscures an object’s type infomation in the code
- initializer change will causes  type change



​		Use type deduction for your variables, unless you need to commit to a specific type.



#### type deduction for functions

​		Since the compiler already has to deduce the return type from the return statement, in C++14, the `auto` keyword was extended to do function return type deduction.

```c++
auto add(int x, int x)
{
	return x + y;
}
```

- can’t dynamic type deduce

  ```c++
  auto func(bool b) 
  {
  	if(b) return 5; // int
      else return 5.7; // double
  }
  ```

  ​		the two return statements return values of different types, so the compiler will give an error.

- `auto`return type function must be fully defined before then can be used.

  ​	a forward declaration is not sufficient

  ```c++
  auto foo();
  
  int main()
  {
      std::cout << foo() ;// the compiler has only seen a forward declaration at this point
  }
  
  auto foo()
  {
      return 5;
  }
  ```

- type deduction can’t be used for function parameter types

  形参在运行时被赋值，所以不能通过值来推断类型。

  > ​		type deduction doesn’t work for function parameters, and prior to C++20, the above program won’t compile.
  >
  > ​		In C++20, the `auto` keyword was extended so that the above program will compile and function correctly -- however, `auto` is not invoking type deduction in this case. Rather, it is triggering a different feature called `function templates` that was designed to actually handle such cases.
  >
  > ```c++
  > void addAndPrint(auto x, auto y)
  > {
  >     std::cout << x + y;
  > }
  > 
  > int main()
  > {
  > 	addAndPrint(2,3); // case 1: call addAndPrint with int parameters
  >     addAndPrint(2.5, 5.5) // case2: call addAndPrint with double parameters
  > }
  > ```

  





#### auto 的非类型说明符用法

- 存储类别说明符（已废除）

- Trailing return syntax 尾随返回（见函数声明）

  ```c++
  auto add(int x, int y) -> int
  {
      return (x + y);
  }
  ```

  The trailing return syntax is also required for some advanced features of C++, such as lambdas 

  One nice thing is that it makes all of your function names line up:

  ```c++
  auto add(int x, int y) -> int;
  auto divide(double x, double y) -> double;
  auto printSomething() -> void;
  auto generateSubstring(const std::string &s, int start, int len) -> std::string;
  ```

  



### decltype

### 先前声明过的类名

### 先前声明过的枚举名

### 带模板实参的模板名

### 无模板实参的模板名



## 用户自定义类型

​		c++有两种复合类型可以用于创建用户自定义类型：枚举类型（无作用域和有作用域）、类类型（struct、class、union）。

## 类说明符

### struct

​		创建一个新类型的第一步是将元素组织到一个数据结构中。

​		结构体是程序定义的允许将多个变量捆绑到一个单独类型的数据类型。

```c++
struct Vector {
       double* elem;  // pointer to elements
       int sz;               // number of elements
};
Vector v;
```

​		结构体中的各部分变量称为 **data members** (or **member variables**).

​		访问特定的数据成员，通常使用 **member selection operator** (`operator.` and `operator->`) 。

```c++
void f(Vector v, Vector& rv, Vector* pv)
{
        int i1 = v.sz;             // access through name
        int i2 = rv.sz;            // access through reference
        int i3 = pv->sz;         // access through pointer
}
```

​		以`C`语言为传统的对结构体的处理，通常通过一组围绕该结构体而设计的函数来实现该用户自定义类型的操作。

```c++
void vector_init(Vector& v, int s)    // initialize a Vector
{
        v.elem = new double[s];  // allocate an array of s doubles
        v.sz = s;
}
```

​		然后通过该结构体和这一组函数来实现面向对象的编程。

```c++
double read_and_sum(int s)
        // read s integers from cin and return their sum; s is assumed to be positive
{
        Vector v;
        vector_init(v,s);                        // allocate s elements for v

        for (int i=0; i!=s; ++i)
                cin>>v.elem[i];                 // read into elements

        double sum = 0;
        for (int i=0; i!=s; ++i)
                sum+=v.elem[i];              // compute the sum of the elements
        return sum;
}
```

​		但这样的设计使得用户必须了解结构体相关的所有细节。

​		但在c++中对`struct`进行了增强，使得`struct`和`class`没有本质上的区别，`struct`默认成员为`public`且默认继承为`public`。

#### 对齐

​		For performance reasons, the compiler will sometimes add gaps into structures (this is called **padding**).

> [data structure alignment](https://en.wikipedia.org/wiki/Data_structure_alignment)
>
> 64位机通常以机器字8字节为对齐单元，32位机通常以机器字4字节为对齐单元。这和地址尺寸是一致的（指针类型尺寸）。

​		`padding`对齐实际上会对类类型的尺寸有着很大的影响， 如不同的成员顺序组织，影响一个对齐单元是否能容纳多一个的成员，以减小`padding`的个数，从而减小类类型的尺寸。

```c++
struct Foo1
{
    short a{};
    short qq{}; // note: qq is defined here
    int b{};
    double c{};
};
// 16

struct Foo2
{
    short a{};
    int b{};
    double c{};
    short qq{}; // note: qq is defined here
};
// 24
```

​		

### class

​		类将数据结构的表示（数据成员组成）和相关的操作紧密的联系在一起，以使其更贴近内建数据类型。

​		通过`public`限定外部能够访问的操作，称为接口。`private`限定的操作只能通过接口来间接的使用。

​		通常将`public`的部分定义在在`private`之前，强调接口。但在强调数据结构表示的情况下，可以将部分`private`放在前部。

```c++
class Vector{
public:
    Vector(int s) :elem{new double[s]}, sz{s} { }    // construct a Vector
    double& operator[](int i) { return elem[i]; }      // element access: subscripting
    int size() { return sz; }
    private:
    double* elem;  // pointer to the elements
    int sz;               // the number of elements
};
```

```c++
double read_and_sum(int s)
{
        Vector v(s);                                    // make a vector of s elements
        for (int i=0; i!=v.size(); ++i)
                cin>>v[i];                               // read into elements

        double sum = 0;
        for (int i=0; i!=v.size(); ++i)
                sum+=v[i];                             // take the sum of the elements
        return sum;
}
```

​		`Vector`对象本身具有固定的大小，这是在C++中处理不同数量信息的基本技术：一个固定大小的句柄，指向一个动态存储空间。

### union

## 枚举说明符

​		An **enumeration** (also called an **enumerated type** or an **enum**) is a compound data type where every possible value is defined as a symbolic constant (called an **enumerator**).

> enumerators are *integral* symbolic constants. As a result, enumerated types actually hold an integral value.

​		C++ supports two kinds of enumerations: unscoped enumerations and scoped enumerations.

​		Enumerations don’t have to be named, but unnamed enumerations should be avoided in modern C++.Enumerators must be given names.

> Name your enumerated types starting with a capital letter. Name your enumerators starting with a lower case letter.

​		Each enumerated type you create is considered to be a **distinct type**, meaning the compiler can distinguish it from other types (unlike typedefs or type aliases, which are considered non-distinct from the types they are aliasing).



###  Unscoped enumerations 无作用域枚举

```c++
enum Color {
// These symbolic constants define all the possible values this type can hold
    // Each enumerator is separated by a comma, not a semicolon
    black, // assigned 0
    red, // assigned 1
    blue, // assigned 2
    green, // assigned 3
    white, // assigned 4
    cyan, // assigned 5
    yellow, // assigned 6
    magenta, // assigned 7 // trailing comma optional but recommended for consistency.
}; // the enum definition must end with a semicolon

Color cup { blue };    // my cup is blue
Color socks { white }; // error: white is not an enumerator of Color
Color hat { 2 };       // error: 2 is not an enumerator of Color
```

​		Unscoped enumerations also provide a named scope region for their enumerators (much like a namespace acts as a named scope region for the names declared within). 

```c++
Color raspberry { Color::red }; // also okay, accessing enumerator from scope of Color
```

​		Prefer putting your enumerations inside a named scope region (such as a namespace or class) so the enumerators don’t pollute the global namespace.

```c++
namespace color
{
    // The names Color, red, blue, and green are defined inside namespace color
    enum Color
    {
        red,
        green,
        blue,
    };
}

namespace feeling
{
    enum Feeling
    {
        happy,
        tired,
        blue, // feeling::blue doesn't collide with color::blue
    };
}

color::Color paint { color::blue };
feeling::Feeling me { feeling::blue };
```

> Classes also provide a scope region, and it’s common to put enumerated types related to a class inside the scope region of the class. 

​		可以显式为`enumerator`赋值，其后随无显式值的`enumerator`会依据自然数增长，直到遇到下一个有显式值的`enumerator`

```c++
enum Animal
{
    cat = -3,
    dog,         // assigned -2
    pig,         // assigned -1
    horse = 5,
    giraffe = 5, // shares same value as horse
    chicken,      // assigned 6
};
```

> When this happens, the enumerators become non-distinct -- essentially, `horse` and `giraffe` are interchangeable. Although C++ allows it, assigning the same value to two enumerators in the same enumeration should generally be avoided.

​		Unscoped enumerations will implicitly convert to integral values.

```c++
Color shirt{ blue };
std::cout << "Your shirt is " << shirt; // 2
```

​		While the compiler will implicitly convert unscoped enumerators to an integer, it will *not* implicitly convert an integer to an unscoped enumerator. 

```c++
Color shirt{ 2 }; // compile error: integer value 2 won't implicitly convert to a Color
shirt = 1; // compile error: integer value 3 won't implicitly convert to a Color

Color shirt { static_cast<Color>(2) }; // convert integer 2 to a Pet
shirt = static_cast<Color>(3);       // our pig evolved into a whale!
```

​		in C++17, if an unscoped enumeration has a specified base, then the compiler will allow you to initialize (but not assign) an unscoped enumeration using an integral value:

```c++
enum Pet: int // we've specified a base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

Pet pet { 2 }; // ok: can initialize with integer
pet = 3;       // compile error: can not assign with integer
```

​		C++没有直接的序列化`enumerator`的方法，需要手工编写代码：

```c++
enum Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColor(Color color) // C++17
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

std::cout << "Your shirt is " << getColor(shirt) << '\n';
```

​		Most often, enum variables is the same size as a standard `int`.However, it is possible to specify a different underlying type.

```c++
// Use an 8-bit unsigned integer as the enum base
enum Color : std::uint8_t
{
    black,
    red,
    blue,
};
```

> Specify the base type of an enumeration only when necessary.

​	

### Scoped enumerations(enumeration class) 有作用域枚举

​		 unscoped enumerations are distinct types in C++, they are not type safe.

```c++
enum Color
{
  red,
  blue,
};

enum Fruit
{
  banana,
  apple,
};

Color color { red };
Fruit fruit { banana };

if (color == fruit) // The compiler will compare color and fruit as integers
  std::cout << "color and fruit are equal\n"; // and find they are equal!
else
  std::cout << "color and fruit are not equal\n";
```

​		That solution is the **scoped enumeration** (often called an **enum class** in C++ for reasons that will become obvious shortly).

- strongly typed (they won’t implicitly convert to integers) 
- strongly scoped (the enumerators are *only* placed into the scope region of the enumeration).

```c++
enum class Color // "enum class" defines this as a scoped enumeration rather than an unscoped enumeration
{
  red, // red is considered part of Color's scope region
  blue,
};

enum class Fruit
{
  banana, // banana is considered part of Fruit's scope region
  apple,
};

Color color { Color::red }; // note: red is not directly accessible, we have to use Color::red
Fruit fruit { Fruit::banana }; // note: banana is not directly accessible, we have to use Fruit::banana

if (color == fruit) // compile error: the compiler doesn't know how to compare different types Color and Fruit
  std::cout << "color and fruit are equal\n";
else
  std::cout << "color and fruit are not equal\n";
```

> This program produces a compile error on line 19, since the scoped enumeration won’t convert to any type that can be compared with another type.

​		Because scoped enumerations offer their own implicit namespacing for enumerators, there’s no need to put scoped enumerations inside another scope region (such as a namespace), unless there’s some other compelling reason to do so, as it would be redundant.

​		**Scoped enumerations don’t implicitly convert to integers**

> As of C++17, you can initialize a scoped enumeration using an integral value without the static_cast (and unlike an unscoped enumeration, you don’t need to specify a base).

​		**Easing the conversion of scoped enumerators to integers**,  a useful hack is to overload the unary `operator+` to perform this conversion.

```c++
enum class Animals
{
    chicken, // 0
    dog, // 1
    cat, // 2
    elephant, // 3
    duck, // 4
    snake, // 5

    maxAnimals,
};

// Overload the unary + operator to convert Animals to the underlying type
// adapted from https://stackoverflow.com/a/42198760, thanks to Pixelchemist for the idea
constexpr auto operator+(Animals a) noexcept
{
    return static_cast<std::underlying_type_t<Animals>>(a);
}

int main()
{
    std::cout << +Animals::elephant; // convert Animals::elephant to an integer using unary operator+

    return 0;
}
```



​		

### using enum 声明

## 详述类型说明符

## typename说明符



## cv限定符（const/volatile）

>   CV限定实际上是从类型的可写角度，来限定对象从外部可写的权限。
>
>   而对象内部限定的可写性，是对象自身性质的一部分，依赖类的访问控制机制（常函数接口，常成员等，公有私有等）
>
>   >   ​		在本节，所谓访问权限为：可读或可写。即从外部观察变量时的权限，因已经向外部暴露，则认为都可读。

-   指明 被声明对象 或 被命名类型 的常变性（常量性 或 易变性）。

-   可以在任意类型说明符或声明说明符序列中

-   除函数类型 / 引用类型 外都可用

    >   包括不完整类型
    >
    >   数组类型的cv限定，同元素的cv限定

-   由对象被创建时所使用的cv限定来决定常变性

    -   声明语句中，声明说明符序列，或声明符的一部分
    -   new 表达式中，类型表示的一部分

#### const

​		限定对象外部访问权限为不可写，除非绕过对象的直接访问。

-   必须进行初始化
-   不能进行赋值

>   通过非const类型的引用或指针，间接访问并修改const对象是可行的，但结果UB。

​		根据子对象组成对象的性质，const对象的子对象（数据成员）也不能被外部修改。

>   ​		在未声明为 `extern` 的非局部非 volatile 非模板(C++14 起)非 inline(C++17 起)变量声明上使用 `const` 限定符，会给予该变量内部连接。
>
>   ​		这有别于 C，const 文件作用域对象拥有外部连接。

##### mutable

​		允许子对象被修改，即便子对象所属的对象声明为const。

​		可出现在非引用非 const 非静态数据成员声明中

```c++
class A
{

public:
    int a;
    mutable int b;
    //mutable int *const c;// ERR 顶层const，常指针不能修改指向
    mutable const int *d; // OK，底层const，可修改指向
};

int main( void )
{
    const A a {};
    // a.a = 1;
    a.b = 1;
}
```

​		mutable 用于指定不影响类的外部可观察状态的成员：通常用于互斥体、记忆缓存、惰性求值和访问指令等。

```c++
#include <mutex>
class ThreadsafeCounter
{
    mutable std::mutex m; // “M&M 规则”：mutable 与 mutex 一起出现
    int data = 0;
public:
    int get() const
    {
        std::lock_guard<std::mutex> lk( m );
        return data;
    }
    void inc()
    {
        std::lock_guard<std::mutex> lk( m );
        ++data;
    }
};

```

>   `mutable` 被当做存储类说明符而非类型限定符，但它不影响存储类或连接



##### 顶层const / 底层const

​		对于指针而言，const限定对const本身的访问权限 还是对指针间接访问对象的权限，由const与`*`的相对位置来决定。

​		`const *`，称为底层const，限定通过指针进行间接访问的权限。

​		`* const`，称为顶层const，限定对指针变量本身进行访问的权限。

> A **top-level const** is a const qualifier that applies to an object itself.
>
> a **low-level const** is a const qualifier that applies to the object being referenced or pointed to

​		`const * const`，同时限定两者。

```c++
const int x;    // this const applies to x, so it is top-level
int* const ptr; // this const applies to ptr, so it is top-level

const int& ref; // this const applies to the object being referenced, so it is low-level
const int* ptr; // this const applies to the object being pointed to, so it is low-level

const int* const ptr; // the left const is low-level, the right const is top-level
```



>   ps：声明/声明符/指针声明符/常量性



##### 常量的定义方式

-   通过#define声明常量宏

    预处理器处理，不申请内存，不进行类型检查

-   通过const声明常变量

-   通过enum引入枚举常量

>   c++建议通过后两种方式来声明常量。
>
>   这种建议限于面向应用的编程，对框架以下的底层编程来说，#define能灵活处理大量的泛化问题。
>
>   >   不要陷入某种教条之中，要寻找问题的本质，和最佳解法。
>
>   如：
>
>   ```c++
>   #define STR(a) #a
>   #define CAT(a, b) a ##b
>   ```
>
>   



#### volatile

​		volatile声明易变性，是声明给硬件的。

​		通常，编译器会在单个线程进行指令重排，加载某个值到寄存器绕过内存来加速程序，但如果对象跨线程使用，这种优化可能导致异常的错误。

​		所以，volatile声明在多线程中的对象，具有被多个线程读写的性质，因而相对于某个线程来说，都是易变的。这样，就禁止了这个对象上发生指令重排或加载到寄存器。

​		但volatile不同于其他语言中具有同步语义，c++中的volatile仅用于声明变量在多线程环境中的易变性。

​		这种易变性声明可声明为：volatile对象，volatile的子对象，const volatile对象的mutable子对象。

>   **可能的优化：**
>
>   ​	ps：基本概念/as-if规则
>
>   **求值顺序**
>
>   ​	ps：表达式/求值顺序
>
>   **memory order**
>
>   ​	ps：标准库/原子操作库/内存顺序/memory_order

>   volatile 的一些用法被弃用：
>
>   -   volatile 类型的左值作为内建自增自减运算符的操作数；
>   -   volatile 类型的左值作为内建赋值、复合赋值运算符的左操作数
>   -   除非该直接赋值表达式出现于不求值语境或是弃值表达式
>   -   volatile 对象类型作为函数参数类型或返回类型；volatile 限定符在结构化绑定声明中。

#### const-volatile

​		const-volatile / const volatile 对象的非mutable子对象 / volatile的const子对象 / const对象的非mutable的volatile子对象。

​		兼具常变性。

#### cv限定引用和指针的限定性转换

​		`无限定 < const / volatile < const-volatile`

依此次序，左边的引用/指针能够隐式转换到右边。

右边的引用/指针需要使用`const_cast`来降级使用。

>   多级指针的限定性转换：
>
>   ps：基本概念/表达式/类型转换/隐式转换/限定性转换

