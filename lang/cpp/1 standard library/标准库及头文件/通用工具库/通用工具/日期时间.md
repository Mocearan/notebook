# 日期时间

---

C++ 包含对二类时间操作的支持：

- `chrono` 库，以各种精度跟踪时间的类型的灵活汇集（如[std::chrono::time_point](https://zh.cppreference.com/w/cpp/chrono/time_point) ）。

  > `<chrono>`，`namespace std::chrono{};`

- C 风格日期和时间工具（如 [std::time](https://zh.cppreference.com/w/cpp/chrono/c/time) ）。



## chrono中的类型

​	时钟、时长、时间点

### 时钟

​		时钟由起点（或纪元）及计次频率组成。

> 例如，时钟可以拥有 1970 年 1 月 1 日的纪元，和每一秒的计次。

### 时间点

​		时间点是从特定时钟的纪元开始经过的时间时长。

### 时长

​		时长由时间跨度组成，定义为某时间单位的某个计次数。

> 例如，“ 42 秒”可表示为由 42 个 1 秒时间点位的计次所组成的时长。



## Timing encapsulate

​		using the chrono library is a bit arcane. The good news is that we can easily encapsulate all the timing functionality we need into a class that we can then use in our own programs.

```c++
// Timer.hpp
#include <chrono> // for std::chrono functions

class Timer
{
private:
	// Type aliases to make accessing nested type easier
	using Clock = std::chrono::steady_clock;
	using Second = std::chrono::duration<double, std::ratio<1> >;

	std::chrono::time_point<Clock> m_beg { Clock::now() };

public:
	void reset()
	{
		m_beg = Clock::now();
	}

	double elapsed() const
	{
		return std::chrono::duration_cast<Second>(Clock::now() - m_beg).count();
	}
};
```

```c++
#include <algorithm> // for std::sort
#include <array>
#include <cstddef> // for std::size_t
#include <iostream>
#include <numeric> // for std::iota

#include "Timer.hpp"

const int g_arrayElements { 10000 };

void sortArray(std::array<int, g_arrayElements>& array)
{

    // Step through each element of the array
    // (except the last one, which will already be sorted by the time we get there)
    for (std::size_t startIndex{ 0 }; startIndex < (g_arrayElements - 1); ++startIndex)
    {
        // smallestIndex is the index of the smallest element we’ve encountered this iteration
        // Start by assuming the smallest element is the first element of this iteration
        std::size_t smallestIndex{ startIndex };

        // Then look for a smaller element in the rest of the array
        for (std::size_t currentIndex{ startIndex + 1 }; currentIndex < g_arrayElements; ++currentIndex)
        {
            // If we've found an element that is smaller than our previously found smallest
            if (array[currentIndex] < array[smallestIndex])
            {
                // then keep track of it
                smallestIndex = currentIndex;
            }
        }

        // smallestIndex is now the smallest element in the remaining array
        // swap our start element with our smallest element (this sorts it into the correct place)
        std::swap(array[startIndex], array[smallestIndex]);
    }
}

int main()
{
    std::array<int, g_arrayElements> array;
    std::iota(array.rbegin(), array.rend(), 1); // fill the array with values 10000 to 1

    Timer t;

    sortArray(array);

    std::cout << "Time taken: " << t.elapsed() << " seconds\n";

    return 0;
}

```

```c++
#include <algorithm> // for std::sort
#include <array>
#include <cstddef> // for std::size_t
#include <iostream>
#include <numeric> // for std::iota

int main()
{
    std::array<int, g_arrayElements> array;
    std::iota(array.rbegin(), array.rend(), 1); // fill the array with values 10000 to 1

    Timer t;

    std::ranges::sort(array); // Since C++20
    // If your compiler isn't C++20-capable
    // std::sort(array.begin(), array.end());

    std::cout << "Time taken: " << t.elapsed() << " seconds\n";

    return 0;
}
```

