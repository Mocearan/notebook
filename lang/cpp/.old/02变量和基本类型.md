

## 常量与const 限定符

### 字面值常量

每个字面值常量都对应一种数据类型。

#### 整型和浮点型字面值

```整型```：十进制10，八进制012， 十六进制0xA

```无符号整型```：U、u后缀。

```浮点型```：浮点型3.124 F/f ，双精度浮点型 3.144/ 3.144E0， 长双精度 2.134LD

#### 字符和字符串字面值

```字符```：'a’

```字符串```："abc”

字符串字面值实质上是一个const char []类型，编译器在每个字符串的结尾处加上一个'\0’来标识结束。

如果两个字符串字面值位置紧邻，仅有空格、缩进或者换行符分隔，实质上是同一个字符串的自由书写格式。

#### 转义序列

有两类字符程序员不能直接使用：一类是不可打印的字符，如推个或其他控制字符，因为没有可视的图符。另一类是在c++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。




#### 指定字面值的类型


可以组合部分标识字来使用，如UL。

#### 布尔字面值和指针字面值

```布尔```：true真，false假

```指针```：NULL，nullptr

关键字const 对变量的类型加以限定，使得变量的值不能被改变。

const 对象一旦创建后其值就不能再改变，所以const对象必须初始化。



### const 限定符 与 常变量

>   常量在声明时初始化。

#### 顶层const 和 底层const

顶层const（top-level const）表示常量对象，即对象本身的属性为const

底层const（low-level const）表示常量指针或引用。指针、引用的访问属性为const方式。

需要注意的是，引用不存在顶层const，因为引用本身不是对象，本身不可寻址没有实体，没有本身被访问属性。

```c++
constexpr int *np = nullptr; //顶层const，指向常量
int j = 0;
constexpr int i = 42;  //常量i
// i j必须在函数体外
constexpr const int *p = &i; //const*  底层const，constexpr底层const
constexpr int *p1 = &j; //顶层const，指向变量
```

>   顶层const是变量本身的可访问属性，变量可以通过对自身进行const修饰，来限定直接或间接访问的权限。（一般的const变量，如const int，即顶层const，本身可访问属性为只读）
>
>   底层const是指针、引用这样能间接访问变量的索引的访问属性，用以说明自身对索引对象的访问权限。
>
>   因此，一个变量本身可读可写，对其索引的变量可以声明自己对其访问为读写访问或只读访问。一个变量限定本身只读，对其索引的变量只能声明自己对其访问为只读访问。

#### 初始化和const

只能在const类型的对象上执行不改变其内容的操作。

初始化是不改变const对象的操作中的一种，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。

```c++
	int i = 42;
	const int ci = i;
	int j = ci;
//无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。
```

#### 默认状态下，const对象仅在文件内有效。

对于一个const变量，编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到该变量的地方，用const变量的值替换。

为了执行上述操作，编译器必须知道变量的初始值。**默认情况下，const对象被设定为仅在文件内有效**，多个文件中出现了同名的const变量时，等同于在不同的全局作用域中分别定义了独立的变量。

当需要在多个文件中共享const变量，需要在一个文件中定义const变量，而在其他的多个文件中声明并使用它。解决方法是，对于const变量，不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了。**多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

```c++
//file1.cc
extern const int bufSize = fcn(); // 定义
//file2.cc
extern const int bufSize; //引用到了file1.cc中的bufSize， 声明

// file1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件独有，它的定义将在别处。
//声明： 想声明一个变量而非定义它，就在变量名前添加extern，而且不要显式地初始化变量
```

#### const限定的引用（常量引用）

即以const的方式引用一个变量。（reference to const）。对常量的引用不能用作修改它所绑定的对象。

因为c++中const变量是真常量，将其看为字面值。所以对于一个const变量的引用也只能声明为const的。

引用的对象是常量还是变量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

```c++
const int &i = 42;
const int c1 = 1024;
const int &r1 = c1;

r1=42;//error
int &r2 = c1;// 类型不匹配。const。
```

##### 初始化和常量引用

引用类型必须与所引用对象的类型一致，但有两个例外：

- 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能够被引用即可。尤其允许为一个常量引用绑定非常量的对象、字面值，甚至一个一般表达式。（**限定引用的访问权限，即顶层const**）

  ```c++
  double dval = 3.14;
  const int &ri = dval;
  //编译器的工作模式是如下
  const int temp = dval;
  const int &ri = temp;
  
  // 实际上ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。c++程序员们常常把临时对象简称为临时量。
  ```

  常量引用仅对引用参与的操作做出了限定，对于引用的目标对象本身是不是一个常量未作限定。对象可能是非常量，所以允许通过其他途径改变它的值。

  ```c++
  int i = 42, & r1 = i, const& r2 = i;
  r1 = 43;
  cout << r2;
  ```

  

#### 指针和const

##### 常量（的）指针

指向常量的指针（pointer to const )不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi = 3.14;
double *ptr = &pi; // err
const double* ptr = &pi; 
```

指针的类型必须与其所指对象的类型一致，但是有两个例外：

- 允许令一个常量的指针指向一个非常量对象

  ```c
  double dval = 3.14;
  const double* ptr = &dval; 
  // 这和上述常量引用是一致的。
  ```

  这种是指针或引用自身对所引用对象访问权限的限制。

>   常量数组可以看做是常量指针。
>
>   ```c++
>   const int a[4] = {1,2,3,4};
>   //a[2] = 4; // err.
>    //int& aa = a[2]; bind err  int& -> const int
>    //aa = 12;
>   ```
>
>   

##### const指针（指针常量）

指针本身是常量属性，其存储的地址值和其类型信息不会改变。但其对所指向对象的访问权限是不受限的。常量必须进行初始化，指针常量也一样。

```c
int number = 0;
int * const pnum = &number;
```

##### 指向常量的const指针（常量指针常量）

本身被访问属性和访问属性都受限。

```c
const double i = 2.31;
const int * const pi = &i;
```





#### constexpr 和 常量表达式

```常量表达式```：是指值不会改变并且在编译过程就能得到计算结果的表达式。

字面值术语常量表达式，常量表达式初始化的const对象也是常量表达式。

c++中有几种情况下是需要用到常量表达式的。（见后）

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。

```c++
const int max_files = 20;
const int limit = max_files + 1;
int statff_size = 27; //variable
const int sz = get_size(); // no, get_size()是函数调用，需要运行期堆栈运行后得到值。
```

##### constexpr 变量

c++11新标准规定，允许将变量声明为constexpr类型，**用以让编译器来验证变量的值是否是一个常量表达式**。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
	constexpr int mf = 20;
	constexpr int limit = mf + 1;
	constexpr int sz = size();// 函数调用在常量表达式中必须具有常量值
```

一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。

`const`只确保值在初始化后不能更改不能确保在编译期确定，其中`constexpr`(在C++11中引入)确保变量是编译时间常数。




https://cloud.tencent.com/developer/ask/37526

##### 字面值类型

对声明constexpr时用到的类型必须有所限制，这些类型一般简单而易得，称之为字面值类型（literal type）。

算数类型、引用和指针都属于字面值类型。自定义类、库中的类和模板类都不属于字面值类型，也就不能定义成constexpr。

算数类型都属于字面值类型。
		nullptr或者0的指针是constexpr指针，或者是存储于某个固定地址中的对象。
			（函数体内定义的变量一般来说并非存放在固定地址中，函数体外的对象（全局作用域）地址固定不变，能用来初始化constexpr指针）
			（函数体内定义的全局范围（static，extern）变量，有固定地址。）

##### 指针和constexpr

			（明确constexpr限定符修饰变量，还是指针）

**constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效**，与指针所指的对象无关。

```c++
const int *p = nullptr; // 底层const，指向整型常量的指针
constexpr int *q = nullptr; // 顶层const，constexpr修饰指针称为常量指针
// 类类型及其引用、指针不属于字面值类型。不能被定义成constexpr。
```

与其他常量指针基本一致。

```c++
constexpr int* constexpr q = nullptr; //err
constexpr int* const q = nullptr;  // right
```

#### const与#define

const定义的常量与#define定义的符号常量的区别

- const定义的常量有类型，而#define定义的没有类型，编译可以对前者进行类型安全检查，而后者仅仅只是简单的替换。
- const定义的常量在编译时分配内存，而#define定义的常量是在预编译时由预编译器进行替换，不分配内存。
- 作用域不同，const定义的常变量的作用域是local 变量的作用域。而#define定义的常量作用域为它的定一点到程序结束，当然也可以在某个地方使用#undef取消。

定义常量还可以使用enum，尽量用const、enum替换#define定义常量。

iniline可以替换宏函数。

在基础设施的编程中，#define的用于还是很灵活的。（#和##的预处理字符替换和连接）。

```c++
#define STR(a) #a
#define CAT(a,b) a##b

int main(void)
{
    int xy = 100;
    cout << STR(ABCD) << endl;
    cout << CAT(x,y) << endl;
    return 0;
}
```

- ```#define```定义的常量，容易产生副作用

  ```c++
  // Effective c++ 3rd的一个例子
  #define CALL_WITH_MAX(x,y) f((x) > (y) ? (x) : (y))
  
  int a = 5;
  int b = 0;
  CALL_WITH_MAX(++a, b);
  CALL_WITH_MAX(++a, b+ 10);
  
  // 在这里，调用f之前，a的递增次数竟然取决于“它被拿来和谁比较”
  ```

  

## 处理类型 ： 别名、类型推导

程序的复杂性有一部分来自于类型的复杂。

- 一些类型名，难记又容易写错，且无法明确体现其真实的目的和含义
- 难以确定限定使用的类型，只能从程序的上下文环境中获得帮助

### 类型别名

类型别名（type alias）：是某种类型的同义词。

>   使用类型别名可以让复杂的名字变得简单明了，易于使用，有助于程序员清楚地知道使用该类型的真实目的。

#### 两种用于定义类型别名的方法

- typedef

  ```c++
  typedef double wages;
  typedef wages base, *p;//*p 是double* 的同义词
  ```

  >   								关键字typedef作为**声明语句中的基本数据类型的一部分**出现。含有typedef的声明语句定义的不再是变量而是类型别名。这里的声明符也可以包含类型修饰，从而能由基本数据类型构造出复合类型来。

  

- 别名声明（alias declaration）  using

  ```c++
  using SI = Sales_item;
  SI item;
  ```

  >   								这种方法用关键字using作为别名的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

	>   			
  >   								类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。

#### 类型别名对指针、常量的处理原则

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到到的后果。

>   **禁止替换：**
>
>   使用了类型别名的声明语句，人们会错误的将原来的类型替换进别名语句来理解。这是错误的。

```c++
typedef char* pstring;

// cstr 指向char 的常量指针。即char* const pstring（顶层const）
// 不等同于 const char* pstring;（底层const）
// const pstring 是声明语句中的基本数据类型。
// 如果简单替换后，const char *cstr = 0; 基本数据成为const char，*成为了声明符的一部分，说明声明了一个const char类型的指针。
const pstring cstr = 0; 

// ps 是一个二级指针，存储了一个指向char类型的常量指针。 
// ps 本身底层const
const pstring *ps;  

// 也就是说，会将typedef、using定义的复杂类型当做个整体来看待，基于此别名的类型修饰，是针对这个复杂类型本身的。
```



###  auto 类型说明符

>    https://zh.cppreference.com/w/cpp/keyword/auto
>
>    c++11新标准引入auto类型说明符。
>
>    编译通过初始值来推导变量的类型， auto定义的变量必须有初始值。

```c++
int n = 200;
auto n = 200;
auto nx = n;
auto nl = 200L;
std::cout << typeid(n1).name() << std::endl; // l -> long

Sales_item val1, val2;
auto item = val1 + val2;
std::cout << item << std::endl;
```

使用auto也能在一条语句中声明多个变量

因为一条声明语句只能有一个基本数据类型。

```c++
auto i = 0u, *p = &i;
```

#### auto 推导复杂类型及const修饰符的原则

编译器推断出的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

```c++
int i = 0, &r = i;
const int ci = i, & cr = ci;
```

- 引用的auto以引用对象的类型为准

  ```c++
  /*
  	使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。
  	此时编译器以引用对象的类型作为auto的类型。
  */
  auto a = r;
  std::cout << typeid(a).name(); // int
  ```

- auto会忽略掉顶层const，同时底层const则会保留下来

  ```c++
  /*
  	auto一般会忽略掉顶层const，同时底层const则会保留下来
  */
  auto b = ci;
  std::cout << typeid(b).name()<<std::endl;//int, ci的顶层const特性被忽略掉了
  			// 对于ci来说，是对i进行了拷贝，并对自身的内存限制了被访问权限
  		// 以auto推断也是一样，既然创建了新的内存空间，内存空间的访问权限就使用默认权限而不沿用推断
  
  auto c = cr;
  std::cout << typeid(c).name() << std::endl;//int， 兼具上一条和 引用的推断
  
  auto d = &i;
  std::cout << typeid(d).name() << std::endl;//int *， 对i取地址得到一个整数的指针
  
  auto e = &ci;
  std::cout << typeid(e).name() << std::endl;//const int *，ci的内存地址是受限访问的，推导出一个对该内存的间接访问，当然这种访问方式的底层访问权限也必须是受限的。
  ```

- 如果希望推断得到一个顶层const，需要附加指出

  ```c++
  const auto f = ci;
  std::cout << typeid(f).name() << std::endl; // const int
  
  const auto f = &ci;	// const int * const
  std::cout << typeid(f).name() << std::endl; // 这个破玩意儿也会把顶层const去掉。。。int const *
  ```

- 希望推导得到一个引用，需要附加指出。

  ```c++
  /*
  	设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留到引用中，
  	如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了，而是底层常量，所以引用中保留的是底层const。
  		（第二句解释， 就是比如g给个ci绑定了一个引用，这时ci的引用关系上就有了一个来自顶层的引用g，所以ci就不再是独立的顶层常量了，故不违背一般去掉顶层const的说法。引用也没有顶层const。
  		也就是通过底层的被访问权限受限推导到顶层的访问权限受限。）
  */
  
  auto& g = ci; //const int& 
  std::cout << typeid(g).name() << std::endl;// int
  
  //auto& h = 42; error， 不能为非常量引用绑定字面值
  const auto& h = 42;//const int& 
  std::cout << typeid(h).name() << std::endl;//int
  ```

- 同一条语句中定义多个变量的推导

  ```c++
  /*
          在同一条语句中定义多个变量，切记，符号&和*值从属于某个声明符，
          而非基本数据类型的一部分，因此初始值必须是同一种类型
      */
  auto k = ci, & l = i;
  auto& m = ci, * p = &ci;
  auto& n = i /*, * p2 = &ci*/; //ci是const int
  const auto* p2 = &ci;
  ```

#### 自动类型推导的作用

-   简化代码

    在使用模板的场景下，类型显得臃肿，但并不为人所关心。

    ![image-20200922235242386](https://gitee.com/masstsing/picgo-picserver/raw/master/20200922235242.png)

-   当改变初始化表达式返回值的数据类型时，不必修改变量类型

    ```c++
    auto val = 10 + 23;
    auto val = 10 + 23.0;
    ```

-    模板场景下的返回值类型后置

     https://zh.cppreference.com/w/cpp/keyword/decltype

     ```c++
     #include <iostream>
     
     // 神奇的是，这两个函数居然构成了重载？编译并没报错
     // 直到main中调用时才出现了二义性
     
     template<typename T, typename U>
     auto add(T t, U u) -> decltype(t + u)
     {
         return t + u;
     }
     
     template<typename T, typename U>
     auto add(T t, U u)
     {
         return t + u;
     }
     
     int main(void)
     {
     
         // 模板返回值类型后置
     //  auto f = add(10 , 12.1);
     //  std::cout << typeid(f).name() << " " << f << std::endl;
     
     //  auto ff = add(10 , 12.2);
     //  std::cout << typeid(ff).name() << " " << f << std::endl;
         return 0;
     }
     
     ```

### decltype 类型指示符

c++11新标准引入第二种类型说明符decltype， 选择并返回操作数的数据类型。

再此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x;
// 编译器不实际调用f()，而是从f()的函数签名中推导返回值类型作为sum的类型。
```

**decltype处理顶层const和引用的方式与auto有些不同**：

- 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

  ```c++
  void page63(const Sales_item si, const Sales_item& ss) 
  {
      decltype(si) x("xxxxxxxxx"); // const Sales_item x
  	decltype(ss) y{ x }; // const Sales_item &y
      		//ss是个引用，decltype(ss)返回的结果就是引用类型，因此作为引用的y必须初始化；
  	// 引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。（ss得到一个引用类型)
  }
  ```

- decltype 和 引用

  ```c++
  /*
  	如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。
  	有些表达式将向decltype返回一个引用类型。一般意味着该表达式的结果对象能作为一条赋值语句的左值。
  
  	如果表达式的内容是解引用操作，则decltype将得到引用类型。
  	解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此decltype（*z）的类型是引用类型
  */
  void page63(const Sales_item si, const Sales_item& ss) 
  {
      decltype(si) x("xxxxxxxxx");
  	decltype(ss) y{ x };
      
      const decltype(ss + si) *z;//const Sales_item *z
      //ss + si使整体结果是一个具体的对象而非一个引用,而且得到的新的z也不再是const，因为相加之后，已经得到了一个具有新值的对象，而非原来某个对象的常值
      
      decltype(*z) a{ y }; // /const Sales_item &a
      //x也可以，变量不影响给常量赋初值
  }
  ```

- decltype的结果类型与表达式形式密切相关

  ```c++
  void page63(const Sales_item si, const Sales_item& ss) 
  {
      decltype(*z) a{ y };//const Sales_item &a
      
  /*
  	前提： 有些表达式将向decltype返回一个引用类型。一般意味着该表达式的结果对象能作为一条赋值语句的左值。
  */
      
  /*
      decltype的另外一个与auto的重要区别是：
         decltype的结果类型与表达式形式密切相关。对于decltype表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号会有不同。
  */
      
  /*
  	结论：
         不加括号得到的就是该变量的类型，加上括号，相当于进行了运算.
         而且因为其是变量，变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型
  */
      decltype((si)) b{ a };//const Sales_item &b
      decltype(si) c;// const Sales_item c , 如果是内置类型，未初始化，const要求初始化，这里默认初始化。
      int i = 0;
      decltype(i) d; // int d
      decltype((i)) e{ d }; //int &e, 这里加const为啥会失效？？？
  }
  ```

  	注意：decltype((variable)) 的结果永远是引用，而decltype(varaible)结果只有当variable本身就是一个引用时才是引用。

  ```c++
  void page63() 
  {
  	//解释上文  变量作为赋值语句参与表达式得到引用
  	int in1 = 3, in2 = 4;
  	decltype(in1) in3 = in1;
  	decltype(in1 = in2) in4 = in1;// in1 = in2 表达式生存期结束，产生匿名对象引用该表达式结果的地址，从而产生引用类型
  }
  ```


## 类型转换

对象的类型定义了数据和运算两个概念。而在运算中有一种操作被普遍支持，就是进行类型之间的转换（convert）。

### 自动隐式类型转换

```自动隐式类型转换```：使用一种类型来取用另一种对象。类型所能表示的值的范围决定了转换的过程。

> 转为bool：0为false， 其他包括负数为正。
>
> bool转为其他：false为0， true 为1.
>
> 浮点数转为整数：舍弃小数部分。
>
> 整数转为浮点数：浮点部分为0，整数超过浮点数表示范围时会有精度损失。
>
> 给无符号类型超出表示范围的值：初始值对无符号类型表示的数值总数取模后的余数。
>
> 给有符号类型一个超出表示范围的值时，结果是未定义的（undefined）。程序可能继续工作、崩溃，或者该内存成为垃圾数据。
>
> ![image-20200922225447746](https://gitee.com/masstsing/picgo-picserver/raw/master/20200922225448.png)
>
> 
>
> ![image-20200922225532283](https://gitee.com/masstsing/picgo-picserver/raw/master/20200922225532.png)



-   将一个值赋值给某一类型的变量时，c++会自动转换

    ```c++
    short s_v = 20;
    int i_v = 20.3;
    float = 1234566787834;
    ```


-   当进行参数传递时

>   使用初始化列表进行初始化或赋值时，会进行类型检查。会对窄类型转换进行警告。
>
>   ```c++
>   #include <iostream>
>   
>   
>   int main(void)
>   {
>    //char c1{200};
>    char c1{67};
>    wchar_t c2{33000};
>    std::cout<< "c1: " << c1 << std::endl;
>   
>    // 警告
>    int x = 95;
>    char c3 = x;
>    char c4{x};
>    std::cout << "c3: " << c3 << "c4: " << c4 << std::endl;
>   
>    // 警告，按char的溢出规则进行溢出
>    int xx = 200;
>    char c33 = xx;
>    char c44{xx};
>    std::cout << "c33: " << (int)c33 << "c44: " << (int)c44 << std::endl;
>   
>    char c5 {c1};
>    std::cout << "c5: " << c5 << std::endl;
>    return 0;
>   }
>   
>   ```

>   ```txt
>   	无法预知的行为源于编译器无须（有时是不能）检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。
>   	不幸的是，在某些情况和/或某些编译器下，含有无须预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
>   	程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，
>   	那么这样的程序就称作不可移植的（nonportable）。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。
>   当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。
>   ```
>   **notice**:
>   	切勿混用带符号类型和无符号类型

### 强制显式类型转换

-   传统的C-style强制转换

    C风格的```(type)var```可以应用于c++中。

    ```c++
    int x = 65;
    char c {(char)x}; // no warnning
    ```

-   C++中的显示类型转换

    -   基于python风格的强制类型转换 ```type(var)```

        ```c++
        int x = 65;
        char x = {char(x)};
        
        std::cout << int('X') << std::endl;
        ```

    -   c++ 的类型转换运算符

        -   const_cast<type>(var);
        -   static_cast<type>(var);
        -   dynamic_cast<type>(var);
        -   reinterpret_cast<type>(var);



## 数组

### 定义

```typename name[size]```

```c++
long productIds[100];
```

数组名实质上是一个指针，指向该连续空间的首地址。

数组长度是，该指针的最大访问宽度是数组长度与指针宽度的乘积，（即指针偏移最大为数组的长度）否则访问该指针会引发空悬指针异常，即数组索引越界。

>   **数组的两维度性质：**
>
>   虽然说数组和指针在寻址行为上，都可以使用索引或者地址偏移的方式进行。但是数组在指针的概念上，增加了一个参数b 维度，用以限定数组的长度。
>
>   所谓数组在参数传递和返回时所表现的退化为指针，是指编译器不能将指针和长度绑定作为一个对象进行处理，从而将长度维度忽略，从而退化成一个指针的行为。所以在参数传递时，需要另外一个参数来补足数组的长度维度。

### 数组的初始化

-   传统C方式

    ```c++
    int number[4] = {3, 6, 9 , 12}; // 初始值列表
    int productIds[4]; // 默认初始化
    // productIds = number; // error, 不支持数组间的直接拷贝赋值。
    float valus[n] = {5.0, 2.1}; // int n = 5; 部分初始化 5.0, 2.1, 0.0, 0.0, 0.0 (自动初始化以类型的默认构造函数为准)
    	// 常用 int totals[200] = {0}; // 统一初始化， 0, 0, 0, ....
    	// 常用 char str[8] = {'\0'}; // 统一初始化， \0, \0, ....
    	// 但实质上仍然是部分初始化，比如 int totals[200] = {1}; char str[8] = {'1'}; 只有首元素被指定，其余元素仍然是默认初始化
    float val[] = {1.2, 2.3,3.4}; // 变长数组初始化定义， 3
    
    int* arrx = new int[4]{1,2,4}; // delete[] arrx;
    for(int i = 0; i < 4; ++i) std::cout << arrx[i] << std::endl;
    ```

-   c++11 

    ```c++
    float totals[200] = {}; // 默认初始化
    double val[20] {1.2, 2.3}; // 部分初始化
    double cal[] {1.2, 2.3,3.4}; // 变长数组初始化定义， 3
    ```

    在c++11 的初始化会对数组元素进行类型检查，对于类型不匹配或者不兼容（宽度向下兼容）的情况进行警告或编译错误。

      ```c++
    //  short as[] = {23, 34, 3.4};
    
    char c_array[] ={'a', 'b', 123};
    
    int a = 123;
    char c_arrays[] ={'a', 'b', a};
      ```

    

### 数组的使用

```c++
productIds[0] = 10;
productIds[1] = 20;
productIds[2] = productIds[0] * productIds[1];

*(productIds[3]) = 30; // 在进行数组索引访问时，无关数组长度维度，可以退化为指针进行使用。这也指征了c风格数组的一个问题，即不能对指针偏移是否超越数组长度进行检查。
```



### 优缺点

数组是连续分配的内存空间，随机访问数组元素进行读写是非常方便地。

但是如果对数组进行插入和删除是非常耗时的，因为为了保证数组的“连续”性质不变，在插入和删除元素时，需要对该位置之后的元素向后腾挪除空间或者向前递补空缺。

### 数组的长度

```c++
std::cout << sizeof productIds << std::endl; // 数组占用的内存大小
std::cout << sizeof productIds / sizeof productIds[0]) << std::endl; 
		// sizeof productIds / sizeof decltype(productIds[0])
		// sizeof productIds / sizeof long

```

### 数组传参的退化

在传统c的语境下，数组本身是不能将其两个维度作为一个统一体进行参数传递和函数返回的，在传递时，无论是```func(char[8])```还是```func(char[])```， 实质上都只是传递了一个```func(char*)```而已，需要另外一个参数来指征该指针可寻址的范围。

而在c++的语境下，同样的用法与c语言保持了兼容性，但是引用语义的加入，使得不退化的传递数组成为了可能，但是这并不能解决对于不定长数组的大小的传递问题。

其根本在于，在传统语境下，两个维度的变量，无法在编译期进行有效的结合。

**所以，传统c语言的两参传递，才是传统数组行之有效的传递方式**

```void func(int a[], int aLen);```

```c++
#include <iostream>
#include <algorithm>
#include <vector>

void each(int ref[10])
{
    std::cout << sizeof(ref) << std::endl; // 8 ， 64bit OS
    for(int i = 0; i < 10; ++i) 
        std::cout << ref[i] << " ";
    std::cout << std::endl;
}

void eachs(int (&ref)[10]) 
{
    std::cout << sizeof(ref) << std::endl; // 40
    for(int i = 0; i < 10; ++i)
        std::cout << ref[i] << " ";
    std::cout << std::endl;
}

void eachas( int (& ref)[])
{
    for(int i = 0; i < 11; ++i) // 所以这里11的确定，是无法得到的，除非是约定好数组的大小，否则无法动态获知。
        std::cout << ref[i] << " "; 
    std::cout << std::endl;
}
// 这里使用algorithm的std::begin, std::end， 以及vector的构造，都无法从一个变长的数组中获得其大小。



int main(void)
{
    int arr[] = {1,2,3,4,5,6,7,8,9,10};
    int arr2[] = {1,2,3,4,5,6,7,8,9,10, 11};

    each(arr);
    each(arr2);

    eachs(arr);
    // eachs(arr2); 编译报错, 这也是传递数组引用的一点好处，能够进行编译时检查。否则长度的不匹配可能会造成有害的结果。

    eachas(arr2);
    return 0;
}
```



### 多维数组

多维数组是对具有复合维度的数据模型的抽象， 如矩阵。当然使用一维数组，加以运算也能实现对这样的数据进行存贮。

#### 从一维数组说起

对于一个5x5的矩阵，使用一维数组进行存储：

```c++
int arr[25] ={0};

// 这里为了和二维数组统一，行列都从0开始
int get(uint32_t row, uint32_t col)
{
    return arr[row*5 + col]; // 合并行列
}

void set(uint32_t row, uint32_t col, int val)
{
    arr[row*5+col] = val;
}

std::pair<uint32_t, uint32_t> find(int val)
{
    for(int i = 0; i < 25; ++i){
        if(arr[i] == val) return {i/5, i%5}; // 取行列
    }
    return {-1, -1};
}

get(0, 3);
set(2,0, 6);
auto [row, col] = find(6);
```

#### 二维数组

基于上述例子，虽然使用以为数组，通过计算来在逻辑上进行多维度的使用，但是这样的计算始终是一种负累。

```c++
int arr[5][5] = {{0}, {0}}; // {0};

std::pair<uint32_t, uint32_t> find(int val)
{
    for(int i = 0; i < 5; ++i){
        for(int j =  0; j < 5; ++j)
        if(arr[i][j] == val) return {i, j};
    }
    return {-1, -1};
}

int val = arr[0][3];
arr[2][0] = 6;
auto [row, col] = find(6);
```

##### 二维数组的初始化

```c++
int arr[5][5] = {0}; 
int arr[5][5] = {1,2,3,4,5,6,7,8,}; //以一维数组的方式部分初始化
int arr[5][5] = {{1}, {0,2},{0,0,3,}}; //以二维数组的方式部分初始化 

// c语言中可以使用数组的指定初始化器，c++不支持
int arrx[5][5] = {[12]=6};
//int arrx[5][5] = {{1}, {0,2},{[2]=3}}; //以二维数组的方式部分初始化 
```

#### 多维数组 的定义

依据二维数组，更高维的数组的使用，定义和嵌套级别更高。其他类似。

```c++
int code[5][5][5] = {{{1,2}, {0,1,2},}, {{0,0,}}};

code[0][1][2] = 5;
```



#### 多维数组与多级指针

基于在多级指针中讨论的，指针在语法层面的模糊性，需要在定义数组某一维度的指针时进行维度说明。

```c++
int arrx[2][3][4] = {0};

int (*ap)[2][3][4] = &arrx; //指向三维数组的指针，可解引用4次，相当于4级指针。
int (*p)[3][4] = arrx; // 指向三位数组第一维的指针，一次偏移跳过一个int[3][4]大小的块，可解引用3次，相当于3级指针
int (*pp)[4] = arrx[0];// 指向三维数组第二维的指针，一次偏移跳过一个int[4]大小的块，可解引用2次，相当于2级指针
int *pv = arrx[0][0];// 指向三维数组第三维的指针，一次偏移跳过一个Int，可解引用一次，一级指针
```

也因上述原因，多维动态数组的内存分配，因每一级都在堆上，只有数组句柄在栈上，索引对每一级都要使用new来进行分配。这和动态指针数组类似。

```c++
//一维动态指针数组

int* (*parr) = new int*[10];// int*(*parr) == int** parr
for(int i = 0; i < 10; ++i){
    parr[i] = new int(i);
    std::cout << *parr[i] << " ";
}
std::cout << std::endl;
```

```c++
// 多维动态数组
int *** dp3 = new int**[2];
for(int i = 0; i < 2; ++i){
    dp3[i] = new int*[3];
    for(int j = 0; j < 3; ++j){
        dp3[i][j] = new int[4];
        for(int k = 0; k < 4; ++k){
            dp3[i][j][k] = j;
            std::cout << dp3[i][j][k] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
}
```





## 字符串

### C风格的字符串

以`char`为基本类型，以`\0`为结束标记符号的字符数组类型。

>   因为其实现为数组，所以对于数组的操作都能支持。且能通过指针的方式进行操作。

#### 存储格式

![image-20201011221149537](https://gitee.com/masstsing/picgo-picserver/raw/master/20201011221150.png)

该数组可以存储在栈上或者堆上。字符串常量存储在常量区。

``` c++
// 对于一个数组，如：
// char s[] = {'a', 'b', '\0', 'c', 'd', '\0', '\0'};
// 这里s并不是一个字符串了，而是一个字符数组。其中存储了两个字符串
// "ab", "cd"

// 所以字符串并非是一个实际的编程语言内置类型概念，而是一个逻辑概念。
// 因此，字符串的表达和实际的存储并非直接相关的关系。

// 一个字符串，即一个以\0字符为结尾的字符线性组合。

// 直接使用s，相当于使用来了一个指针
```

#### 定义和初始化

```c++
char s1[6] = {'a', 'b', 'c', 'd', 'e', 'f'};// 并非字符串
char s2[6] = {'a', 'b', 'c', 'd'};// "abcd"
char s3[6] = {'a', 'b', 'c', 'd', '\0', '\0'};// 相当于s2

char s11[6] = "abcd"; // {'a', 'b', 'c', 'd', '\0', '\0'}   
for(int i = 0; i < 6; ++i) 
    std::cout << (int)s11[i] << " " << std::endl;
std::cout << std::endl;

char str[] = "abcsadfsafsdfa";
const char* pstr = "abcsadfsafsdfa"; // 指向分配在常量区的字符串常量
char* pstr = "abcsadfsafsdfa"; // 同上，但是分配在常量区的字符串常量，由一个可写的指针进行索引可能会出现写错误，c++并不建议这样操作，并会给出警告。
char* pstr = s2;

char* p = new char[strlen(s2) + 1]; // str系列函数查阅c语言手册
```

#### 常量字符串

```c++ 
// 字面值字符串，用作右值
"hello" 
// 只读的字符串变量，用作左值
const char* name = "mass";
// constexpr 字符串，要求编译器在编译器求值为常量的字符串
 
```



#### 相关操作

```cpp
/// type operation

// 1. 连接常量字符串
char str5[] = "abcd""ef";
std::cout << str5 <<std::endl;
std::cout << "xyz""123" <<std::endl;

// 2. 获取字符串长度
std::cout << ::strlen(str5) << std::endl;

// 3. 获取字符串中的字符
for(int i = 0; i < ::strlen(str5); ++i)
    std::cout << str5[i] << " "; // std::cout << *(str5 + i) << " ";
std::cout << std::endl;

// 4. io--> 从io流中读取字符串
char str6[32] = {'\0'};
::fread(str6, 1, 32, stdin);// scanf, gets
std::cout << str6 << std::endl; 
```



### c++风格的字符串 std::string

#### 存储格式

#### 定义和初始化

#### 相关操作

- 输入输出 std::stirng

- 使用c++风格的字符串操作对C-style字符串的输入

  ```c++
  #include <iostream>
  #include <string>
  
  #define CIN_TEST 
  //#define GETLINE_TEST 
  //#define GET_TEST
  
  //#undef CIN_TEST
  //#undef GETLINE_TEST
  
  
  int main(void)
  {
  ```

  

  ```c++
      // 4. 字符串输入  ---- 以c++方式操作C style字符串
      constexpr int size = 16;
      char name[size] = {'\0'};
      std::cout << "input your name" << std::endl;
  
      // 4.1 cin
      //      istream cin(stdin); 是标准库预定义的标准输入流对象
      //      cin与get一样，不会将输入流中的回车读走，但下次读取到回车时，也不会添加到用户buffer中。
      //      所以如果用户希望丢弃回车时，应该在第一次读取后再读取一次，就会将丢弃。
      //      cin经过重载等方式，可以接受任意类型(标准库提供基础类型).
  #if defined CIN_TEST
      name[size-1] = '\0';
      int year;
      std::cout << "input your birth year" << std::endl;
      (std::cin >> year).get();
      std::cout << "your birth year : " << year << std::endl;
  ```

  > ![image-20201018002611744](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20201018002611744.png)
  >
  > 并且，如果输入中含有空白符，会令输入流中断，第一个空白符后的字符都会被丢弃：
  >
  > ![image-20201018003205519](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20201018003205519.png)
  >
  > 也就是说，cin并不能完成按行读取的需求。

  

  ```c++
      // 4.2 getline
  #elif defined GETLINE_TEST
      //      istream.getline
      //      getline会将输入流中的回车字符读走，但会将其丢弃，不会添加到用户buffer中。
      std::cin.getline(name, size);
      for(int i = 0; i<size;++i) std::cout<<(int)name[i]<<" "; std::cout << std::endl;
      char city[size] = {'\0'};
      std::cout << "input your city" << std::endl;
      std::cin.getline(city, size);
      for(int i = 0; i<size;++i) std::cout<<(int)city[i]<<" "; std::cout << std::endl;
      std::cout << "your city: " << city << std::endl;
  ```

  > ![image-20201018004421677](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20201018004421677.png)

  ```c++
      // 4.3 get
  #elif defined GET_TEST
      //      istream.get
      //      get不会将输入流中的回车读走，但下次读取到回车时，也不会添加到用户buffer中。
      //      所以如果用户希望丢弃回车时，应该在第一次读取后再读取一次，就会将丢弃。
      std::cin.get(name, size);
      for(int i = 0; i<size;++i) std::cout<<(int)name[i]<<" "; std::cout << std::endl;
      char city[size] = {'\0'};
      std::cout << "input your city" <<std::endl;
      std::cin.get(city, size);
      for(int i = 0; i<size;++i) std::cout<<(int)city[i]<<" "; std::cout << std::endl;
      std::cout << "your city: " << city <<  std::endl;
  ```

  ```c++
  #endif
  
      std::cout << "your name: " << name << std::endl;
  
  
      return 0;
  }
  ```

- 获取std::string类型变量值中的指定字符 

### 宽字符串和裸字符串

```c++
//
//  c++ 中的宽字符串和裸字符串
//
//


#include <iostream>

using namespace std;

union WChar {
    uint8_t w[4];
    int32_t val;
};

union Char16 {
    uint8_t c16[2];
    int16_t val;
};

int main(void)
{
    // 宽字符串 
    //      宽字符，可以存储非ASCII单字节编码的多字节编码字符 - Unicode编码
    std::string str1 = "中"; // utf8 中文3个字节
    char c_str[] = "中";    // 中文3个字节加 \n  char8_t
    wchar_t wc_str[] = L"中"; // 任意字符4字节
    char16_t c16_str[] = u"中";// 任意字符2字节


    cout << "chinese string "<< str1 <<" length : " << str1.length() << endl;
    //for(const auto& c : str1) cout << (uint32_t)c << endl;
    cout << sizeof str1.data() << endl; // 这个大小的不同是由于stl分配器的原因
    for(int i = 0; i <= str1.length(); ++i) cout << (int)str1[i] << " ";
    cout<< endl;
    for(int i = 0; i < sizeof str1.data(); ++i) cout << (int)str1[i] << " ";
    cout<< endl;

    for(int i = 0; i < sizeof c_str; ++i) cout << (int)c_str[i] << " ";
    cout<< endl;




    for(int i = 0; i < sizeof wc_str / sizeof wc_str[0]; ++i) {
            WChar w{{ uint8_t(wc_str[i] bitand 0xff)
                    , uint8_t((wc_str[i] >> 8) bitand 0xff)
                    , uint8_t((wc_str[i] >> 16) bitand 0xff)
                    , uint8_t((wc_str[i] >> 24) bitand 0xff)}};
            cout << w.val << " ";
    } // 20013 unicode 4e2d 中
     // 0
    cout<< endl;
   for(int i = 0; i < sizeof wc_str / sizeof wc_str[0]; ++i)
       cout << (int32_t)wc_str[i] << " ";
     // 20013 unicode 4e2d 中
     // 0
    cout<< endl;





     cout << "chinese char16[] "<< c16_str <<"byte length : " << sizeof c16_str << " length :" << sizeof c16_str / sizeof c16_str[0] << endl;
    for(int i = 0; i < sizeof c16_str / sizeof c16_str[0] ; ++i) {
            Char16 w{{uint8_t(c16_str[i] bitand 0xff)
                    , uint8_t((c16_str[i] >> 8) bitand 0xff)}};
            cout << w.val << " ";
    } // 20013 unicode 4e2d 中
     // 0 
    cout<< endl;
    for(int i = 0; i < sizeof c16_str / sizeof c16_str[0]; ++i)
        cout << (int32_t)c16_str[i] << " ";
    cout<< endl;


    /// raw string
    //      如果常量字符串中含有转义字符，希望按照原样进行使用，则需要对\进行转
义-》\\
    //      使用raw string会使得字符串不会对\进行转义
    //          R"*()*", 对首末括号及其前后缀中的字符串进行raw string处理
    cout << "hello \n world" << endl;
    cout << "hello \\n world" << endl;
    cout << R"(hello \n world)" << endl;
    cout << R"(hello \n world)" << endl;
    cout << R"((hello) \n world)" << endl;
//  cout << R"aa((hello) \n world)" << endl; //error R"aa()"
    cout << R"aa((hello) \n world)aa" << endl; // right R"aa()aa"
//  cout << R"aa(hello)aa \n world" << endl; //error
    return 0;
}

```



## 小结

​	

## 术语