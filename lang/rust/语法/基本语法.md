# 基础语法

---



##  变量

Rust是强类型语言，但是具有自动类型推导的能力。

### 常变量

使用`let`关键字来声明变量。

```rust
let a = 123;
```

在声明变量后，不允许使用其他类型的字面量对变量进行赋值

```rust
a = "abc"; //error
```

且Rust不允许精度有损失的自动类型转换

```rust
a = 12.3; //error
```

Rust的变量定义也是分为声明和初始化两个过程的，允许变量的声明和初始化分离，并且会从初始化的过程中推导声明时的类型。但是如果只有声明，查找不到初始化过程，就必须进行类型的说明。

```rust
let a = 12;
let b; // declare b.
// init b.
if a > 0 {
    b = -1;
} else {
    b = 0;
}
// b = 12; // if variable inited, the value will not be changed.

println!("b is {}", b);

let c;
let x : i32;
c = 10;
```



### 可变变量

Rust为实现并发的安全性，在语言层面将变量的默认行为设计为“常变量”， 需要使变量可变（mutable），需要用`mut`关键字显式的声明。

```rust
a = 456; //error

let mut a = 123;
a = 456;
```

### 常变量与常量的区别

在Rust中，常变量意味着不能直接对变量进行修改，但是可以通过**重影（shadowing）**，来重新为名字绑定新实体。

```rust
let a = 123;
let a = 456;
```

>**重影（shadowing）**
>
>​	重影类似于c++的名字遮蔽技术，不同的是，c++的相同名字不明声明在同一作用域下，需要在不同作用域声明，在后续深层作用域里声明的名字会遮蔽外层的名字。
>
>​	rust不同之处在于，在同一作用域的前后也能进行这样的遮蔽技术。
>
>```rust
>let x = 5;
>let x = x + 1;
>let x = x * 2;
>println!("the val of x is: {}", x);
>```
>
>​	以此可见，重影不同于变量赋值，而是名字与实体映射关系的重新绑定，类型、可变属性和值都可以改变。而可变变量的赋值只能发生值的变化。
>
>```rust
>// let mut s = "123"; 
>// s = s.len(); // error
>let ss = "123";
>let ss = ss.len();
>```

而Rust中的常量需要使用`const`关键字来声明，且必须指明类型，并且不能进行重影，也不能声明为可变。

```rust
const a : i32 = 123;
let a = 456; //error
const a = 456; //error

const mut b : i32 = 456;//error
```

> 变量有时也为了满足取值范围的需要而显式的指定类型，方便编译器理解。
>
> ```rust
> let a : u64 = 123;
> ```





## 数据类型

### 标量类型（scalar）

​	是一个单独的实体，是语言层面定义的最小数据基元。

#### 整型

​	按照bit大小和有无符号分为：

| 位长度  | 有符号 | 无符号 |
| :------ | :----- | :----- |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

> **arch**
>
> ​	即architecture，结构。这个整型变量的长度取决于运行时宿主系统的架构，与系统的字宽相同。

​	整数字面量的表达方式：

| 进制                 | 例          |
| :------------------- | :---------- |
| 十进制               | 98_222      |
| 十六进制             | 0xff        |
| 八进制               | 0o77        |
| 二进制               | 0b1111_0000 |
| 字节(只能表示 u8 型) | b'A'        |

> rust支持字面量的分隔符`_`，使得字面量的阅读更加方便。
>
> 同时统一了基于二进制表达的八进制，十六进制的表达方式，引入了字节字面量的表达方式。

#### 浮点型

​	支持32位浮点数（f32)和64位浮点数（f64）。默认方式使用字面量初始化的浮点变量是f64，因为现代计算机处理器对两种浮点数的计算速度几乎相同，但64位浮点数精度更高。

```rust
let x = 2.0; // f64
let x : f32 = 3.0; // f32
```

>**运算符支持**
>
>​	对于加减乘除取余等基本运算都支持，还支持对应的赋值版本。
>
>​	但rust不提供自增自减，是为了保证代码的可读性并减少代码书写的复杂度。

#### 布尔型

true/false

#### 字符型

Rust的 char 类型并不基于ASCII编码，而基于Unicode编码，大小为 4 个字节。

> 这意味着它可以支持中文，日文和韩文字符等非英文字符，甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。
>
> Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 
>
> 但是，"字符"这个概念并不存在于 Unicode 中，因此您对"字符"是什么的直觉可能与Rust中的字符概念不匹配。
>
> 所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。
>
> > **注意：**由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

### 复合类型（Compound）

​	多个实体组合成一个类型。

#### 元组（tuple）

​	以`()`声明一组多类型数据，并支持结构化绑定。

```rust
// 声明元组
let t : (i32, f64, u8) = (500, 21.2, 1);
println!("t0 : {}", t.0);
// 将一个元组结构化绑定
let (x, y, z) = t;
println!("x : {}", x);
// 以结构化绑定的方式声明元组
let (a, b , c) : (i32, f64, u8) = (500, 32.1, 3);
println!("a : {}", a);
// 将结构化的元组绑定在一个名字上
let tt = (a, b, c);
println!("tt1 : {}", tt.1);
```

#### 数组(array)

​	以`[]`声明一组同类型数据

```rust
let a = [1, 2, 3, 4, 5];

let b = ["1", "2", "3", "4"];

let c : [i32; 5] = [1, 2, 3, 4, 5];

let d = [3 ; 5]; // [3, 3, 3, 3, 3]


//let a[0] = 9; // error, only name can at let right.
println!("array use {}", a[0]); // rust array is not eq pointer
//  so cannot *a here.

let mut e = [1, 2, 3];
e[0] = 9;
```



## 注释

rust可以进行单行注释(`//`)和多行注释（`/**/`）。

并支持以`///`开头的说明文档注释：

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let x = add(1, 2);
///
/// ```
fn add(a: i32, b: i32) -> i32 
{
    return a + b;
}

// 在调用时，编辑器可能会为这个函数原型带上优雅的说明。
```

同时类似于Javadoc或者doxygen的功能，`cargo doc`可以将说明性注释转换为HTML文档。



## 函数

`fn func_name(parameter list) -> return_type {...}`

Rust函数一般用小写字母的蛇形命名法。

Rust函数一般用c++后置的形式指定返回值。但是不支持返回值类型推导，没有显式声明函数返回值的类型，是纯过程的，即认为返回void。

Rust函数的调用关系不必先声明再使用，在任意某个地方定义即可。

Rust函数体由一系列可以以表达式借我的语句组成。

> 语句时执行某些操作且没有返回值的步骤，即认为是过程。
>
> ```rust
> let a = 6; //是个语句
> let a = (let b = 2); // 因为赋值语句是过程，没有返回值，所以此句不正确。
> ```
>
> 表达式由计算步骤且有返回值。
>
> ```rust
> a = 7;
> b + 2;
> c *(a + b);
> ```
>
> rust中可以使用{}引起一个代码块，用以编写一个较为复杂的表达式，即函数体表达式。
>
> ```rust
> let x = 5;
> let z = 3;
> let y = {
>  let x = 3;
>  x + add_sum(x, z)  // 注意最后一行没有分号，这是因为表达式的结尾不应该有分号，语句之后才应该有分号并且没有返回值。
> };
> 
> println!("x 的值为 : {}", x);
> println!("y 的值为 : {}", y);
> ```
>
> **代码块：**
>
> ​	代码块是一个表达式，在一个内嵌的作用域内，使用一系列语句完成一个流程，最终返回一个值。代码块的值是最后一个表达式的值，所以代码块的最后一行没有封号。

```rust
fn  test_func()
{
    println!("sum 1 and 2 is {}", add_sum(1, 2));
}

fn add_sum(a: i32, b: i32) -> i32
{
    return a + b;
}
```



## 控制流

​	控制流是根据条件围兜为真来决定是否执行某些代码，或重复执行都写代码。

​	Rust提供if表达式和三种循环结构来提供控制流。

### if表达式

`if condition {...} else if {...} else {...}`

这里条件（condition）与python一样，不需要使用小括号来包裹，从condition必须是bool类型，不能是其他整型。

```rust
let number = 3;
if number { // error: expected `bool`, found integerrustc.
    println!("yes"); 
}
```

>   虽然C/C++中看来是很正常的，但是C/C++在设计之初是没有bool类型的，是后期基于整数类型拓展的（非0为真）。但这在很多注重代码安全性的语言中是被禁止的。

但是Rust中的id 不存在但语句不用加{}的规则，即必须使用{}引导。

需要注意的是，在大多数语言中，if是一个语句。但是在Rust中，if是一个表达式，这意味着if引导的条件结构是可以有返回值的。可以将if引起的{}视作一个代码块，进行有条件的返回。

```rust
let a = 3;
let number = if a > 0 { 1 } else { -1 };
```

>   两个代码块的返回类型必须一致，且必须有一个else及其后的表达式块。并且可以嵌套，达到三目运算符的效果。

### 循环

#### loop表达式

loop是Rust提供的原生死循环结构。

```rust
let mut counter = 0;

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;
    }
};

println!("The result is {}", result);
```

>   ​	Rust的break语句类似于函数的Return语句，可以带出一个结果到循环外部。	
>
>   ​	这是一个很巧妙的设计，因为循环的一个主要用途是用来查找，在查找结束时返回结果。当然，也是可以忽略结果，不接收返回。

#### while 循环

while循环是对loop中以if条件判断跳出模式的精简表达。

```rust
```















