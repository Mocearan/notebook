# 算法

---



​		基本运算及规定的运算顺序所构成的完整的解法，或者看成按照要求设计好的游戏那的确切的计算序列。

## 算法的特性

- 输入
- 输出
- 有穷性
- 确定性
- 可行性

## 算法的设计目标

- 正确性
- 可读性
- 健壮性
- 高效率与低存储量需求



## 算法复杂度分析

​		算法是研究以更少算力更少空间来解决问题的学科，其中算力以运行时间来衡量，空间以内存占用来衡量。二者随数据规模的增长趋势的数学特征称之为复杂度。

​		复杂度分析在纯粹理论角度，对解法的时空消耗进行估算，大体对时空消耗随数据规模的增长特征做出数量级上的判断，对解法的算力和内存需求进行性能判断。

​		复杂度分析的主要方法：

- 迭代：级数求和
- 递归：递归跟踪+递推方程
- 猜测+验证

### 大O表示法

1.  设每行基本语句的执行时间为一致的单位时间 unit_time

2.  那么解法的时间消耗为```T(n) = unit_time * f(n)```

    >   f(n) 是计算解法为得到解所需要执行的所有基本语句量
    >
    >   ```c++
    >   int cal(int n) {
    >      int sum = 0;		// 1
    >      int i = 1, j = 1;	//  1
    >      for (; i <= n; ++i) {		 // n
    >          j = 1;				    // n
    >          for (; j <= n; ++j)       // n*n
    >              sum = sum +  i * j;   // n*n
    >      }
    >   }
    >   ```
    >
    >   `f(n) = 2*n*n + 2*n + 2 = 2n²+2n+2`

3.  如果不关心具体的时间消耗到底是多少，只关心需要执行的基本语句量与时间消耗的渐进关系：```T(n) = O(f(n))```

    >   O(N) 渐近时间复杂度， 表示解法的时间消耗随数据规模（所需执行基本语句量）的变化趋势。

4.  对于复杂度的估算，只关心随语句量增长最大的数学特征，即数学量级最高的数学表征：``O(f(n)) = O(2n²+2n+2)≈O(n²)``

    >   需要注意：
    >
    >   1.  加法原则：总复杂等于量级最大的那段代码的复杂度
    >
    >       `T(n) = T1(n) + T2(n) = max(O(fn), O(g(n))) = O(max(f(n), g(n)))`
    >
    >       一个解法的复杂度等于量级最大的子解法的时间复杂度
    >
    >   
    >
    >       ```c++
    >               
    >       int cal(int n) {
    >          int sum_1 = 0;
    >          int p = 1;
    >          for (; p < 100; ++p) {
    >            sum_1 = sum_1 + p;
    >          }
    >               
    >          int sum_2 = 0;
    >          int q = 1;
    >          for (; q < n; ++q) {
    >            sum_2 = sum_2 + q;
    >          }
    >               
    >          int sum_3 = 0;
    >          int i = 1;
    >          int j = 1;
    >          for (; i <= n; ++i) {
    >            j = 1; 
    >            for (; j <= n; ++j) {
    >              sum_3 = sum_3 +  i * j;
    >            }
    >          }
    >               
    >          return sum_1 + sum_2 + sum_3;
    >        }
    >       ```
    >               
    >        `T(n) = T1(n) + T2(n) + T3(n) ≈ O(1) + O(n) + O(n²) ≈ O(n²) `
    >
    >   2.  乘法法则：嵌套块中的复杂度等于嵌套内外代码复杂度的乘积
    >
    >   `T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))`
    >
    >   ```c++
    >   int f(int n) {		// T1(n) = O(f(n)) = O(2n + 2) ≈ O(n)
    >       int sum = 0;
    >       int i = 1;
    >       for (; i < n; ++i) {
    >           sum = sum + i;
    >       } 
    >       return sum;
    >   }
    >   
    >   int cal(int n) {    // T2(n) = O(g(n)) = O(2n + 2)
    >       int ret = 0; 
    >       int i = 1;
    >       for (; i < n; ++i) {
    >           ret = ret + f(i);
    >       } 
    >   } 
    >   ```
    >
    >   `T(n) = T1(n) * T2(n) ≈ O(n)* O(n) = O(n²)  `




### 常见复杂度

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/20210310171634.jpeg)

`O(2^n)`和`O(n!)`成为非多项式量级（NP），其余为多项式量级（P）。

当数据规模增长时，NP算法的时间复杂度会急剧增加，

#### O(1)

只要算法中不存在循环语句、递归语句、跳转语句，即顺序语句的行数再多，时间复杂度也是O(1)。

#### O(logn) / O(nlogn)

非常常见又最难分析。

```c++
i = 1;
while ( i <= n ) {
	i *= 2;
}

// cnt   1  2   3       k      x
// i     2 2*2  2*2*2  2^k    2^x  = n
// 即执行次数cnt 的最终值x = log2n
```

对于对数的底，可以通过换底公式都换成以2为底n的对数。所以在对数阶时间复杂度的表示方法里，忽略对数的底的影响，统一表示为`O(logn)`.

对于`O(logn)`的子解法，需要重复n此才能最终求解，则该解法的复杂度通过乘法法则可知为`O(nlogn)`.这是一种常见的复杂度量级，比如归并排序，快速排序。

#### O(m+n)、O(m*n)

决定复杂度的不止一个数据维度。

```c++
int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++i) {
        sum_1 = sum_1 + i;
    }

    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
        sum_2 = sum_2 + j;
    }

    return sum_1 + sum_2;
}
```

无法在解法设计时确知m和n的量级大小关系，所以不能简单的使用加法法则，省略掉较小的一个。所以复杂度即为`O(m+n)`.

但是乘法法则继续有效。



#### 时间复杂度

```c++
// n表示数组array的长度
int find(int array[], int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```

​		该代码，在查找到相应的元素后会跳出循环结束任务。那么并不是每次执行该解法所执行的代码量是不定的，最好的情况是要查找的元素在数组首元素，那么时间复杂度就是`O(1)`，但最坏情况下数组中不存在待查元素，那么时间复杂度就是`O(n)`。

##### 最好/最坏情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这个解法的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这个解法的时间复杂度。

##### 平均情况时间复杂度

最好情况时间复杂度和最坏情况时间复杂度都是极端假设下的复杂度，发生的概率并不大。平均情况时间复杂度则能更均衡的表征解法的整体复杂度水平。

需要考虑解法的整体加权平均值（期望）。

比如待查数据在不在数组中的概率为½， 在数组中时，每个位置上出现的概率为1/2，那么全概率为：

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/20210311145527.jpeg)

通常无需区分如上三种情况，因为大致量级都是一样的。只有当同一解法在不同情况下，时间复杂度有量级的差距，才会用这三种复杂度来区分。

##### 均摊时间复杂度

```c++
// array表示一个长度为n的数组
// 代码中的array.length就等于n
int array[] = new int[n];
int count = 0;

void insert(int val) {
    if (count == array.length) {
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }

    array[count] = val;
    ++count;
}
```

![image-20210311161107548](https://gitee.com/masstsing/picgo-picserver/raw/master/20210311161107.png)

平均时间复杂度在极端假设下复杂度才为`O(1)`，只有这种场景下，个别情况下复杂度才比较高为`O(n)`。并且高复杂度的子解法出现的频率是规律的，而且有一定的前后时序关系，一般是在一个高复杂度解法之后跟着一组低复杂度的操作，循环往复。

那么，可以将高复杂度的个别子解法的时间消耗均摊在一组低复杂度的每个操作上。在能够应用均摊时间复杂度的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

均摊时间复杂度就是一种特化的平均时间复杂度。

```c++
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
    if (i >= len) { // 数组空间不够了
        // 重新申请一个2倍大小的数组空间
        int new_array[] = new int[len*2];
        // 把原来array数组中的数据依次copy到new_array
        for (int j = 0; j < len; ++j) {
            new_array[j] = array[j];
        }
        // new_array复制给array，array现在大小就是2倍len了
        array = new_array;
        len = 2 * len;
    }
    // 将element放到下标为i的位置，下标i加一
    array[i] = element;
    ++i;
}
```



#### 空间复杂度

空间复杂度一般指渐进空间复杂度，表示解法需要的存储空间与数据规模之间的增长关系。

常见的空间复杂度为`O(1), O(n), O(n²)`.空间复杂度分析比时间复杂度分析简单一些。





#### 如何进行复杂度分析？

2.复杂度分析法则 

1）单段代码看高频：比如循环。

 2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。

 3）嵌套代码求乘积：比如递归、多重循环等 

4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 

#### 常用的复杂度级别？

​		多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括， O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶） 

​		非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括， O(2^n)（指数阶）、O(n!)（阶乘阶） 五、如何掌握好复杂度分析方法？ 复杂度分析关键在于多练，所谓孰能生巧。



#### 封底估算













## 算法策略

### 蛮力（枚举）

### 贪心

### 减而治之

​	![image-20220821175500752](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821175500752.png)

### 分而治之

![image-20220821180237994](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821180237994.png)

![image-20220821180305296](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821180305296.png)



## 迭代与递归

​		程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。

​	 虽然从计算角度看，迭代与递归可以得到相同的结果，**但它们代表了两种完全不同的思考和解决问题的范式**。

- **迭代**：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
- **递归**：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

​		以求和函数为例，设问题 ` f(n)=1+2+⋯+n `。

- **迭代**：在循环中模拟求和过程，从` 1` 遍历到` n` ，每轮执行求和操作，即可求得 `f(n)` 。
- **递归**：将问题分解为子问题` f(n)=n+f(n−1) `，不断（递归地）分解下去，直至基本情况`f(1)=1` 时终止。

### 迭代分析

​		「迭代 iteration」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。



### 递归

​		「递归 recursion」是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

​		 从实现的角度看，递归代码主要包含三个要素。

1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

​		递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。
- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。

​		有趣的是，**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为「尾递归 tail recursion」。

- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。

- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

  >​		请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。

```cpp
/* 递归 */
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    // 递：递归调用
    int res = recur(n - 1);
    // 归：返回结果
    return n + res;
}

/* 尾递归 */
int tailRecur(int n, int res) {
    // 终止条件
    if (n == 0)
        return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
```

​		对比普通递归和尾递归，两者的求和操作的执行点是不同的。

- **普通递归**：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
- **尾递归**：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。

![image-20231203224216739](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20231203224216739.png)

### 递归树

​		当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。

​		以“斐波那契数列”为例。

```cpp
/* 斐波那契数列：递归 */
int fib(int n) {
    // 终止条件 f(1) = 0, f(2) = 1
    if (n == 1 || n == 2)
        return n - 1;
    // 递归调用 f(n) = f(n-1) + f(n-2)
    int res = fib(n - 1) + fib(n - 2);
    // 返回结果 f(n)
    return res;
}
```

​		在函数内递归调用了两个函数，**这意味着从一个调用产生了两个调用分支**。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n的「递归树 recursion tree」。

![image-20231203224903670](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20231203224903670.png)

​		从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。

### 对比

​		总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。

​			表 2-1  迭代与递归特点对比

|          | 迭代                                   | 递归                                                         |
| :------- | :------------------------------------- | :----------------------------------------------------------- |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

​		迭代和递归具有什么内在联系呢？以上述的递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，**这种工作机制与栈的“先入后出”原则是异曲同工的**。

事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。

1. **递**：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。
2. **归**：当函数完成执行并返回时，对应的栈帧会从“调用栈”上被移除，恢复之前函数的执行环境。

因此，**我们可以使用一个显式的栈来模拟调用栈的行为**，从而将递归转化为迭代形式：

```cpp
/* 使用迭代模拟递归 */
int forLoopRecur(int n) {
    // 使用一个显式的栈来模拟系统调用栈
    stack<int> stack;
    int res = 0;
    // 递：递归调用
    for (int i = n; i > 0; i--) {
        // 通过“入栈操作”模拟“递”
        stack.push(i);
    }
    // 归：返回结果
    while (!stack.empty()) {
        // 通过“出栈操作”模拟“归”
        res += stack.top();
        stack.pop();
    }
    // res = 1+2+3+...+n
    return res;
}
```



​		当递归被转换为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转换，但也不一定值得这样做，有以下两点原因。

- 转化后的代码可能更加难以理解，可读性更差。
- 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。

总之，**选择迭代还是递归取决于特定问题的性质**。在编程实践中，权衡两者的优劣并根据情境选择合适的方法是至关重要的。

## 算法设计

### 递归

​		递归使用减而治之、分而治之的策略，应用递归跟踪、递推分析的手段来分析问题。

#### 递归跟踪

![image-20220821175906458](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821175906458.png)

![image-20220821175928237](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821175928237.png)

#### 递推分析

![image-20220821180141402](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821180141402.png)

![image-20220821180159925](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220821180159925.png)



### 迭代

#### memoization 记忆算法

​		将已计算过的实例的结果制表备查。

####  Dynamic programming 动态规划

​		将递归分析自顶而下分化求解的思路，颠倒为自底向上迭代求解。

​		从初始状态开始，依赖上一状态求解下一状态。
