

# 并发模型

---

## 多进程

​		多进程为每个连接的`socket`开辟一个子进程，用于持续处理该`socket`上的数据收发。

### 进程

​		进程是拥有独立虚拟地址空间的程序运行单元。

### 子进程

​		子进程是独立运行的父进程副本，在创建子进程之后，两个进程各自独立运行。依据进程ID可以使用同一代码段进行不同的操作。

```c++
#include <unistd.h>
pid_t fork(void); // return ID / -1
```

- 父进程中，`fork`得到子进程id
- 子进程可以通过系统调用获取父进程id，因此`fork`返回`0`



### 僵尸进程

​		多进程服务器容易产生的问题之一是，处理客户连接的子进程销毁后，父进程如果不及时处理回收子进程的资源，就会产生僵尸进程。

```c++
#include <sys/wait.h>

pid_t wait(int* statloc); // return child pid / -1
// WIFEXITED(statloc) 子进程正常终止返回 true
// WEXITSTATUS 返回子进程的返回值

wait(&status);
if(WIFEXITED(status))
    printf("%d\n", WEXITSTATUS(status));
```

​		`wait`会引起程序阻塞，可以使用`waitpid`

```c++
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* statloc, int options); // return child pid / -1
// pid，要处理的进程pid，传递-1与`wait`相同，等待任意子进程终止
// options
//		WNOHANG, 没有终止的子进程也不会阻塞，返回0

pid_t pid=fork();
if(pid = 0) {
	sleep(15); return 24;
} else {
    while(!waitpid(-1, &status, WNOHANG)) {
        sleep(3); puts("sleep 3sec...");
    }
    
    if(WIFEXITED(status))
        printf("Child send %d\n", WEXITSTATUS(status));
}
```



![image-20210914221544401](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210914221544401.png)

​		父进程持续检测子进程的退出同样是一种`loop`，造成父进程其他功能受阻。解决方案是通过信号：捕获`SIGCHLD`信号并处理（可忽略）。 

> ```c++
> #include <signal.h>
> 
> typedef void (*sighandler_t)(int);
> 
> sighandler_t signal(int signum, sighandler_t handler);
> ```

```c++
#include <signal.h> 

// ignore
signal(SIGCHLD, SIG_IGN);
sigignore(SIGCHLD);

// handle
void handle_chld( int sig ) {
	wait( NULL );// waiting for signal triggle.
	// do nothing == ignore
}
signal(SIGCHLD, handle_sigchld);
```



![image-20210914224724095](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210914224724095.png)

> 当并发关闭连接时，使用wait 只会处理第一个信号，其他并发到达的信号会被丢弃。
>
> waitpid会依据到达的时机，如果不分先后的并行到达，即处理的时刻只会处理1个，但是稍有先后的情况下，会依据处理完成接着处理的逻辑能处理几个就处理几个。
>
> ```c
> #include <sys/types.h>
> #include <sys/wait.h>
> 
> pid_t wait(int *status);
> 
> pid_t waitpid(pid_t pid, int *status, int options);
> 
> int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
> 
> // wait只等待第一个信号，后续的信号都不做处理
> // waitpid 会等待对应pid
> ```
>
> ![image-20210914225543193](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210914225543193.png)
>
> ![image-20210914225632918](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210914225632918.png)
>
> 解决：
>
> ```c
> void handle_chld( int sig )
> {
> #if 0
> wait( NULL );// waiting for signal triggle.
> #elif 0
> waitpid( -1, NULL, WNOHANG );
> #else
> while ( waitpid( -1, NULL, WNOHANG ) > 0 );
> #endif
> // do nothing == ignore
> }
> ```
>
> **example:**
>
> ```c
> /*
>  * @Author: Mass 
>  * @Date: 2021-09-11 13:19:19 
>  * @Last Modified by: Mass
>  * @Last Modified time: 2021-09-12 23:17:04
>  *
>  *      gcc echo_server_v5_rear_flag.c ../common/utils.c -o echo_server_v5_rear_flag
>  */
> 
> #include "../common/basedef.h"
> #include "../common/utils.h"
> 
> #include <sys/socket.h>
> #include <netinet/in.h>
> #include <arpa/inet.h>
> #include <strings.h>
> #include <string.h>
> #include <unistd.h>
> #include <signal.h>   // for signal
> #include <sys/wait.h> // for wait
> 
>     void handle_chld( int sig )
>     {
> #if 0
>         wait( NULL );// waiting for signal triggle.
> #elif 0
>         waitpid( -1, NULL, WNOHANG );
> #else
>         while ( waitpid( -1, NULL, WNOHANG ) > 0 );
> #endif
>         // do nothing == ignore
>     }
> 
> 
> void do_service( int conn_fd )
> {
>     char recv_buf[ 1024 ];
>     int ret = { 0 };
>     while ( 1 ) {
>         bzero( recv_buf, sizeof( recv_buf ) );
>         ret = readline( conn_fd, recv_buf, sizeof( recv_buf ) );
>         if ( ret == 0 ) {// connection close
>             printf( "client %d close\n", conn_fd );
>             break;
>         } else if ( ret == -1 ) {
>             ERR_EXIT( "readline" );
>         }
> 
>         fputs( recv_buf, stdout );
>         writen( conn_fd, recv_buf, ret );
>     }
>     close( conn_fd );
> }
> 
> int main( void )
> {
> 
>     //* handle defunct process.
>     // ignore signal
>     //signal( SIGCHLD, SIG_IGN );
>     //sigignore( SIGCHLD );
>     // handle signal
>     signal( SIGCHLD, handle_chld );
> 
> 
>     int listen_fd;
>     // socket( PF_INET, SOCK_STREAM, 0 )
>     if ( ( listen_fd = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP ) ) < 0 )
>         ERR_EXIT( "socket" );
> 
>     int on = 1;
>     setsockopt( listen_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof( on ) );
> 
>     struct sockaddr_in srvaddr = {
>         .sin_family = AF_INET,
>         .sin_port = htons( 5288 ),
>         .sin_addr = {
>             .s_addr = inet_addr( "127.0.0.1" )
>             // .s_addr = htonl( "127.0.0.1" );
>         }
>     };
>     //inet_aton( "127.0.0.1", srvaddr.sin_addr );
>     if ( bind( listen_fd, (struct sockaddr *) &srvaddr, sizeof( srvaddr ) ) < 0 )
>         ERR_EXIT( "bind" );
> 
>     if ( listen( listen_fd, SOMAXCONN ) )
>         ERR_EXIT( "listen" );
> 
> 
>     int conn_fd;
>     int pid;
>     struct sockaddr_in peer_addr;
>     socklen_t peer_addr_len = sizeof( peer_addr );
> 
>     while ( 1 ) {
>         if ( ( conn_fd = accept( listen_fd, (struct sockaddr *) &peer_addr, &peer_addr_len ) ) < 0 )
>             ERR_EXIT( "accept" );
> 
>         printf( "peer ip: %s, port: %d, fd : %d\n", inet_ntoa( peer_addr.sin_addr ), ntohs( peer_addr.sin_port ), conn_fd );
> 
>         pid = fork();
>         if ( pid == -1 )
>             ERR_EXIT( "fork" );
> 
>         if ( pid == 0 ) { // child process
>             close( listen_fd );
>             do_service( conn_fd );
>             exit( EXIT_SUCCESS ); // 子进程自行退出，否则下一个循环回到父进程的代码逻辑上，
>                                   //    accept 并 fork进程，从而造成进程分裂
>         } else { // father process
>             close( conn_fd );
>         }
>     }
> 
>     close( listen_fd );
> 
>     return 0;
> }
> ```
>
> 







### multi-process-for-connection echo_server

​		一个连接用一个子进程来处理。

```c
#include "../common/basedef.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <strings.h>
#include <string.h>
#include <unistd.h>

void do_service( int conn_fd )
{
    char recv_buf[ 1024 ];
    int ret = { 0 };
    while ( 1 ) {
        bzero( recv_buf, sizeof( recv_buf ) );
        ret = read( conn_fd, recv_buf, sizeof( recv_buf ) ); // 向read传递应用缓冲区的大小
        if ( ret == 0 ) {// connection close
            printf( "client %d close\n", conn_fd );
            break;
        } else if ( ret == -1 ) {
            ERR_EXIT( "read" );
        }

        fputs( recv_buf, stdout );
        write( conn_fd, recv_buf, ret ); 
    }
    close( conn_fd );
}

int main( void )
{
    int listen_fd;
    // socket( PF_INET, SOCK_STREAM, 0 )
    if ( ( listen_fd = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP ) ) < 0 ) 
        ERR_EXIT( "socket" );

    int on = 1;
    setsockopt( listen_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof( on ) );

    struct sockaddr_in srvaddr = {
        .sin_family = AF_INET,
        .sin_port = htons( 5288 ),
        .sin_addr = {
            .s_addr = inet_addr( "127.0.0.1" )
            // .s_addr = htonl( "127.0.0.1" );
        }
    };
    //inet_aton( "127.0.0.1", srvaddr.sin_addr );
    if ( bind( listen_fd, (struct sockaddr *) &srvaddr, sizeof( srvaddr ) ) < 0 )
        ERR_EXIT( "bind" );

    if ( listen(listen_fd, SOMAXCONN))
        ERR_EXIT( "listen" );


    int conn_fd;
    int pid;
    struct sockaddr_in peer_addr;
    socklen_t peer_addr_len = sizeof( socklen_t );

    while ( 1 ) {
        if ( ( conn_fd = accept( listen_fd, (struct sockaddr *) &peer_addr, &peer_addr_len ) ) < 0 )
            ERR_EXIT( "accept" );

        printf( "peer ip: %s, port: %d, fd : %d\n", inet_ntoa( peer_addr.sin_addr ), ntohs( peer_addr.sin_port ), conn_fd );

        pid = fork();
        if ( pid == -1 )
            ERR_EXIT( "fork" );

        if ( pid == 0 ) { // child process
            close( listen_fd );
            do_service( conn_fd );
            exit( EXIT_SUCCESS ); // 子进程自行退出，否则下一个循环回到父进程的代码逻辑上，
                                  //    accept 并 fork进程，从而造成进程分裂
        } else { // father process
            close(conn_fd );
        }
    }
    close( listen_fd );
    return 0;
}
```



### peer-peer chat

```c
// s2c_chat_server.c
/*
 * @Author: Mass 
 * @Date: 2021-09-07 18:32:33 
 * @Last Modified by: Mass
 * @Last Modified time: 2021-09-07 19:24:58
 *
 *      client chat with server .
 */


#include "../common/basedef.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <strings.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

void quit_handler( int sig )
{
    printf( "child quit.\n" );
    
    exit( EXIT_SUCCESS );
}

int main( void )
{
    int listen_fd;
    // socket( PF_INET, SOCK_STREAM, 0 )
    if ( ( listen_fd = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP ) ) < 0 )
        ERR_EXIT( "socket" );

    int on = 1;
    setsockopt( listen_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof( on ) );

    struct sockaddr_in srvaddr = {
        .sin_family = AF_INET,
        .sin_port = htons( 5288 ),
        .sin_addr = {
            .s_addr = inet_addr( "127.0.0.1" )
            // .s_addr = htonl( "127.0.0.1" );
        }
    };
    //inet_aton( "127.0.0.1", srvaddr.sin_addr );
    if ( bind( listen_fd, (struct sockaddr *) &srvaddr, sizeof( srvaddr ) ) < 0 )
        ERR_EXIT( "bind" );

    if ( listen( listen_fd, SOMAXCONN ) )
        ERR_EXIT( "listen" );


    int conn_fd;
    struct sockaddr_in peer_addr;
    socklen_t peer_addr_len = sizeof( socklen_t );
    if ( ( conn_fd = accept( listen_fd, (struct sockaddr *) &peer_addr, &peer_addr_len ) ) < 0 )
        ERR_EXIT( "accept" );

    printf( "peer ip: %s, port: %d\n", inet_ntoa( peer_addr.sin_addr ), ntohs( peer_addr.sin_port ) );

    pid_t pid = fork();
    if ( pid == -1 ) { // fork err
        ERR_EXIT( "fork" );
    } else if ( pid == 0 ) { // child process
        // send data
        char sendbuf[ 1024 ] = { 0 };

        signal( SIGUSR1, quit_handler ); // 等待父进程通知退出

        while ( fgets( sendbuf, 1024, stdin ) != NULL ) {
            write( conn_fd, sendbuf, strlen( sendbuf ) );
            bzero( sendbuf, sizeof( sendbuf ) );
        }
    } else { // father process
        // receive data
        char recv_buf[ 1024 ];
        while ( 1 ) {
            bzero( recv_buf, sizeof( recv_buf ) );
            int ret = read( conn_fd, recv_buf, sizeof( recv_buf ) ); // 向read传递应用缓冲区的大小
            if ( ret == -1 )
                ERR_EXIT( "read" );
            else if ( ret == 0 ) {
                printf( "client close\n" );
                break;
            }
            
            fputs( recv_buf, stdout );
        }
        printf( "father quit.\n" );
        kill( pid, SIGUSR1 ); // 通知子进程退出
    }

    close( conn_fd );
    close( listen_fd );
}
```

```c
//s2c_chat_client.c

#include "../common/basedef.h"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <strings.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

void quit_handler( int sig )
{
    printf( "child quit.\n" );
    exit( EXIT_SUCCESS );
}

int main( void )
{
    int conn_fd;
    // socket( PF_INET, SOCK_STREAM, 0 )
    if ( ( conn_fd = socket( PF_INET, SOCK_STREAM, IPPROTO_TCP ) ) < 0 )
        ERR_EXIT( "socket" );

    struct sockaddr_in srvaddr = {
        .sin_family = AF_INET,
        .sin_port = htons( 5288 ),
        .sin_addr = {
            .s_addr = inet_addr( "127.0.0.1" )
            // .s_addr = htonl( "127.0.0.1" );
        }
    };
    if ( ( connect( conn_fd, (struct sockaddr *) &srvaddr, sizeof(srvaddr) ) ) < 0 )
        ERR_EXIT( "connect" );

    pid_t pid = fork();
    if ( pid == -1 ) { // fork err
        ERR_EXIT( "fork" );
    } else if ( pid == 0 ) { // child process
        // send data
        char sendbuf[ 1024 ] = { 0 };

        signal( SIGUSR1, quit_handler ); // 等待父进程通知退出

        while ( fgets( sendbuf, 1024, stdin ) != NULL ) {
            write( conn_fd, sendbuf, strlen( sendbuf ) );
            bzero( sendbuf, sizeof( sendbuf ) );
        }
    } else { // father process
        // receive data
        char recv_buf[ 1024 ];
        while ( 1 ) {
            bzero( recv_buf, sizeof( recv_buf ) );
            int ret = read( conn_fd, recv_buf, sizeof( recv_buf ) ); // 向read传递应用缓冲区的大小
            if ( ret == -1 )
                ERR_EXIT( "read" );
            else if ( ret == 0 ) {
                printf( "server %d close");
                break;
            }
            
            fputs( recv_buf, stdout );
        }
        printf( "father quit.\n" );
        kill( pid, SIGUSR1 ); // 通知子进程退出
    }

    close( conn_fd );

    return 0;
}
```



## 多线程



## 协程



## I/O多路复用

​		上述利用并发机制来处理多个`socket`的本质，都是利用一种独立处理的机制
