

# TCP

​		可靠有连接的流式传输协议。

---

- 基于字节流	

  对于segment数据段的边界不做任何标定。一次发送或接收可能处理 一个以上或以下的包，这就可能造成粘包问题，需要在应用层处理。

- 面向连接

- 可靠传输

- 缓冲传输

- 全双工

  发送和接收可以同时进行

- 流量控制

## 报文格式

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/20180324113628122)

> [TCP（传输控制协议详解）详解_谁也不知道会怎样的博客-CSDN博客_tcp协议](https://blog.csdn.net/weixin_41191846/article/details/79676110/)
>
> [【TCP协议】（1）---TCP协议详解 - 雨点的名字 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qdhxhz/p/10267932.html)
>
> [TCP协议、算法和原理 - sarah_linux - 博客园 (cnblogs.com)](https://www.cnblogs.com/linuxprobe-sarah/p/10634626.html)

> - 源端口号与目的端口号
>
>   各16位，共32位，两个端口号加上各自IP头部中的两个IP地址，唯一确定一个TCP连接，称为四元组。
>
> - 序号
>
>   32位，序号表示在这个报文段中的第一个数据字节序号。
>
> - 确认号
>
>   32位，仅当ACK标志为1时有效，表示期望收到的下一个字节的序号
>
> - 头部长度（数据偏移)
>
>   4位，tcp头部最多60个字节。
>
> - 保留位
>
>   6位，必须为0
>
> - 6个标志位
>
>   6位，
>
>   - URG，紧急指针有效
>   - ACK，缺人序号有效
>   - PSH，接收方应尽快将这个报文段交给应用层
>   - RST，连接重置
>   - SYN，同步序号用来发起一个连接
>   - FIN，表示将要终止一个连接
>
> - 窗口大小
>
>   16位，通过窗口大小来达到流量控制
>
> - 校验和
>
>   16位，对tcp头域数据进行忘记校验和，不保证完备校验
>
> - 紧急指针
>
>   16位，是一个正的偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
>
> - 选项与填充
>
>   4字节的整数倍，不足用0填充。
>
>   最常见的可选字段是最长报文大小MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段中指明这个选项。它指明本段所能接收的最大长度的报文段。该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）。MSS一般不会大于MTU。 
>
>   > 默认情况下，应用层TCP数据包的大小超过536个字节会导致分片，所以通常应用层的缓冲区最大取512字节。



## TCP状态流转

### 三次握手

![img](https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png)

> 建立连接的过程
>
> 1. TCP B，`socket()`创建tcp套接字，为`CLOSED`
>
> 2. TCP B,   `bind()` 将套接字绑定到端口上，为`CLOSED`
>
> 3. TCP B， `listen()` 将套接字设置为被动套接字，监听连接，为`LISTEN`
>
> 4. TCP B， `accept()` 阻塞等待对端连接，为`LISTEN`
>
> 5. TCP A，`socket()`创建TCP 套接字，为`CLOSED`
>
> 6. TCP A， `connect()` 主动连接对端，阻塞等待连接成功或失败后返回， 为`SYN_SENT`
>
>    1. 主动连接对端，通过向对端发送同步请求`SYN`分节，假设分节荷载值为`a`
>
>    >   如果服务器端不能连接，直接进入CLOSED状态
>
> 7. TCP B， `accept()` 接收到``SYN``，连接请求到达，为`SYN_RCVD`
>
>    1. 此阶段为内核协议栈处理
>    2. 将该请求对应的fd加入未连接队列
>    3. 接收到请求到达后，确认同步请求`a`，响应`ACK`分节，荷载值为`a+1`
>    4. 同时设置`SYN`分节，假设荷载值为`b`
>
>    >   当A发送SYN的同事也收到了对端的SYN，即两端同事发起连接请求，那么 A 会从`SYN_SENT`转换为`SYN_RCVD`
>
> 8. TCP A，  `connect()` 接收到连接响应，为`ESTABLISHED`
>
>    1. `connect()` 确认同步请求`b`，响应`ACK`分节，荷载值为`b+1`
>    2. `connect()` 从内核协议栈返回用户态应用程序
>
> 9. TCP B， `accept()` 接收到连接响应，为`ESTABLISHED`
>
>    1. 将连接对应的fd从未连接队列中取出放入已连接队列
>    2. `accept(）` 从内核协议栈返回用户态应用程序，向用户态应用程序返回已连接队列队头第一个热连接

> 连接存续期间，双方状态始终为`ESTABLISHED`

### 四次挥手

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/f34823ce42a49e4eadaf642a75d14de1.png)

> 断开连接的过程
>
> 1. TCP A， `close()` 关闭tcp套接字，为`FIN_WAIT_1`
>
>    1. 向对端发送连接结束请求`FIN`分节，假设荷载值为`x`
>    2. 同时设置`ACK`分节，假设荷载值为`y`
> 2. TCP B， `read()`返回`0`， 为`CLOSE_WAIT`
>
>    1. 内核协议栈向对端发送`ACK`分节，荷载值为`x+1`
> 3. TCP A，  收到对端`read()`后经内核协议栈返回的`ACK`分节后，为`FIN_WAIT_2`
>    1. read() 返回`EOF`
> 4. TCP B，  `close()` 关闭tcp套接字，为`LAST_ACK`
>
>    1. 内核协议栈处理
>    2. 向对端发送`ACK`分节，荷载值为`x+1`
>    3. 同时设置`FIN`分节，假设荷载值为`y`
> 5. TCP A， 收到对端`close`后经内核协议栈返回的`FIN`和`ACK`分节后，为`TIME_WAIT`
>
>    1. 内核协议栈向对端发送 `ACK`分节，荷载值为`y+1`
>
>    2. `TIME_WAIT`状态保持 2 MSL时间（MSL是tcp段的最大生存时间）后置为`CLOSED`状态
> 6. TCP B， 收到`ACK`分节后，为`CLOSED`

### TIME_WAIT

​		服务器上对于每个客户端的连接会占用一个本地端口来进行交互，在并发较高的情况下，`TIME_WAIT`状态的连接过多，会将服务器操作系统提供的端口耗尽，不能对外提供可靠的服务。并经过一段时间可以恢复。

​		`TIME_WAIT`状态持续时间是固定的，是最长分节生命期MSL（maximum segment lifetime）的两倍，称为2MSL。这个值在linux上是硬编码在系统内核中的，名称为`TCP_TIMEWAIT_LEN`，值为60s。

```c
#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-        WAIT state, about 60 seconds  */
```

> `TIME_WAIT`状态只会由断连发起的一端产生。

​		过多的TIME_WAIT连接

- 占用内存资源，可以忽略
- 对端口资源的占用，一个TCP连接至少消耗一个本地端口，端口总数一般为6w左右。如果TIME_WAIT状态过多，会导致无法创建新连接。

#### TIME_WAIT的原因

因四次挥手主动发起而产生。无论是客户端还是服务器端，只要主动发起断开，必然会经过TIME_WAIT过程。

> 客户端套接字的端口号是任意指定的，客户端动态分配端口资源，并且不需要提供大量的端口以供连接。所以不用考虑客户端TIME_WAIT带来的影响。

#### TIME_WAIT 的作用

- 确保最后的ACK能够被被动方接收，帮助其正常关闭连接。

  ​		TCP的容错性设计，假设TCP报文会丢失，需要重传。这里如果最后的ACK没能被被动方正确接收，被动方会重发FIN报文。如果断连发起方没有`TIME_WAIT`状态，直接进入CLOSED状态，就失去了当前连接状态的上下文，只能回复一个RST，从而导致被动关闭防出现错误。

- 连接化身和迷途分节

  ​		在网络中，经常会发生报文经过一段时间才能到达目的地的情况（迷途分节），产生的原因是多种多样的，如路由器重启，链路突然出现故障等。在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。

  ​		 在关闭一个TCP连接后，马上又重新建立起一个相同连接四元组的TCP连接，后一个连接被称为前一个连接的化身（incarnation)。

  ​		那么有可能出现这种情况，前一个连接的迷途分节在前一个连接终止后到达对端，从而被误解成从属于新的连接化身。就会对TCP通信产生影响。



​		综上，经过``2MSL``， 可以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新的连接化身所产生的。

2MSL 的时间是从断连发起方接收到 FIN 后发送 ACK 开始计时的。

如果在 TIME_WAIT 时间内，因为断连发起方的 ACK 没有传输到被动方，断连发起方 又接收到了被动方 重发的 FIN 报文，那么 2MSL 时间将重新计时。

> ​		因为 2MSL 的时间，目的是为了让旧连接的所有报文都能自然消亡，现在主机 1 重新发送了 ACK 报文，自然需要重新计时，以便防止这个 ACK 报文对新可能的连接化身造成干扰。

#### TIME_WAIT的解决方案

- 监听套接字

> **`TIME_WAIT`会导致对端无法重新启动，此时可以通过`SO_REUSEADDR`来解决**
>
> 即使TIME_WAIT状态的端口，也可以继续使用它做为新的套集字使用。

- 连接套接字

  - net.ipv4.tcp_max_tw_buckets

    通过 sysctl 命令，将系统值调小。这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

  - 调低 TCP_TIMEWAIT_LEN，重新编译系统

    需要“一点”内核方面的知识，能够重新编译内核。

  - SO_LINGER

    ​		“linger”的意思为停留，我们可以通过设置套接字选项，来设置调用 close 或者 shutdown 关闭连接时的行为。

    ​		如果l_onoff为非 0， 且l_linger值也为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。

    ​		这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在recv()调用上时，接受到 RST 时，会立刻得到一个“connet reset by peer”的异常。

    ​		为跨越 TIME_WAIT 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。

  - net.ipv4.tcp_tw_reuse：更安全的设置

    > ​		Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technical experts.

    如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用:

    - 只适用于连接发起方（C/S 模型中的客户端）；
    - 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。

    需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）。

    > ​		TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

### CLOSING

​	 当两端同时``close()``时，与上述挥手状态不同。

![image-20210915224723889](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210915224723889.png)



### CLOSE_WAIT

​		主动发起`close`的一方发送`FIN`包给被动接收方，被动接收方收到`FIN`后进入`CLOSE_WAIT`状态。但服务器没有正确的调用`close / shutdown`关闭连接。

​		解决方法基本的思想就是要检测出对方已经关闭的socket，然后关闭它。

 1.代码需要判断socket，一旦read返回0，断开连接，read返回负，检查一下errno，如果不是AGAIN，也断开连接。(注:在UNP 7.5节的图7.6中，可以看到使用select能够检测出对方发送了FIN，再根据这条规则就可以处理CLOSE_WAIT的连接)
 2.给每一个socket设置一个时间戳last_update，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个socket。
 3.使用一个Heart-Beat线程，定期向socket发送指定格式的心跳数据包，如果接收到对方的RST报文，说明对方已经关闭了socket，那么我们也关闭这个socket。
 4.设置SO_KEEPALIVE选项，并修改内核参数

https://juejin.cn/post/6963590333993074725

[【网络编程】线上大量CLOSE_WAIT的原因深入分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/493915289)

[大量LAST_ACK分析过程_51CTO博客_LAST_ACK](https://blog.51cto.com/yangsj/1782099)

## 滑动窗口

​		链路层和TCP协议都有滑动窗口作为流量控制的算法，链路层的滑动窗口以帧为单位，TCP滑动窗口以字节为单位。

![image-20210903150326813](https://gitee.com/masstsing/picgo-picserver/raw/master/20210903150327.png)

-   通告接收窗口（rwnd)：

    ​		预防应用程序发送的数据超过对方的缓冲区，接受方使用的流量控制手段

-   拥塞窗口（cwnd)：

    ​		预防应用程序发送的数据超过网络所能承受的能力。发送方使用的流量控制手段

>   发送窗口取两者较小值

-   慢启动阈值（ssthresh: slow start threshold）

-   慢启动阶段

    cwnd从1开始按指数增长知道ssthresh

-   拥塞避免阶段

    cwnd按现行增长，知道拥塞，将cwnd = 1, ssthresh减半

-   快速重传

-   快速恢复

## 可靠性保证

​		何为不可靠及解决方式：

- 差错   -- 校验和
- 失序  --  seq
- 重复  –  seq
- 丢包  –  超时重传+确认

​		应用数据被分隔成TCP认为最适合发送的数据块，成为段传递给IP层

​		当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

​		当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

​		TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到端的校验和有任何差错，TCP将丢弃这个报文段并且不确认（导致对方超时重传）

​		TCP承载与IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达可能会失序。TCP将对收到的数据进行重新排序。

​		IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。

​		TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间（滑动窗口）