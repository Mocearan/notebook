

# TCP

​		可靠有连接的流式传输协议。

---

​		传输控制协议（TCP，Transmission Control Protocol）是一种**面向连接**的、**可靠**的、基于**字节流**的传输层通信协议，由IETF的[**RFC793**](https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc793)定义。

- 基于字节流、缓冲传输

  - 对于segment数据段的边界不做任何标定。
  - 面相缓冲区读写
  - 一次发送或接收可能处理 一个以上或以下的包，这就可能造成粘包问题，需要在应用层处理。

- 面向连接

  - TCP在开始传输数据前要先经历三次握手建立连接

  - 通过连接一对一发送消息

  - 传输结束后通过四次挥手断开连接

- 可靠传输

  - 确认应答、超时重传、流量控制、拥塞控制、有序传输，数据完整性高

- 全双工

  ​	发送和接收可以同时进行

- 流量控制

- 单播



## 参考

[TCP（传输控制协议详解）详解_谁也不知道会怎样的博客-CSDN博客_tcp协议](https://blog.csdn.net/weixin_41191846/article/details/79676110/)

[【TCP协议】（1）---TCP协议详解 - 雨点的名字 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qdhxhz/p/10267932.html)

[TCP协议、算法和原理 - sarah_linux - 博客园 (cnblogs.com)](https://www.cnblogs.com/linuxprobe-sarah/p/10634626.html)



[RFC 793 - Transmission Control Protocol (ietf.org)](https://datatracker.ietf.org/doc/html/rfc793)

[全网最全GB/T 28181网络基础-TCP协议一文全面了解TCP协议，无论是初学者，还是工作中常用TCP协议的老手，都 - 掘金 (juejin.cn)](https://juejin.cn/post/7412502916644077580#heading-4)

## 报文格式

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/20180324113628122)



```
 0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- TCP头部一般20字节。

- **源端口号(Source Port)**（16位->2个字节）：发送端口，范围为0-65535。

- **目的端口号(Destination Port)**（16位->2个字节）：接收端口，范围为0-65535

  > 两个端口号加上各自IP头部中的两个IP地址，唯一确定一个TCP连接，称为四元组。

- **序列号(Sequence Number)**（32位->4个字节）：表示在这个报文段中的第一个数据字节序号。

  - 当序号增加到4294967295后，下一个序号将回到0重新开始。
  - 随机数作为初始值，发送时累加该“数据字节数”的大小
  - 序列号用来解决网络包乱序问题，实现可靠的数据传输和流量控制

- **确认号(Acknowledgment Number)**（32位->4个字节）：仅当ACK标志为1时有效，表示期望收到的下一个字节的序号

  - 一般都是上次接收成功的数据字节序号加1
  - 如果ISN的初始值为X，那么确认号的范围就是[X+1, X+1+N-1]，其中N表示已经成功接收的字节数。
  - 发送端收到确认以后可以认为在这个序号以前的数据都已经被正常接收。

- **数据偏移(Data Offset)**（4位）：指示TCP荷载数据之前的字节数，即TCP头部长度。

  - 字节长度为表示值的4倍
  - 没有选项时该值为5，即20字节
  - 4位能表示的最大整数是15，也就说明TCP报文里数据开始的位置距离报文起点是60个字节(4*15)。

- **保留(Reserved)**（位）：保留供将来使用，目前应设置为零。

- **控制位(Acknowledgment)**（6位）：

  - **URG(Urgent)**（1位）：紧急指针有效，指示报文段中包含紧急数据。

    - 当URG=1时，表明开启了urgent mode，通知接收方在处理数据时要特别注意紧急数据的处理。
    - URG标志位的设置与紧急指针字段(Urgent Pointer)一起使用。

  - **ACK(Acknowledgment)**（1位），确认号有效，仅当ACK=1时确认号字段才有效，当ACK=0时确认号无效。

    - TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。

  - **PSH(Push)**（1位），接收方应尽快将这个报文段交给应用层

    - 接收方应立即将数据推送给应用程序，而不是等待缓冲区填满

    >  有时一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。
    >
    > 接收方TCP收到PSH=1的报文段，就尽快地(即“推送”向前)交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。

  - **RST(Reset)**（1位），连接重置，复位连接，中断当前的通信。

    - 当 RST=1 时，表示 TCP 连接中出现异常(如主机崩溃或其他原因)必须强制断开连接，然后再重新建立连接进行传输。
    - RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。

  - **SYN(Synchronize)**（1位），同步序号用于建立连接，发起连接请求。在连接建立时用来同步序号。

    > 当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。

  - **FIN(Finish)**（1位），表示将要终止一个连接，用于关闭连接，请求终止连接。

    - 当FIN=1时，表示发送方没有数据要传输了，要求释放连接。

- **窗口大小(Window Size)**（16位->2个字节），指示接收方的接收窗口大小，用于流量控制。

  - 最大的窗口大小为2^16-1=65535=64k
  - 这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项字段里加一个窗口扩大选项，来传输更多的数据。
  - 窗口是通知对端本端的接收窗口大小
    - 窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量(以字节为单位)
    - 接收方的数据缓存空间是有限的。防止对端过快的发送数据造成拥塞等待
    - 接收到本报文得到窗口大小，应该设置其发送窗口，以控制发送数据的速度

- **校验和(Checksum)**（16位->2个字节）：奇偶校验，对整个 TCP 报文段（TCP header  + TCP data）。

  - 不保证完备校验
  - 计算方式：把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节。把TCP报头中的校验和字段置为0（否则就陷入鸡生蛋还是蛋生鸡的问题），用反码相加法累加所有的16位字（进位也要累加）。最后，对计算结果取反，作为TCP的校验和。

  > 此外，校验和还包括一个概念上位于TCP头部前的96位（12字节）伪头部。这个伪头部包含了源地址、目的地址、协议类型以及TCP的长度信息。这样的设计给予了TCP保护措施，以防段被错误路由。这部分信息虽然存在于Internet协议中，但通过TCP与网络层（IP）接口间的交互（例如调用时的参数或返回结果），在TCP层面上可访问并用于校验和计算过程。

- **紧急指针(Urgent Pointer)**（16位->2个字节）：只有在`URG`标志位被设置时才有效。指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)。

  - 紧急指针指出了紧急数据的末尾在报文段中的位置。是一个正的偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。
  - 当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。
  - 值得注意的是，即使窗口为0时也可以发送紧急数据。

  16位，

- **选项(Options)**：可选字段，长度可变，最长可达40个字节。选项字段用于提供额外的功能和控制，每个选项的开始是 1 字节的kind字段，说明选项的类型。

  - 当没有使用选项时，TCP的首部长度是20字节。
  - 一些常见的选项举例如下：
    - **最大报文段长度**(Maximum Segment Size, MSS)：占用4字节，通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为(MTU-40)字节，携带TCP报文段的IP数据报的长度就不会超过MTU(MTU最大长度为1518字节，最短为64字节)，从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。
      - 每个连接方通常都在通信的第一个报文段中指明这个选项。它指明本段所能接收的最大长度的报文段。该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）。MSS一般不会大于MTU。 
      - 默认情况下，应用层TCP数据包的大小超过536个字节会导致分片，所以通常应用层的缓冲区最大取512字节。

    - **窗口扩大因子**(Window Scale Factor)：占用3字节，取值0-14。用来把TCP的窗口的值左移的位数，使窗口值乘倍。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区(接收窗口)的长度通常大于65535字节。
    - **时间戳选项**(TCP Timestamps Option, TSopt)：占用10字节，其中最主要的字段是时间戳字段(Timestamp Value field, TSval, 4字节)和时间戳回送回答字段(Timestamp Echo Reply field, TSecr, 4字节)。时间戳选项允许通信的两端在TCP报文段中包含时间戳值，以便进行一些时间相关的操作和计算。
    - **安全摘要选项**(TCP Authentication Option, TCP Option)：用于提供数据完整性和身份验证的功能。该选项用于对TCP报文段进行保护，防止数据篡改和未经授权的访问。

- **填充字段(Padding)**：这个字段中加入额外的零，以保证TCP头是32的整数倍。

  - 4字节的整数倍，不足用0填充。

  

  



## TCP状态流转	

​		所谓连接，实际上是通信双方为通信建立专属的数据收发缓冲，以在此基础上进行一对一的通信。

​		三次握手实际上是确认双方全双工的数据收发缓冲功能完备，相应的四次挥手是安全的销毁双方全双工的数据收发缓冲。

### 三次握手

​		三次握手建立连接。

![image-20241013192901041](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20241013192901041.png)

​		socket准备阶段：

1. TCP B，`socket()`创建tcp套接字，为`CLOSED`

2. TCP B,   `bind()` 将套接字绑定到端口上，为`CLOSED`

3. TCP B， `listen()` 将套接字设置为被动套接字，监听连接，为`LISTEN`

4. TCP B， `accept()` 阻塞等待对端连接，为`LISTEN`

5. TCP A，`socket()`创建TCP 套接字，为`CLOSED`

​		三次握手阶段：

1. TCP A， `connect()` 主动连接对端，阻塞等待连接成功或失败后返回， 为`SYN_SENT`

   1. 主动连接对端，通过向对端发送同步请求`SYN`分节，假设分节荷载值为 `a`
   1. 主动方确认自己发送缓冲

   >   如果服务器端不能连接，直接进入`CLOSED`状态

2. TCP B， `accept()` 接收到``SYN``，连接请求到达，创建接收方socket，为`SYN_RCVD`

   1. 此阶段为内核协议栈处理
   2. 将该请求对应的`fd`加入未连接队列
   3. 接收到请求到达后，确认同步请求`a`，响应`ACK`分节，荷载值为 `a+1`
   4. 同时设置`SYN`分节，假设荷载值为`b`
   5. 被动方确认自己接收正常

   >   当A发送`SYN`的同时也收到了对端的`SYN`，即两端同事发起连接请求，那么 A 会从`SYN_SENT`转换为`SYN_RCVD`

3. TCP A，  `connect()` 接收到连接响应，为`ESTABLISHED`

   1. `connect()` 确认同步请求`b`，响应`ACK`分节，荷载值为 `b+1`
   2. `connect()` 从内核协议栈返回用户态应用程序
   3. 主动方确认自己接收正常

4. TCP B， `accept()` 接收到连接响应，为`ESTABLISHED`

   1. 将连接对应的fd从未连接队列中取出放入已连接队列
   2. `accept(）` 从内核协议栈返回用户态应用程序，向用户态应用程序返回已连接队列队头第一个热连接
   3. 被动方确认自己发送正常



- 主动方：`CLOSED` -> `SYN_SENT` -> `ESTABLISHED`
- 被动方：`CLOSED` -> `LISTEN` -> `SYN_RCVD` -> `ESTABLISHED`
- 连接存续期间，双方状态始终为`ESTABLISHED`
- 为什么是三次握手而不是四次握手：因为被动方将`SYN/ACK`合成一个数据包发送，即`SYN-ACK`数据包，同时设置了`SYN`和`ACK`
- 为什么不是两次握手：因为不能完全测试双方的全双工信道，不能保证后续收发的正确性。



### 四次挥手

![image-20241013192847406](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20241013192847406.png)

1. TCP A， `close()` 关闭tcp套接字，为`FIN_WAIT_1`

   1. 向对端发送连接结束请求`FIN`分节，假设荷载值为`x`
   2. 同时设置`ACK`分节，假设荷载值为`y`
2. TCP B， `read()`返回`0`， 为`CLOSE_WAIT`

   1. 内核协议栈向对端发送`ACK`分节，荷载值为`x+1`
   1. 被动方关闭接收缓冲
3. TCP A，  收到对端`read()`后经内核协议栈返回的`ACK`分节后，为`FIN_WAIT_2`
   1. read() 返回`EOF`
   1. 主动方关闭发送缓冲
4. TCP B，  `close()` 关闭tcp套接字，为`LAST_ACK`

   1. 内核协议栈处理
   2. 向对端发送`ACK`分节，荷载值为`x+1`
   3. 同时设置`FIN`分节，假设荷载值为`y`
5. TCP A， 收到对端`close`后经内核协议栈返回的`FIN`和`ACK`分节后，为`TIME_WAIT`

   1. 内核协议栈向对端发送 `ACK`分节，荷载值为`y+1`

   2. `TIME_WAIT`状态保持 `2 MSL`时间后置为`CLOSED`状态
      1. `MSL`是TCP协议规定的报文在网络中的最大生存时间，通常设置为2分钟
   
      2. **2MSL**大约是4分钟。在这段时间过后，连接正式关闭，相关资源得以回收。
   
   3. 主动方关闭接收缓冲
6. TCP B， 收到`ACK`分节后，为`CLOSED`
   1. 接收方关闭发送缓冲



- 主动方：`ESTABLISHED`->`FIN_WAIT1` -> `FIN_WAIT2`->`TIME_WAIT`->`CLOSED`
- 被动方： `ESTABLISHED` -> `CLOSE_WAIT` -> `LAST_ACK` -> `CLOSED`
- 连接存续期间，双方状态始终为`ESTABLISHED`
- 为什么四次挥手：
  - 相当于两端各自发起一次`FIN`，收到`FIN`请求的一方关闭接收缓冲，收到`FIN`的`ACK`一方对应关闭发送缓冲。
  - 因为只有发送`FIN`的一方是强保证不会再发送数据（因为已经`close`了`socket`），所以接收到`FIN`的一端可以放心的关闭接收缓冲
  - 也只有在收到对端对于`FIN`的`ACK`才能确认对端已经关闭接收缓冲，所以本端才能对应的关闭发送缓冲
  - 故四次。


### CLOSED

​		初始状态，表示没有任何连接。但是这个状态时虚拟状态，实际并不存在，netstat -ant | grep 端口的时候是找不到。



### LISTEN

​		被动方在某个端口上监听连接请求，随时准备有主动方连接。



### SYN_SENT

​		发送连接请求后等待确认信息。当客户端Socket进行Connect连接时，会首先发送SYN包，随即进入SYN_SENT状态，然后等待匹配的连接请求。



### SYN_RCVD

​		收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。通常是建立TCP连接的三次握手过程中的一个中间状态，表示Server端的Socket接收到来自Client的SYN包，并作出回应。



### ESTABLISHED

​		表示连接已经建立，可以进行数据传输。表示一端的收发缓冲都已经确认。



### FIN_WAIT1

​		 主动关闭方发送`FIN`包，表示己方不再发送数据，进入`FIN_WAIT_1`状态，等待返回`ACK`包。

- 在该状态下，主动方还能读取数据，但不能发送数据。
- 在正常情况下，无论对方处于何种状态，都应该马上返回`ACK`包，所以`FIN_WAIT_1`状态一般很难见到。



### FIN_WAIT2

​		主动关闭方收到返回的`ACK`包后，等待对方发送`FIN`包。

- 由于`FIN_WAIT_2`状态下需要等待对方发送的`FIN`包，所有常常可以看到。
- 若在`FIN_WAIT_1`状态下收到对方发送的同时带有`FIN`和`ACK`的包时，则直接进入`TIME_WAIT`状态，无须经过`FIN_WAIT_2`状态。



### TIME_WAIT

​		主动关闭方收到对方的FIN包后返回ACK包，然后等待足够长的时间（2MSL）以确保对方接收到ACK包，最后回到CLOSED状态，释放网络资源。

​		服务器上对于每个客户端的连接会占用一个本地端口来进行交互，在并发较高的情况下，`TIME_WAIT`状态的连接过多，会将服务器操作系统提供的端口耗尽，不能对外提供可靠的服务。并经过一段时间可以恢复。

​		`TIME_WAIT`状态持续时间是固定的，是最长分节生命期MSL（maximum segment lifetime）的两倍，称为2MSL。这个值在linux上是硬编码在系统内核中的，名称为`TCP_TIMEWAIT_LEN`，值为60s。

```c
#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-        WAIT state, about 60 seconds  */
```

> `TIME_WAIT`状态只会由断连发起的一端产生。

​		过多的TIME_WAIT连接

- 占用内存资源，可以忽略
- 对端口资源的占用，一个TCP连接至少消耗一个本地端口，端口总数一般为6w左右。如果TIME_WAIT状态过多，会导致无法创建新连接。

#### TIME_WAIT的原因

因四次挥手主动发起而产生。无论是客户端还是服务器端，只要主动发起断开，必然会经过TIME_WAIT过程。

> 客户端套接字的端口号是任意指定的，客户端动态分配端口资源，并且不需要提供大量的端口以供连接。所以不用考虑客户端TIME_WAIT带来的影响。

#### TIME_WAIT 的作用

​		考虑到丢失ACK包的可能和迷路重复数据包的影响，通常在主动关闭方对被动关闭方的FIN做出ACK后，需要等待足够长的时间，确保被动关闭方收到ACK数据包。

​		操作系统通常会将2MSL设为4分钟，最低不少于30秒，因而TIME_WAIT状态一般维持在30秒至4分钟

- 确保最后的ACK能够被被动方接收，帮助其正常关闭连接。

  ​		TCP的容错性设计，假设TCP报文会丢失，需要重传。这里如果最后的ACK没能被被动方正确接收，被动方会重发FIN报文。如果断连发起方没有`TIME_WAIT`状态，直接进入CLOSED状态，就失去了当前连接状态的上下文，只能回复一个RST，从而导致被动关闭防出现错误。

- 连接化身和迷途分节

  ​		在网络中，经常会发生报文经过一段时间才能到达目的地的情况（迷途分节），产生的原因是多种多样的，如路由器重启，链路突然出现故障等。在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。

  ​		 在关闭一个TCP连接后，马上又重新建立起一个相同连接四元组的TCP连接，后一个连接被称为前一个连接的化身（incarnation)。

  ​		那么有可能出现这种情况，前一个连接的迷途分节在前一个连接终止后到达对端，从而被误解成从属于新的连接化身。就会对TCP通信产生影响。



​		综上，经过``2MSL``， 可以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新的连接化身所产生的。

2MSL 的时间是从断连发起方接收到 FIN 后发送 ACK 开始计时的。

如果在 TIME_WAIT 时间内，因为断连发起方的 ACK 没有传输到被动方，断连发起方 又接收到了被动方 重发的 FIN 报文，那么 2MSL 时间将重新计时。

> ​		因为 2MSL 的时间，目的是为了让旧连接的所有报文都能自然消亡，现在主机 1 重新发送了 ACK 报文，自然需要重新计时，以便防止这个 ACK 报文对新可能的连接化身造成干扰。

#### TIME_WAIT的解决方案

- 监听套接字

> **`TIME_WAIT`会导致对端无法重新启动，此时可以通过`SO_REUSEADDR`来解决**
>
> 即使TIME_WAIT状态的端口，也可以继续使用它做为新的套集字使用。

- 连接套接字

  - net.ipv4.tcp_max_tw_buckets

    通过 sysctl 命令，将系统值调小。这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

  - 调低 TCP_TIMEWAIT_LEN，重新编译系统

    需要“一点”内核方面的知识，能够重新编译内核。

  - SO_LINGER

    ​		“linger”的意思为停留，我们可以通过设置套接字选项，来设置调用 close 或者 shutdown 关闭连接时的行为。

    ​		如果l_onoff为非 0， 且l_linger值也为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。

    ​		这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在recv()调用上时，接受到 RST 时，会立刻得到一个“connet reset by peer”的异常。

    ​		为跨越 TIME_WAIT 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。

  - net.ipv4.tcp_tw_reuse：更安全的设置

    > ​		Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technical experts.

    如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用:

    - 只适用于连接发起方（C/S 模型中的客户端）；
    - 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。

    需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）。

    > ​		TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。



### CLOSE_WAIT

​		主动关闭方调用`close`发送`FIN`包给被动接收方，被动关闭方收到`FIN`后返回`ACK`包，然后进入`CLOSE_WAIT`状态。

​		在该状态下，若己方还有数据未发送，则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。

​		当服务器没有正确的调用`close / shutdown`关闭连接，则服务端对应的`socket`会长时间处于`CLOSE_WAIT`状态。解决方法就是要检测出对方已经关闭的`socket`，然后关闭它。

- 代码需要判断`socket`，一旦`read`返回`0`，断开连接，`read`返回负，检查一下`errno`，如果不是`AGAIN`，也断开连接。

  > 在UNP 7.5节的图7.6中，可以看到使用select能够检测出对方发送了FIN，再根据这条规则就可以处理CLOSE_WAIT的连接

- 给每一个`socket`设置一个时间戳`last_update`，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个`socket`。

- 使用一个`Heart-Beat`线程，定期向`socket`发送指定格式的心跳数据包，如果接收到对方的``RST``报文，说明对方已经关闭了`socket`，那么我们也关闭这个`socket`。

- 设置`SO_KEEPALIVE`选项，并修改内核参数

> https://juejin.cn/post/6963590333993074725
>
> [【网络编程】线上大量CLOSE_WAIT的原因深入分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/493915289)
>
> [大量LAST_ACK分析过程_51CTO博客_LAST_ACK](https://blog.51cto.com/yangsj/1782099)

### LAST_ACK

​		被动关闭方在`CLOSE_WAIT`状态下，完成数据的发送后便可向对方发送`FIN`包，进入`LAST_ACK`状态，然后等待对方返回`ACK`包。

​		收到`ACK`包后便回到`CLOSED`状态，释放网络资源。

### CLOSING

​	 比较罕见的例外状态。正常情况下，发送FIN包后应该先收到（或同时收到）对方的ACK包，再收到对方的FIN包，而CLOSING状态表示发送FIN包后并没有收到对方的ACK包，却已收到了对方的FIN包。

- 当两端同时``close()``时，那么就可能出现双方同时发送FIN包的情况
- 如果`ACK`包丢失而对方的`FIN`包很快发出，也会出现`FIN`先于`ACK`到达。

![image-20241013195213976](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20241013195213976.png)



## 工作流程

### 数据包发送流程

1. **数据分段**：根据MTU（最大传输单元）和当前窗口大小，发送方可能需要将数据拆分成多个数据段。每个数据段包含TCP头部和数据负载，每个数据段都有序列号，表示它在数据流中的位置。
2. **添加TCP头部**：每个数据段前加上TCP头部，包含源端口、目的端口、序列号、确认号、数据偏移（头部长度）、保留位、标志位（如SYN、ACK、FIN、RST等）、窗口大小、校验和、紧急指针等字段。
3. **封装成IP数据包**：TCP数据段被封装进IP数据包中，再由网络层处理，加上源IP地址、目的IP地址等信息。
4. **物理层传输**：最终，数据包通过物理网络发送出去。

###  数据包接收流程

1. **接收数据包**：网络层接收到IP数据包后，剥离IP头部，将TCP数据段传递给传输层。
2. 校验与排序
   - **校验和**：TCP头部包含校验和，接收方计算并验证数据段的完整性。
   - **排序**：根据数据段的序列号对它们进行排序，确保数据的正确顺序。
3. 确认与流量控制
   - **发送ACK**：接收方发送ACK，确认已接收到的数据段。ACK中的确认号是对收到序列号的下一个期待数据段的确认。
   - **窗口通告**：接收方通过TCP头部中的窗口大小字段，告知发送方其缓冲区的可用空间大小，实现流量控制。
4. **数据传递给应用层**：排序和校验后的数据段被重新组合成原始数据，然后传递给应用层。



## 滑动窗口

​		链路层和TCP协议都有滑动窗口作为流量控制的算法，链路层的滑动窗口以帧为单位，TCP滑动窗口以字节为单位。

![image-20210903150326813](https://gitee.com/masstsing/picgo-picserver/raw/master/20210903150327.png)

-   通告接收窗口（rwnd)：

    ​		预防应用程序发送的数据超过对方的缓冲区，接受方使用的流量控制手段

-   拥塞窗口（cwnd)：

    ​		预防应用程序发送的数据超过网络所能承受的能力。发送方使用的流量控制手段

>   发送窗口取两者较小值

-   慢启动阈值（ssthresh: slow start threshold）

-   慢启动阶段

    cwnd从1开始按指数增长知道ssthresh

-   拥塞避免阶段

    cwnd按现行增长，知道拥塞，将cwnd = 1, ssthresh减半

-   快速重传

-   快速恢复

## 可靠性保证

​		何为不可靠及解决方式：

- 差错   -- 校验和
- 失序  --  seq
- 重复  –  seq
- 丢包  –  超时重传+确认

​		应用数据被分隔成TCP认为最适合发送的数据块，成为段传递给IP层

​		当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

​		当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

​		TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到端的校验和有任何差错，TCP将丢弃这个报文段并且不确认（导致对方超时重传）

​		TCP承载与IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达可能会失序。TCP将对收到的数据进行重新排序。

​		IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。

​		TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间（滑动窗口）