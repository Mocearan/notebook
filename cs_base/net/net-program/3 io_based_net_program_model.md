# 基于I/O的网络模型

​		这里的并发模型是指I/O并发，而非任务并发。

​		一般将数据的I/O和紧随其后的处理视作一个任务，除非其后的处理在应用层面上更为耗时。

---

​		使用`socket api`编写的基础代码展示了网络编程的基础设施，但要编写真正使用的网络应用需要并发来支持大量用户的同时访问，或资源的高效使用。

​		基础的`socket`程序存在的问题是串行，对于多个`socket`句柄需要轮询读取数据，在一个`socket`上读取数据包的同时，其他`socket`接收的数据只能在接收缓冲区中堆积排队等待读取。

​		在`socket`编程中，通常将一个持续处理的单元称为一个`loop`，因为往往是一个循环。它可能是不同粒度和组合形式的。

## 网络事件

​		在不同的``socket``上会产生如下事件，对这些事件不同粒度和组合形式的处理，产生了大量不同的网络模型。

- 连接事件
- 读事件
- 写事件
- 异常事件
- 关闭事件

## routine

​		简化`socket`编程的复杂性，主要在于让`socket`中各种事件尽量批量的、互不干涉的被处理。

​		因此，分割各个I/O阶段，使用独立的单元去处理就成了基于I/O的网络编程设计的核心问题。由此产生了大量的基于多路复用/iocp操作系统特性的I/O模型，和各种逐渐发展并完善的并发模型设计。

​		一般的，将一个连接上数据包经历的处理单元分为：

- `acceptor`：处理连接

- `poller`：基于一个多路复用调用(`select/poll/epoll`)设计的事件检测循环
  - 经过`poller`处理会得到一个事件，接下来的事情事实上不属于网络框架的处理范围
  - 基于这两个结构
  
- `handler`：发生实际的I/O并处理数据（``task``）
  
  > 针对于不同的数据处理特点，设计针对事件的不同的处理结构
  
  - 可以在`poller`中进行读写（读写一般设置非阻塞）
  - 也可以使用独立的I/O线程或线程池
  
- `task`：

  - 任务耗时较少时，可以在`handler`中处理
  - 任务耗时较长，或任务并发较大时可以使用工作线程或线程池

    - 单线程处理所有`handler`

    - 线程池处理所有`handler`
    - 任务队列
    - `pipeline`
