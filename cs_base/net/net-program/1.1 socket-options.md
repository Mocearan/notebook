# socket 选项

​		socket具有多种特性，这些特性可以通过可选项进行配置。

---

​		进行套接字编程时，往往主要关注数据通信，而其他的特性对不同场景的适配具有实践意义。

> level 及 optval
>
> https://blog.csdn.net/chary8088/article/details/2486377
>
> https://www.cnblogs.com/baiduboy/p/8127913.html
>
> [setsockopt函数解析 _四月的专栏-CSDN博客](https://blog.csdn.net/yufangbo/article/details/4663639)



## SOL_SOCKET socket通用选项

​		套接字编程相关通用选项

### `SO_REUSERADDR`

​		允许重用本地地址和端口（``int``)

> 允许绑定已被使用的地址（或端口号），可以参考``bind``的man手册

- 当一个套接字主动``close``之后，并不会立即释放，而是会进入`TIME_WAIT`状态，直到两个``TTL``之后才能重新使用。

- 如果创建套接字之后，设置套接字选项`REUSEADDR`，可以不必等待`TIME_WAIT`状态的结束就可以重启复用同一端口。

- 所以服务器端监听的端口尽可能使用`REUSEADDR`，因为服务器的端口无法随意更改，并通知到所有客户端。

  - 服务端的连接端口一般也不会主动与客户端断开连接，而是等待客户端主动`close`
  - 客户端是以任意端口向服务端发起链接，因此有足够时间释放原端口

  ```shell
  netstat -an | grep TIME_WAIT
  ```

  

```c
int on = 1;
setsockopt( listen_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof( on ) );
```



### SO_LINGER

```c
struct linger {
　int　 l_onoff;　　　　/* 0=off, nonzero=on */
　int　 l_linger;　　　　/* linger time, POSIX specifies units as seconds */
}
```



- 选项简述：延迟关闭连接
- 选项值类型： struct linger

![image-20210906221407523](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210906221407523.png)

> ​		若设置了SO_LINGER（亦即linger结构中的l_onoff域设为非零），并设置了零超时间隔，则 closesocket()不被阻塞立即执行，不论是否有排队数据未发送或未被确认。
>
> ​		这种关闭方式称为“强制”或“失效”关闭，因为套接口的虚电路立即被 复位，且丢失了未发送的数据。
>
> ​		在远端的recv()调用将以WSAECONNRESET出错。
> ​		若设置了SO_LINGER并确定了非零的超时间 隔，则closesocket()调用阻塞进程，直到所剩数据发送完毕或超时。这种关闭称为“优雅的”关闭。
>
> ​		请注意如果套接口置为非阻塞且 SO_LINGER设为非零超时，则closesocket()调用将以WSAEWOULDBLOCK错误返回。
> 若在一个流类套接口上设置了 SO_DONTLINGER（也就是说将linger结构的l_onoff域设为零；），则 closesocket()调用立即返回。但是，如果可能，排队的数据将在套接口关闭前发送。请注意，在这种情况下WINDOWS套接口实现将在一段不确 定的时间内保留套接口以及其他资源，这对于想用所以套接口的应用程序来说有一定影响。

### SO_BROADCAST

- 选项简述：允许发送广播
- 选项值类型：int
- 适用于 UDP socket。其意义是允许 UDP socket 「广播」（broadcast）讯息到网路上。

### SO_DEBUG

- 选项简述：允许调试
- 选项值类型：int

### SO_DONTROUTE

- 选项简述：不查找路由
- 选项值类型： int

### SO_ERROR

- 选项简述：获得套接字错误
- 选项值类型：int

### SO_KEEPALIVE

- 选项简述：保持连接

- 选项值类型： int

- 检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。

  > ​		设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方 发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况： 对方接收一切正常：以期望的 ACK响应。2小时后，TCP将发出另一个探测分节。 对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。 对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到 一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错 误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“hostunreachable (主机不 可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为 EHOSTUNREACH。

### SO_DONTLINGER

- 选项简述：若为真，则**SO_LINGER**选项被禁止。





### SO_OOBINLINE

- 选项简述：带外数据放入正常数据流,在普通数据流中接收带外数据
- 选项值类型： int

### `SO_RCVBUF & SO_SNDBUF`

​		接收缓冲区大小(``int``)、发送缓冲区大小(``int``)

> ​		每个套接口都有一个发送缓冲区和一个接收缓冲区。 接收缓冲区被TCP和UDP用来将接收到的数据一直保存到由应用进程来读。 
>
> - TCP: 
>   - TCP通告对端滑动窗口大小，告知一次能够处理的数据长度，因此接收缓冲区不会溢出。  
>   - 这是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。 
> - UDP:
>   - 当接收到的数据报装不进套接口接收缓冲区时，此数据报就被丢弃。
>   - UDP是没有 流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。

- 设置接收、发送缓冲区的保留大小与 **SO_MAX_MSG_SIZE** 或TCP滑动窗口无关
- 最终缓冲区的大小和设置的值不一定相同，系统会参考该值进行设置
- 如果一般发送的包很大很频繁，那么使用这个选项

### SO_RCVLOWAT

- 选项简述：接收缓冲区下限
- 选项值类型： int

### SO_SNDLOWAT

- 选项简述：发送缓冲区下限

- 选项值类型： int

- 每个套接口都有一个接收低潮限度和一个发送低潮限度。

  > ​		它们是函数selectt使用的， 接收低潮限度是让select返回“可读”而在套接口接收缓冲区中必须有的数据总量。 ——对于一个TCP或UDP套接口，此值缺省为1。发送低潮限度是让select返回“可写” 而在套接口发送缓冲区中必须有的可用空间。对于TCP套接口，此值常缺省为2048。 对于UDP使用低潮限度， 由于其发送缓冲区中可用空间的字节数是从不变化的，只要 UDP套接口发送缓冲区大小大于套接口的低潮限度，这样的UDP套接口就总是可写的。 UDP没有发送缓冲区，只有发送缓冲区的大小。

### SO_RCVTIMEO

- 选项简述：接收超时
- 选项值类型：struct timeval

### SO_SNDTIMEO

- 选项简述：发送超时
- 选项值类型： struct timeval

### SO_EXCLUSIVEADDRUSE

- 选项简述：独占模式使用端口,就是不充许和其它程序使用SO_REUSEADDR共享的使用某一端口。
- 在确定多重绑定使用谁的时候，根据一条原则是谁的指定最明确则将包递交给谁，而且没有权限之分，也就是说低级权限的用户是可以重绑定在高级权限如服务启动的端口上的,这是非常重大的一个安全隐患,
  如果不想让自己程序被监听，那么使用这个选项

### SO_TYPE

套接字类型（``int``）.

- tcp socket, 1
- udp socket, 2

### SO_BSDCOMPAT

- 选项简述：与BSD系统兼容
- 选项值类型： int



## IPPRPTO_IP 	IP协议选项

### IP_HDRINCL

- 选项简述：在数据包中包含IP首部
- 选项值类型：int
- 这个选项常用于黑客技术中，隐藏自己的IP地址

### IP_OPTINOS

- 选项简述：IP首部选项
- 选项值类型：int

### IP_TOS

- 选项简述： 服务类型

### IP_TTL

- 选项简述：生存时间
- 选项值类型：int



### 以下IPV4选项用于组播：

### IP_ADD_MEMBERSHIP

- 选项简述：加入到组播组中
- 选项值类型：struct ip_mreq

### IP_ROP_MEMBERSHIP

- 选项简述：从组播组中退出
- 选项值类型：struct ip_mreq
- 该选项用来从某个组播组中退出。数据结构ip_mreq的使用方法与上面相同。

### IP_MULTICAST_IF

- 选项简述：指定提交组播报文的接口
- 选项值类型：struct ip_mreq
- 该选项可以修改网络接口，在结构ip_mreq中定义新的接口。

### IP_MULTICAST_TTL

- 选项简述：指定提交组播报文的TTL
- 选项值类型：u_char
- 设置组播报文的数据包的TTL（生存时间）。默认值是1，表示数据包只能在本地的子网中传送。

### IP_MULTICAST_LOOP

- 功能描述：使组播报文环路有效或无效
- 选项值类型：u_char
- 组播组中的成员自己也会收到它向本组发送的报文。这个选项用于选择是否激活这种状态。

![image-20210906222505849](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210906222505849.png)

> 若进程要加入到一个组播组中，用soket的setsockopt()函数发送该选项。该选项类型是ip_mreq结构，它的第一个字段imr_multiaddr指定了组播组的地址，第二个字段imr_interface指定了接口的IPv4地址。

## IPPRPTO_TCP	TCP协议选项

TCP协议相关的选项

### TCP_MAXSEG

- 选项简述：TCP最大数据段的大小

- 选项值类型：int

- 获取或设置TCP连接的最大分节大小(MSS)。

  > ​		返回值是我们的TCP发送给另一端的最大 数据量，它常常就是由另一端用SYN分节通告的MSS，除非我们的TCP选择使用一个比 对方通告的MSS小些的值。如果此值在套接口连接之前取得，则返回值为未从另·—端 收到Mss选项的情况下所用的缺省值。小于此返回值的信可能真正用在连接上，因为譬 如说使用时间戳选项的话，它在每个分节上占用12字节的TCP选项容量。我们的TcP将 发送的每个分节的最大数据量也可在连接存活期内改变，但前提是TCP要支持路径MTU 发现功能。如果到对方的路径改变了，此值可上下调整。



### TCP_NODELAY & TCP_CORK

- TCP_NODELAY：不使用Nagle算法（``int``）

  ​	指定TCP开始发送保活分节前，以秒为单位的连接空闲时间。

  ​	缺省值至少为7200秒，即2小时。

  ​	此选项仅在**SO_KEPALIVEE**套接口选项打开时才有效。

> 许多UNIX系统都实现了TCP_NODELAY选项，但是，TCP_CORK则是Linux系统所独有的而且相对较新；它首先在内核版本2.4上得以实现。
>
> 此外，其他UNIX系统版本也有功能类似的选项，值得注意的是，在某种由BSD派生的系统上的 TCP_NOPUSH选项其实就是TCP_CORK的一部分具体实现。
> ​

#### Nagle

​		`Nagle`算法是一种串行化算法，用于防止数据包过多而发生网络过载。需要收到上一数据包的``ACK``才会发送下一数据包。

​		TCP默认使用`Nagle`交换数据，最大限度的进行缓冲，直到收到`ACK`

```c
A                  B			A                              b
  ---> data 'N'						---> data 'N'		
  <--- ACK 'N'						---> data 'a'	<--- ACK 'N'
  ---> data 'agle'					---> data 'g'	<--- ACK 'a'
  <--- ACK 'agle'					---> data 'l'	<--- ACK 'g'
  								   ---> data 'e'   <--- ACK 'l'
    											  <--- ACK 'e'
  /* Nagle ON */								/* Nagle Off */
```

> 不使用`Nagle`算法，数据发送时机与`ACK`无关，数据被传递到发送缓冲区后就会被立即发送出去。增加了数据包的数据量，降低传送延迟的同时，也降低了传送效率。

​		``Nagle``算法实际上能提高缓冲效率。不使用``Nagle``算法可以提高传输速度，但会增加网络流量。但这需要考察一次传送到发送缓冲区的数据量：

- 如果数据量远小于发送缓冲区，就会造成传输协议数据包数量的增加

- 如果数据量接近甚至超过发送缓冲区的大小，传输协议数据包也基本是满载的，不会暂停加数据包的数量，还会无须等待`ACK`进行连续传输

  > 诸如大文件传输等流式传输应用适用于禁用``Nagle``算法。

​		

​	

​		TCP_NODELAY和TCP_CORK基本上控制了包的 “Nagle化”，Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。John Nagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参 看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome ，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40 个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。 Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。
​		现 在让我们假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送 数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比 就会比较低，而且，如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle算 法。
​		另外一种情况则需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服 务器。应用 Nagle算法在这种情况下就会产生问题。但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同 TCP_NODELAY相反（TCP_CORK 和 TCP_NODELAY 是互相排斥的）。下面就让我们仔细分析下其工作原理。
​		假设应用程序 使用sendfile()函数来转移大量数据。应用协议通常要求发送某些信息来预先解释数据，这些信息其实就是报头内容。典型情况下报头很小，而且套接字 上设置了TCP_NODELAY。有报头的包将被立即传输，在某些情况下（取决于内部的包计数器），因为这个包成功地被对方收到后需要请求对方确认。这 样，大量数据的传输就会被推迟而且产生了不必要的网络流量交换。
但是，如果我们在套接字上设置了TCP_CORK（可以比喻为在管道上插入 “塞子”）选项，具有报头的包就会填补大量的数据，所有的数据都根据大小自动地通过包传输出去。当数据传输完成时，最好取消TCP_CORK 选项设置给连接“拔去塞子”以便任一部分的帧都能发送出去。这同“塞住”网络连接同等重要。
​		总而言之，如果你肯定能一起发送多个数据集合（例如HTTP响应的头和正文），那么我们建议你设置TCP_CORK选项，这样在这些数据之间不存在延迟。能极大地有益于WWW、FTP以及文件服务器的性能，同时也简化了你的工作。示例代码如下.

![image-20210906224159278](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210906224159278.png)

​		不幸的是，许多常用的程序并没有考虑到以上问题。例如，Eric Allman编写的sendmail就没有对其套接字设置任何选项。

​		Apache HTTPD 是因特网上最流行的Web服务器，它的所有套接字就都设置了TCP_NODELAY选项，而且其性能也深受大多数用户的满意。这是为什么呢？答案就在于实 现的差别之上。由BSD衍生的TCP/IP协议栈（值得注意的是FreeBSD）在这种状况下的操作就不同。当在TCP_NODELAY 模式下提交大量小数据块传输时，大量信息将按照一次write()函数调用发送一块数据的方式发送出去。然而，因为负责请求交付确认的记数器是面向字节而 非面向包（在 Linux上）的，所以引入延迟的概率就降低了很多。结果仅仅和全部数据的大小有关系。而 Linux 在第一包到达之后就要求确认，FreeBSD则在进行如此操作之前会等待好几百个包。

​		在Linux系统上，TCP_NODELAY的效果同习惯于BSD TCP/IP协议栈的开发者所期望的效果有很大不同，而且在Linux上的Apache性能表现也会更差些。其他在Linux上频繁采用TCP_NODELAY的应用程序也有同样的问题



### TCP_DEFER_ACCEPT

​		我 们首先考虑的第1个选项是TCP_DEFER_ACCEPT（这是Linux系统上的叫法，其他一些操作系统上也有同样的选项但使用不同的名字）。为了理 解TCP_DEFER_ACCEPT选项的具体思想，我们有必要大致阐述一下典型的HTTP客户/服务器交互过程。请回想下TCP是如何与传输数据的目标 建立连接的。在网络上，在分离的单元之间传输的信息称为IP包（或IP 数据报）。一个包总有一个携带服务信息的包头，包头用于内部协议的处理，并且它也可以携带数据负载。服务信息的典型例子就是一套所谓的标志，它把包标记代 表TCP/IP协议栈内的特殊含义，例如收到包的成功确认等等。通常，在经过“标记”的包里携带负载是完全可能的，但有时，内部逻辑迫使TCP/IP协议 栈发出只有包头的IP包。这些包经常会引发讨厌的网络延迟而且还增加了系统的负载，结果导致网络性能在整体上降低。
​		现在服务器创建了一个套接字同 时等待连接。TCP/IP式的连接过程就是所谓“3次握手”。首先，客户程序发送一个设置SYN标志而且不带数据负载的TCP包（一个SYN包）。服务器 则以发出带SYN/ACK标志的数据包（一个SYN/ACK包）作为刚才收到包的确认响应。客户随后发送一个ACK包确认收到了第2个包从而结束连接过 程。在收到客户发来的这个SYN/ACK包之后，服务器会唤醒一个接收进程等待数据到达。当3次握手完成后，客户程序即开始把“有用的”的数据发送给服务 器。通常，一个HTTP请求的量是很小的而且完全可以装到一个包里。但是，在以上的情况下，至少有4个包将用来进行双向传输，这样就增加了可观的延迟时 间。此外，你还得注意到，在“有用的”数据被发送之前，接收方已经开始在等待信息了。
​		为了减轻这些问题所带来的影响，Linux（以及其他的一些 操作系统）在其TCP实现中包括了TCP_DEFER_ACCEPT选项。它们设置在侦听套接字的服务器方，该选项命令内核不等待最后的ACK包而且在第 1个真正有数据的包到达才初始化侦听进程。在发送SYN/ACK包之后，服务器就会等待客户程序发送含数据的IP包。现在，只需要在网络上传送3个包了， 而且还显著降低了连接建立的延迟，对HTTP通信而言尤其如此。
​		这一选项在好些操作系统上都有相应的对等物。例如，在FreeBSD上，同样的行为可以用以下代码实现：

![image-20210906224328073](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20210906224328073.png)

​		这 个特征在FreeBSD上叫做“接受过滤器”，而且具有多种用法。不过，在几乎所有的情况下其效果与TCP_DEFER_ACCEPT是一样的：服务器不 等待最后的ACK包而仅仅等待携带数据负载的包。要了解该选项及其对高性能Web服务器的重要意义的更多信息请参考Apache文档上的有关内容。
​		就HTTP 客户/服务器交互而言，有可能需要改变客户程序的行为。客户程序为什么要发送这种“无用的”ACK包呢？这是因为，TCP协议栈无法知道ACK包的状态。 如果采用FTP而非HTTP，那么客户程序直到接收了FTP服务器提示的数据包之后才发送数据。在这种情况下，延迟的ACK将导致客户/服务器交互出现延 迟。为了确定ACK是否必要，客户程序必须知道应用程序协议及其当前状态。这样，修改客户行为就成为必要了。
​		对Linux客户程序来说，我们还可 以采用另一个选项，它也被叫做TCP_DEFER_ACCEPT。我们知道，套接字分成两种类型，侦听套接字和连接套接字，所以它们也各自具有相应的 TCP选项集合。因此，经常同时采用的这两类选项却具有同样的名字也是完全可能的。在连接套接字上设置该选项以后，客户在收到一个SYN/ACK包之后就 不再发送ACK包，而是等待用户程序的下一个发送数据请求；因此，服务器发送的包也就相应减少了。

### TCP_QUICKACK

​		阻止因发送无用包而引发延迟的另一个方法是使用TCP_QUICKACK选项。这一选项与 TCP_DEFER_ACCEPT不同，它不但能用作管理连接建立过程而且在正常数据传输过程期间也可以使用。另外，它能在客户/服务器连接的任何一方设 置。如果知道数据不久即将发送，那么推迟ACK包的发送就会派上用场，而且最好在那个携带数据的数据包上设置ACK 标志以便把网络负载减到最小。当发送方肯定数据将被立即发送（多个包）时，TCP_QUICKACK 选项可以设置为0。对处于“连接”状态下的套接字该选项的缺省值是1，首次使用以后内核将把该选项立即复位为1（这是个一次性的选项）。

​		在某些情形下，发出ACK包则非常有用。ACK包将确认数据块的接收，而且，当下一块被处理时不至于引入延迟。这种数据传输模式对交互过程是相当典型的，因为此类情况下用户的输入时刻无法预测。在Linux系统上这就是缺省的套接字行为。
​		在 上述情况下，客户程序在向服务器发送HTTP请求，而预先就知道请求包很短所以在连接建立之后就应该立即发送，这可谓HTTP的典型工作方式。既然没有必 要发送一个纯粹的ACK包，所以设置TCP_QUICKACK为0以提高性能是完全可能的。在服务器方，这两种选项都只能在侦听套接字上设置一次。所有的 套接字，也就是被接受呼叫间接创建的套接字则会继承原有套接字的所有选项。
​		通过TCP_CORK、TCP_DEFER_ACCEPT和 TCP_QUICKACK选项的组合，参与每一HTTP交互的数据包数量将被降低到最小的可接受水平（根据TCP协议的要求和安全方面的考虑）。结果不仅 是获得更快的数据传输和请求处理速度而且还使客户/服务器双向延迟实现了最小化。







## sockopt api

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname,
                      void *optval, socklen_t *optlen);
/* Set socket FD's option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
int setsockopt(int sockfd, int level, int optname
               , const void *optval, socklen_t optlen);

// sockfd:   套接字
// level:   指定控制套接字的层次.可以取三种值:
//    1) SOL_SOCKET:通用套接字选项.
//    2) IPPROTO_IP:IPv4选项.
//    3) IPPROTO_IP6:IPv6选项.
//    4) IPPROTO_TCP:TCP选项.　
// optname:  控制的方式(选项的名称)
// optval:	是一个指向变量的指针, 具体的转型依赖optname传入的选项 
//	  类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }
// optlen:  set时为传入参数， get时为传出参数， optval的大小

// 成功返回0， 失败返回-1
```

​		部分选项只能进行读取，而不能设置。

