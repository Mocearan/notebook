

# socket udp编程

## udp 基础编程

![img](https://gitee.com/masstsing/picgo-picserver/raw/master/8416f0055bedce10a3c7d0416cc1f430.png)

>   **echo server:**
>
>   ```c 
>   /*
>    * @Author: Mass 
>    * @Date: 2021-09-28 14:51:10 
>    * @Last Modified by: Mass
>    * @Last Modified time: 2021-09-28 15:28:27
>    */
>   
>   #include "../../common/utils.h"
>   
>   #include <string.h>
>   #include <signal.h>
>   #include <stdlib.h>
>   
>   #define MAXLINE 4096
>   
>   static int count;
>   
>   static void recvfrom_int( int signo )
>   {
>       printf( "\nreceived %d datagrams\n", count );
>       exit( 0 );
>   }
>   
>   int main( int argc, char *argv [] )
>   {
>       int socket_fd = socket( PF_INET, SOCK_DGRAM, 0 );
>       struct sockaddr_in servaddr = {
>           .sin_family = AF_INET,
>           .sin_addr.s_addr = htonl( INADDR_ANY ),
>           .sin_port = htons( 5288 )
>       };
>       bzero( servaddr.sin_zero, sizeof( servaddr.sin_zero ) );
>   
>       bind( socket_fd, (struct sockaddr *) &servaddr, sizeof( sizeof( servaddr ) ) );
>   
>       signal( SIGINT, recvfrom_int );
>   
>       struct sockaddr_in cliaddr;
>       socklen_t clilen = sizeof( cliaddr );
>   
>       char message[ MAXLINE ];
>       count = 0;
>   
>       for ( ;;) {
>           int n = recvfrom( socket_fd, message, MAXLINE, 0, (struct  sockaddr *) &cliaddr, &clilen );
>           message[ n ] = 0;
>           printf( "receive %d bytes: %s\n", n, message );
>   
>           char send_line[ MAXLINE ];
>           sprintf( send_line, "Hi, %s", message );
>   
>           sendto( socket_fd, send_line, strlen( send_line ), 0, (struct sockaddr *) &cliaddr, clilen );
>           count++;
>       }
>   }
>   ```
>
>   **echo client**
>
>   ```c
>   /*
>    * @Author: Mass 
>    * @Date: 2021-09-28 15:24:51 
>    * @Last Modified by: Mass
>    * @Last Modified time: 2021-09-28 15:41:07
>    */
>   
>   #include "../../common/basedef.h"
>   #include "../../common/utils.h"
>   
>   #include <arpa/inet.h>
>   #include <string.h>
>   
>   #define MAXLINE 4096
>   
>   int main( int argc, char *argv [] )
>   {
>       if ( argc != 2 )
>           ERR_EXIT( "UASAGE: udpclient <IPaddress>" );
>   
>       int sock_fd = socket( PF_INET, SOCK_DGRAM, 0 );
>   
>       struct sockaddr_in servaddr = {
>           .sin_family = AF_INET,
>           .sin_addr = inet_addr( argv[ 1 ] ),
>           .sin_port = htons( 5288 )
>       };
>       bzero( servaddr.sin_zero, sizeof( servaddr.sin_zero ) );
>       socklen_t servlen = sizeof( servaddr );
>   
>       struct sockaddr resaddr;
>       socklen_t reslen = 0;
>   
>       int n = 0;
>   
>       char send_line[ MAXLINE ], recv_line[ MAXLINE + 1 ];// recv + '\0'
>       while ( fgets( send_line, MAXLINE, stdin ) != NULL ) {
>           int i = strlen( send_line );
>           if ( send_line[ i - 1 ] == '\n' )
>               send_line[ i - 1 ] = 0;
>   
>           printf( "now sending %s\n", send_line );
>           size_t rt = sendto( sock_fd, send_line, strlen( send_line ), 0, (struct sockaddr *) &servaddr, servlen );
>           if ( rt < 0 )
>               ERR_EXIT( "send failed" );
>           printf( "send bytes: %zu\n", rt );
>   
>           n = recvfrom( sock_fd, recv_line, MAXLINE, 0, &resaddr, &reslen );
>           if ( n < 0 )
>               ERR_EXIT( "recvfrom failed" );
>           recv_line[ n ] = '\0';
>           fputs( recv_line, stdout );
>           fputs( "\n", stdout );
>       }
>       exit( 0 );
>   }
>   ```
>
>   >   ​	因为不用connect， 所以当接收端未启动，不会出现Connect refused，而是UDP会一直阻塞在sendto上。
>
>   