# Multiplexing I/O

---

​		基于事件触发的 I/O多路复用模型，是现在linux下最常用的I/O模型。

## 多路复用

​		多路，指多个信道，即多个I/O端口。集中在一组系统调用中又系统统一返回。

​		复用，指对系统调用的复用。频繁的使用系统调用会使得操作系统在用户态和内核态之间切换，而使用多路复用接口，使得对多个端个的检测由内核统一检测，统一返回，减少系统调用的使用频率。



## I/O事件产生条件

### 可读

- 套接口缓冲区有数据可读

  > ​		有一个下限，缓冲区中数据量超过这个下限，就会通过select通知可读事件触发。


> ​		read可能并没有把通信套接字内核缓冲区中的数据都读完，那么通讯缓冲区仍然是活跃的，我们应该将读到的数据保存在应用层维护的通讯套接字对应的缓冲区中。
>
> ​		write的时候，应该也维护一个应用层的发送缓冲区。

- 连接的读一半关闭，即接收到FIN段，读操作将返回0.

  > ​		对方关闭，即意味着对方不再发送数据，通知本地关闭接收。这时read将返回0.

- 监听套接字上，已完成队列不为空时

  > ​		表示有已经准备好的连接需处理

- 套接口上发生了一个错误需要处理

  > ​		可以通过`getsockopt`指定`SO_ERROR`来获取错误

### 可写

- 套接口的发送缓冲区不满，有空间容纳数据

  > ​		正因此，可写事件会持续发生，因为一般情况下发送缓冲区都不会被写满，也就不会被阻塞。
  >
  > ​		所以我们一般也不太关注写事件。

  > ​		对于可写事件，只要通讯套接字的内核发送缓冲区不满（可以容纳数据）就会持续触发可写事件。
  >
  > ​		如果过早的关注了可写事件，可能因为内核缓冲区未满而持续的触发可写事件，进而导致忙等待（busy-loop）。应该在write失败时检查内核缓冲区是不是已经满了，然后再关注可写事件。等到应用层缓冲区的中数据全部发送完毕，取消关注可写事件。

- 连接的写一半关闭，即受到RST段后，再次调用write操作向连接对端发送数据

  > ​		会产生`SIGPIPE`信号，通知连接管道破裂。

- 套接口上发生了一个错误待处理

  > ​		错误可以通过`getsockopt`指定

### 异常

- 套接口存在带外数据



### select / poll / epoll  对比

![image-20220704232436331](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220704232436331.png)



![image-20220704232551001](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220704232551001.png)



![image-20220704232717732](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220704232717732.png)



![image-20220704232644977](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220704232644977.png)



​	epoll内部实现更为复杂，在连接数较少的情况下，epoll的效率不会比`select / poll`更高。