# 	文件

---



## 文件机制



### 块存储

linux ext4文件系统中文件在磁盘上的存储是以4KB的块为单位的，即文件在磁盘上实际占用的最小单位是4K。

> 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。
>
> 所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。

### 文件缓冲区

对文件的读写并非直接应用于硬件设备之上，而是对内核维护的文件缓冲区进行读写，由内核在合适的时机将缓冲区和文件进行同步。

也可以选择是否使用缓冲区和缓冲区同步的方式。

大多数文件系统为改善性能，都采用某种预读技术。检测到正在进行顺序读取时，系统可能试图读入比应用要求的多的数据到缓冲区中待应用读取。



### 内核文件结构

内核使用三种数据结构表示打开文件，它们之间的关系决定着文件共享方面进程之间的影响。

1. 每个进程在进程表中都有一个记录项

   记录项中包含一张打开文件描述符表，每个文件描述符结构关联：文件描述符标志，指向文件表项的指针

2. 内核为所有打开文件维护一张文件表

   每个文件表项包含：文件状态标志、当前文件偏移量、指向该文件v节点表项的指针

   > 文件状态标志：读、写、添加、同步或非阻塞等。

3. 每个打开文件（或设备）都有一个V节点（v-node）结构。

   > linux没有使用v节点，而是使用了i节点结构。虽然两种实现有所不同，但是在概念上是一致的。两者都指向文件系统特点有的i节点结构。
   >
   > linux的i节点有两种，一种是与文件系统相关的i节点和一个与文件系统无关的i节点。

   v节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v节点还包含了该文件的i节点i-node，索引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以，文件的所有相关信息都是随时可用的。

![image-20220331175414639](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220331175414639.png)

##### 标志

文件描述符标志和文件状态标志的区别在于，文件描述符标志作用于一个进程，而文件状态标志应用于所有引用了给定文件表项的所有进程中对应的文件描述符表项。

##### 文件描述符项

即上图进程表项（进程文教描述符表项），是以文件描述符为核心的一套数据结构。

###### 文件描述符

对文件的句柄式表征为文件描述符（fd, file descriptor)，表现为一个非负整数。范围是`0~OPEN_MAX-1`.

> 对于内核，所有打开的文件都通过文件描述符引用。
>
> > Linux上所有的设备或文件的操作，都视为对文件的操作。都抽象为文件操作。当打开或创建一个文件时，系统调用从内核中向进程返回一个文件描述符，后续对文件的操作只需要通过该文件描述符，内核记录该文件描述符的相关结构信息。
>
> 当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。
>
> 当读写一个文件时，使用`open / creat` 返回的文件描述符表示该文件，将其作为参数传递给`read / write`

> 对于linux来说，文件描述符的变化范围几乎无限，只受限于存储期总量、整型的字长以及系统管理员所配置的软限制和硬限制。

> ### /dev/fd
>
> 目录名为文件描述符的数值，打开文件`/dev/fd/n`等效于赋值描述符。
>
> `fd=open("/dev/fd/0", mode);`等效于`fd=dup(0);`，fd与0共享同一文件表项，mode被忽略，只能依赖于原文件打开状态。
>
> 主要由shell使用，允许使用路径名作为调用参数的程序，能用处理路径名的方式来处理标准输入输出：
>
> ​		`filter f1 | cat f1 /dev/fd/0 f3 | lpr

###### 预定义文件描述符

一个进程默认隐含的包含三个已经打开的文件描述符，表示三个基本的输入输出设备：

​		`#include <unistd.h>`

- `STDIN_FILENO   0`，标准输入设备文件描述符，表征键盘
- `STDOUT_FILENO  1`，标准输出设备文件描述符，表征屏幕
- `STDERR_FILENO  2`，标准错误输出设备文件描述符，表征屏幕

> C库中有对应三个文件指针：
> 		`stdin`/ `stdout` / `stderr`

> `fileno`，将文件指针转换为文件描述符
>
> `fdopen`，将文件描述符转换为文件指针
>
> ```c
> #include <stdio.h>
> 
> int main( void )
> {
>      printf( "fileno(stdin) = %d\n", fileno( stdin ) );
>      return 0;
> }
> ```



##### 文件表：文件描述符的内核数据结构

进程中内核维护文件描述符表，用来记录该进程打开的文件列表。文件描述符表中记录了文件（信息）表：

- 文件状态标志

  ​	读写、追加、同步、非阻塞等。

- 当前文件偏移量

- refcnt = 1

- v节点指针

​		V节点指针指向一个v节点表，其中包括v节点信息和i节点信息等。



### 文件偏移

每个打开的文件都有一个与之关联的**当前文件偏移量**。通常是一个非负整数，标定从文件开始处到当前**cursor位置的**字节数。

通常文件读写，都是当前cursor处进行，读写操作会潜在的改变cursor的位置（当前文件偏移量改变）。

> 如果写操作导致当前文件偏移量超过了当前文件长度，则将i节点表项汇总的当前文件长度设置为cursor的位置（文件加长了）

使用`O_APPEND`选项打开文件，对文件偏移的操作都将失效，任何write都发生在文件末尾。否则，当前文件偏移量被设置为0。

> 文件偏移记录在文件表中，共享的文件表共用文件偏移。
>
> 选项标志首先记录在文件表项的文件状态标志中。

> 每次对这种具有追加写标志的文件执行写操作，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。

这样隐含的在文件偏移处读写，是文件的顺序读写。可以通过操作文件偏移的方式，来实现文件的随机读写。

使用`lseek`可以显式地为一个打开文件设置偏移量。

> 使用`lseek`定位到文件当前的尾端，则文件表项中的当前文件坯那一辆被设置为i节点表项中的当前文件长度。
>
> `lseek`只修改文件表项中的当前文件偏移量，不进行任何I/O操作。

每个进程拥有独立的当前文件偏移量



## 文件系统

文件系统是操作系统中负责管理持久数据的子系统，负责把用户的文件存到磁盘硬件中。

> 磁盘里的数据不会因掉电丢失，可以持久化的保存文件。
>
> Linux 最经典的一句话是：「一切皆文件」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。

可以把一个磁盘分成一个多个分区，每个分区可以包含一个文件系统。

![image-20220407234807328](https://gitee.com/masstsing/picgo-picserver/raw/master/image-20220407234807328.png)

### 超级块

超级块，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。

> 当文件系统挂载时进入内存；

### 索引节点与目录项

Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。

- 索引节点（ inode），固定长度，用来记录文件的元信息，比如 inode 编号、文件类型、文件大小、访问权限、链接计数、创建时间、修改时间、数据在磁盘的位置（指向文件数据块的指针）等等。

  > ​		索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。
  >
  > ​		`stat`结构中的信息大多数取自索引节点，其中只有索引节点编号和文件名存放在目录项中。
  >
  > ​		内核中索引节点的数据类型是`ino_t`
  >
  > ​		索引节点是存储在硬盘上的数据，为了加速文件的访问，通常会把索引节点加载到内存中。

- 目录项（dentry），用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构。

  > ​		与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。
  >
  > ​		如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。

目录项和索引节点的关系是多对一，**硬链接**通过多个目录项中的索引节点指向同一个文件，索引节点中的链接计数增加。只有当索引节点中的链接计数为0时，才能删除该文件，释放该文件占用的数据块。

> 因此，删除一个目录项的函数称为`unlink`而不是`delete`。
>
> 链接计数包含在`stat.st_nlink`中，`LINK_MAX`指定了一个文件的嘴大链接数。
>
> 硬链接不存在对应的文件，而是通过不同的名字（目录项）访问同一索引节点，从而访问同一文件的数据块。而软链接（符号链接），通过另一文件间接的访问到该文件的索引节点。
>
> 不能将目录项指向一个另一个文件系统中的索引节点，所以不能创建跨越文件系统的链接。（如果实现允许，也仅限于超级用户才可以这样做。）因为可能在文件系统中形成循环。因此很多文件系统不允许对目录的硬链接。
>
> 重命名文件时，不会改动实际的文件内容。只需要重新构造一个指向现有索引节点的目录项，并删除老的目录项。链接计数也不会改变。

![图片](https://gitee.com/masstsing/picgo-picserver/raw/master/640)

## 文件类型

Unix系统大多数文件是普通文件或目录。

### 普通文件（regular file）

包含某种形式的数据。unix内核不区分数据是文本还是二进制，文件处理程序负责解释文件内容。

> 二进制可执行文件是内核可以区分并理解的。

### 目录文件（directory file）

包含其他文件的名字以及指向与这些文件有关信息的指针。

只有内核可以直接写目录文件

### 块特殊文件（block special file）

提供对设备带缓冲的访问（以固定长度）

### 字符特殊文件（character special file）

提供对设备不带缓冲的访问，每次访问长度可变

系统中设备要么是字符特殊文件，要么是块特殊文件。

### FIFO（管道文件，pipe）

用于进程间通信，有时也称为命名管道

### 套接字（socket）

用于进程间的网络通信，也可以在同一台机器上进程之间的非网络通信。

### 符号链接（symbolic link）

符号链接时对一个文件的间接。符号链接文件的实际内容（数据块中的数据）包含了该符号链接所指向的文件的名字。

> `.... lib->/usr/lib`

引入符号链接的原因是为了避开硬链接的一些限制：

- 硬链接通常要求链接和文件处于同一文件系统中
- 只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）

因为符号链接以及它指向哪种对象，没有任何文件系统限制。（任何用户都可以创建指向目录的符号链接）

## 文件类型

### 符号链接

```c
#include <unistd.h>
// 读取一个符号链接的
ssize_t readlink(const char *path, char *buf, size_t bufsiz);
```

























