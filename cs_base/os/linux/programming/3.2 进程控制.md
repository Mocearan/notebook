# 进程控制

​		包括创建新进程。执行程序和进程终止。以及与此相关的进程属性的各种ID，以及它们如何受进程控制原语的影响。

---



## 进程标识

​		进程由一个非负整数的ID唯一标识，进程终止后其ID归还给操作系统，以待复用。

> 大多数Unix系统采用延迟复用算法，以防止新创建的进程与操作系统还未完全回收的进程冲突。

### 系统进程

​		不同的unix实现版本都有自己的一套提供操作系统服务的内核进程。，用以维护操作系统运行时的状态。

​		一般`ID`为0的进程通常是调度进程，也称作交换进程（swapper）。该进程是操作系统内核的一部分，并不执行任何磁盘上的程序，因此也称作是系统进程

​		某些unix的虚拟存储器实现中，ID为2的是页守护进程（page daemon），此进程负责支持虚拟存储期系统的分页操作。

​		

### init进程

​		`ID`为1的进程通常是``init``进程，在自举过程结束时由内核调用。负责在自举内核后启动一个UNIX系统

- 对应的程序文件为`/etc/init`，在较新的版本中是`/sbin/init`文件
- 通常读取与系统有关的初始化文件（`/etc/rc*`文件，`/etc/inittab`文件以及`/etc/init.d`中的文件），并经系统引导到一个状态
- 该进程在操作系统运行期间不会终止
- 以超级用户特权运行在用户空间



### api

```c++
#include<unistd.h>
pid_t getpid(void);  // 返回值：调用进程的进程ID
pid_t getppid(void); // 返回值：调用进程的父进程ID
uid_t getuid(void);  // 返回值：返回进程的实际用户ID
uid_t geteuid(void); // 返回值：返回进程的有效用户ID
gid_t getgid(void);  // 返回值：返回进程的实际组ID
gid_t getegid(void); // 返回值：返回进程的有效组ID

// 返回值无出错情形
```





## 创建进程

​		现有的进程可以调用`fork/vfork`来创建新的进程，创建的新进程叫做子进程（child process）。

- 一个进程可以创建多个子进程

- 在创建成功后，父子进程继续各自执行各自的指令

- 父子进程共享正文段（代码段）

  > 子进程从父进程的正文段加载指令

- 子进程拷贝父进程的数据空间、堆、栈，拥有不同的虚拟地址空间。

  > 拷贝而非共享， 任何进程之间的数据都是隔离的。

- 创建子进程成功后，父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的进程调度算法。

  > 可以使用进程间通信机制解决这类竞争问题



### 写时复制

​		`fork`之后往往调用`exec`（创建子进程的目的是为了完成某个任务），所以很多系统实现并不会完全拷贝父进程的数据空间、堆和栈。而是使用**写时复制**（Copy-On-Write， COW）技术：

- `exec`在当前进程地址空间中，将正在进行的程序替换为新程序。

- `exec`用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段和栈段。

- 所以在`fork`时不必执行完整的地址空间拷贝，因为大概率会调用`exec`来用新程序替换当前地址空间中各个段。

  - 父进程和子进程共享内存区域，内核这些区域设置为只读访问

  - 父进程或子进程中任意一个对该只读内存区域中的数据进行修改时，内核此时才将要写的数据拷贝到子进程副本（制作一个虚拟内存页）

    > linux中`clone()`是`fork`的一种泛化形式，允许调用者控制哪些部分由父子进程共享。



### 文件共享

​		父进程的所有打开的文件描述符都被复制到子进程中。

​		这种复制等同于子进程对该文件描述符执行了`dup`函数。因此，父子进程每个相同的打开描述符共享同一个文件表项。

> ​		由于标准`IO`库是带缓冲的，缓冲是地址空间中的一段数据，因此在`fork`调用之后，随着对应文件描述符被拷贝，这些缓冲的数据也被拷贝到子进程中。

​		![image-20220913225742589](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220913225742589.png)

​		由于父子进程共享文件表项，因此当前文件偏移也是共享的。因此，对于父子进程写同一文件描述符指向的文件，需要一些同步处理，否则写入的数据会混合。

> 同步包括等待或信号通知等进程间通信手段

​		对于`fork`之后的文件描述符处理有两种常见情况：

- 父进程等待子进程结束，不进行其他操作。

  ​	父进程无须对打开的文件描述符进行任何处理，因为只有子进程在操作这些文件描述符。

- 父进程和子进程各自执行各自的代码段。

  ​	父进程和子进程需要各自关闭它们不需要使用的文件描述符，从而减少共享造成的数据混乱；对于仍旧共享的文件，需要提供父子进程之间同步的机制。

​		

​		除了打开的文件描述符之外，子进程还继承了父进程的下列属性：

- 实际用户`ID`、实际组`ID`、有效用户`ID`、有效组`ID`、附属组`ID`、进程组`ID`、会话`ID`
- 控制终端、设置用户`ID`标志和设置组`ID`标志
- 当前工作目录、根目录
- 文件模式创建屏蔽字、信号屏蔽和信号处理、对任一打开文件描述符的执行时关闭标志
- 环境、连接的共享存储段、存储映像、资源限制



### 创建子进程的两个用途

- 父进程复制自己的地址空间，但子进程执行不同的代码段。

  ​	常用于网络程序：父进程等待连接，子进程处理连接后的逻辑

- 父进程拉起一个全新的进程

  ​	常用于`shell`程序，子进程从`fork`后立即调用`exec`（称为`spawn`）

  > `exec`内核使程序执行的唯一方法。
  >
  > `exec`用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段和栈段。从而使进程执行一个全新的程序，从`main`开始执行。（即子进程从父进程中拷贝和共享的所有东西，都会被`exec`加载的新程序所替换。）

  ​	在`fork`和`exec`之间，子进程可以更改自己的属性，如I/O重定向、用户Id、信号安排等。

  

### 子进程中非复制的差别

- `fork`返回值不同
- 进程`ID`不同
- 各自父进程`ID`不同
- 子进程的`tms_utime,tms_stime,tms_cutime,tms_ustime`的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集



### api

#### fork

```c
#include <unistd.h>

pid_t fork(void);
```

##### 返回值

- 如果创建成功

  一次调用，两次返回

  - 在父进程的调用中子进程ID

    > 系统没有提供获取当前进程创建的子进程ID列表的接口，``fork``通过返回进程ID，由应用维护子进程ID列表。

  - 在子进程的返回值中返回0.

    > 子进程可以通过`getppid()`来获取父进程的ID，因为在子进程中只需返回``0``表示成功即可。

- 如果创建失败，在父进程中返回-1

  > 创建失败的两个主要原因：
  >
  > - 系统资源不足（已经有太多的进程，占满了系统资源）
  > - 实际用户ID的进程数超限（`CHILD_MAX`限定了每个实际用户ID在任何时刻可以保持的最大进程数）



> 一次调用两次返回的原理：
>
> [鸿蒙内核源码分析(fork篇) | fork是如何做到调用一次返回两次的? (baidu.com)](https://baijiahao.baidu.com/s?id=1696710441939503546&wfr=spider&for=pc)
>
> [为什么fork会返回两次？-EDA365电子论坛通信数码-人工智能-计算机-半导体-手机家电消费电子硬件门户网站](https://www.eda365.com/article-164879-1.html)
>
> [为什么fork函数会返回两次？_nu1lptr的博客-CSDN博客_fork调用一次返回两次](https://blog.csdn.net/weixin_40323516/article/details/123256746)
>
> ​		进程地址空间的复制，子进程PCB进程表项生成。现场保护信息中，寄存器、PC提供`fork`前后的现场信息。



#### vfork

```c
#include <sys/types.h>
#include <unistd.h>

pid_t vfork(void);
```

​		`vfork`用于创建一个新进程，该新进程的目的是`exec`一个新程序，所以`vfork`并不将父进程的地址空间拷贝到子进程中。

​		子进程调用`exec`或者`exit`之前，子进程在父进程的地址空间中运行。这意味着子进程在`exec/exit`之前，在父进程的地址空间可以修改数据、调用函数或异常退出，都可能会带来未知结果。

​		`vfork`保证子进程优先运行，在子进程调用`exec`或者`exit`之后父进程才可能被调度运行



## 终止进程

​		进程有五种正常和三种异常终止方式，无论以何种方式终止，最后内核都会执行一段代码为相应进程关闭所有打开的文件描述符，释放使用的存储期等。

- 正常终止

  - `main`函数内执行`return`语句

    ​	等效于调用`exit`

  - 调用`exit`函数

    ​	ISO C定义的标准库函数，其操作包括调用各终止处理程序，然后关闭所有标准I/O流。

    > 终止处理程序由`atexit`在先前注册。
    >
    > ISO C不处理文件描述符、多进程以及作业控制，这一定义对UNIX系统而言并不完整。

  - 调用`_eixt`或`_Exit`函数

    ​	ISO C定义`_Eixt`，终止时不运行终止处理程序或信号处理程序，Unix中也不冲洗标志IO流.

    ​	Unix中`_Exit`和`_exit`同义，`_eixt`由`exit`调用，用于处理Unix系统中特定的细节。

    > `_exit`由POSIX.1说明，是一个系统调用

  - 进程启动的最后一个线程中执行`return`语句

    ​	但该线程的返回值不是进程的返回值，而是以终止状态0返回。

  - 进程启动的最后一个线程中调用`pthread_exit`函数。

    ​	进程以终止状态0返回，与传递给`pthread_exit`的参数无关。

- 三种异常终止

  - 调用`abort`。

    ​	产生`SIGABRT`信号，是信号终止的一个特例

  - 信号终止。

    ​	信号可由进程自身产生（`abort`等）、其他进程或内核发送。

    > 如地址越界访问、除0等，都会产生相应的信号。

  - 最后一个线程响应取消。

    ​	取消需要延迟等待到线程被内核调度。



### 进程终止的捕获

​		终止进程的父进程能够使用`wait/waitpid`函数取得其终止状态（termination status）。

> unix中，所有进程都有父进程。

​		对于退出函数：`eixt / _exit / _Exit`，将其退出状态（exit status）作为参数传递给退出函数，内核将退出状态转换成终止状态（termination status）。

​		对于异常终止，内核将产生一个指示异常终止原因的终止状态（termination status）。

​		![image-20220914232620322](https://raw.githubusercontent.com/Mocearan/picgo-server/main/image-20220914232620322.png)



### 孤儿进程

​		父进程先于子进程终止，为保证所有进程都有父进程，子进程将由`init`进程接管作为父进程。被称为孤儿进程。

​		在一个进程终止时，内核逐个检查所有活动的进程，判断它是否是正要终止的进程的子进程，确认后该进程的父进程ID就更改为1（`init`进程ID）。这保证每个进程都有一个父进程。



### 僵尸进程

​		如果子进程先于父进程终止，为保证父进程对子进程终止的捕获能够及时的得到信息。  





​		



















































