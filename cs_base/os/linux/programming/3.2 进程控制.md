# 进程控制

包括创建新进程。执行程序和进程终止。以及与此相关的进程属性的各种ID，以及它们如何受进程控制原语的影响。

---



## 进程标识

​		进程由一个非负整数的ID唯一标识，进程终止后其ID归还给操作系统，以待复用。

> 大多数Unix系统采用延迟复用算法，以防止新创建的进程与操作系统还未完全回收的进程冲突。

- `ID`为0的进程通常是调度进程，也称作交换进程。

  ​		该进程是操作系统内核的一部分，并不执行任何磁盘上的程序，因此也称作是系统进程

- `ID`为1的进程通常是``init``进程，在自举过程结束时由内核调用。

  - 该进程对应的程序文件为`/etc/init`，在较新的版本中是`/sbin/init`文件
  - 该进程负责在自举内核后启动一个UNIX系统
  - 该进程通常读取与系统有关的初始化文件（`/etc/rc*`文件，`/etc/inittab`文件以及`/etc/init.d`中的文件），并经系统引导到一个状态
  - 该进程永远不会终止
  - 以超级用户特权运行在用户空间



## 创建进程

​		一个现有的进程可以调用`fork`来创建一个新的进程。







## 进程控制操作

### getpid / getppid / getuid / geteuid / getgid / getegid

```c++
#include<unistd.h>
pid_t getpid(void);  // 返回值：调用进程的进程ID
pid_t getppid(void); // 返回值：调用进程的父进程ID
uid_t getuid(void);  // 返回值：返回进程的实际用户ID
uid_t geteuid(void); // 返回值：返回进程的有效用户ID
gid_t getgid(void);  // 返回值：返回进程的实际组ID
gid_t getegid(void); // 返回值：返回进程的有效组ID

// 返回值无出错情形
```



### fork

```c
#include <unistd.h>

pid_t fork(void);
```

#### fork后的地址空间

​		`fork`后生成子进程，子进程和父进程共享同一程序副本（共享正文段）。但从`fork`处开始，子进程和父进程执行各自不同的指令，拥有不同的虚拟地址空间。

​		`fork`生成的子进程拷贝父进程数据空间、堆和栈的副本，但父子进程不在同一虚拟地址空间内。进程之间都是隔离的。

​		`fork`之后往往调用`exec`（创建子进程的目的是为了完成某个任务），所以很多系统实现并不会完全拷贝父进程的数据空间、堆和栈。而是使用**写时复制**（Copy-On-Write， COW）技术：

> `exec`在当前进程地址空间中，将正在进行的程序替换为新程序。
>
> `exec`用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段和栈段。
>
> 所以在`fork`时不必执行完整的地址空间拷贝，因为大概率会调用`exec`来用新程序替换当前地址空间中各个段。

- 父进程和子进程共享只读的内存区域
- 父进程或子进程中任一对该只读内存区域中的数据进行修改，内核此时才将要写的数据拷贝到副本（制作一个虚拟内存页）

> linux中`clone()`是`fork`的一种泛化形式，允许调用者控制哪些部分由父子进程共享。

#### fork后的执行顺序

​		`fork`之后，是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的进程调度算法

#### fork后的文件共享

​		父进程的所有打开的文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享同一个文件表项。

> ​		由于标准`IO`库是带缓冲的，缓冲是地址空间中的一段数据，因此在`fork`调用之后，这些缓冲的数据也被拷贝到子进程中。

​		由于父子进程共享文件表项，因此当前文件偏移也是共享的。因此，对于父子进程写同一文件描述符指向的文件，需要一些同步处理，否则写入的数据会混合。

​		对于`fork`之后的文件描述符处理有两种常见情况：

- 父进程等待子进程结束，不进行其他操作。

  ​	父进程无须对打开的文件描述符进行任何处理，因为只有子进程在操作这些文件描述符。

- 父进程和子进程各自执行各自的代码段。

  ​	父进程和子进程需要各自关闭它们不需要使用的文件描述符，从而减少共享造成的数据混乱；对于仍旧共享的文件，需要提供父子进程之间同步的机制。

​		

​		除了打开的文件描述符之外，子进程还继承了父进程的下列属性：实际用户`ID`、实际组`ID`、有效用户`ID`、有效组`ID`、附属组`ID`、进程组`ID`、会话`ID`、控制终端、设置用户`ID`标志和设置组`ID`标志、当前工作目录、根目录、文件模式创建屏蔽字、信号屏蔽和信号处理、对任一打开文件描述符的执行时关闭标志、环境、连接的共享存储段、存储映像、资源限制



#### 父进程和子进程的区别

- `fork`返回值不同
- 进程`ID`不同
- 进程父进程`ID`不同
- 子进程的`tms_utime,tms_stime,tms_cutime,tms_ustime`的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集



#### fork 的两个用法

- 父进程复制自己的地址空间，但子进程执行不同的代码段。

  ​	常用于网络程序：父进程等待连接，子进程处理连接后的逻辑

- 父进程拉起一个全新的进程

  ​	常用于`shell`程序，子进程从`fork`后立即调用`exec`

  > `exec`内核使程序执行的唯一方法。
  >
  > `exec`用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段和栈段。从而使进程执行一个全新的程序，从`main`开始执行。





#### 返回值

- 如果创建成功
  - 在父进程的调用中子进程ID
  - 在子进程的返回值中返回0.

> ​		一个进程可以创建多个子进程，系统并不提供获取当前进程创建的子进程ID列表的接口。所以，fork返回的进程ID需要应用进行维护。
>
> ​		子进程通过`getppid()`来获取父进程的ID，因为在子进程中只需返回``0``表示成功即可。

> ​	**一次调用，两次返回的原理：**
>
> ​		进程地址空间的复制，子进程PCB进程表项生成。现场保护信息中，寄存器、PC提供`fork`前后的现场信息。
>
> [鸿蒙内核源码分析(fork篇) | fork是如何做到调用一次返回两次的? (baidu.com)](https://baijiahao.baidu.com/s?id=1696710441939503546&wfr=spider&for=pc)
>
> [为什么fork会返回两次？-EDA365电子论坛通信数码-人工智能-计算机-半导体-手机家电消费电子硬件门户网站](https://www.eda365.com/article-164879-1.html)
>
> [为什么fork函数会返回两次？_nu1lptr的博客-CSDN博客_fork调用一次返回两次](https://blog.csdn.net/weixin_40323516/article/details/123256746)

- 如果创建失败，在父进程中返回-1

  ​	创建失败的两个主要原因：

  - 系统资源不足（已经有太多的进程，占满了系统资源）
  - 实际用户ID的进程数超限（`CHILD_MAX`限定了每个实际用户ID在任何时刻可以保持的最大进程数）































































