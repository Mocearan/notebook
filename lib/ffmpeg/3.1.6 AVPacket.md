# AVPacket





• pts：显示时间戳

• dts：解码时间戳

• data：压缩编码数据

• size：压缩编码数据大小

• pos:数据的偏移地址

• stream_index：所属的AVStream



```c
AVPacket *av_packet_alloc(void); 分配AVPacket 这个时候和buffer没有关系
void av_packet_free(AVPacket **pkt); 释放AVPacket 和_alloc对应
void av_init_packet(AVPacket *pkt); 初始化AVPacket 只是单纯初始化pkt字段
int av_new_packet(AVPacket *pkt, int size); 给AVPacket的buf分配内存，引用计数初始化为1
int av_packet_ref(AVPacket *dst, const AVPacket *src); 增加引用计数
void av_packet_unref(AVPacket *pkt); 减少引用计数
void av_packet_move_ref(AVPacket *dst, AVPacket *src); 转移引用计数
AVPacket *av_packet_clone(const AVPacket *src); 等于av_packet_alloc()+av_packet_ref()
AVFrame *av_frame_alloc(void); 分配AVFrame
void av_frame_free(AVFrame **frame); 释放AVFrame
int av_frame_ref(AVFrame *dst, const AVFrame *src); 增加引用计数
void av_frame_unref(AVFrame *frame); 减少引用计数
void av_frame_move_ref(AVFrame *dst, AVFrame *src); 转移引用计数
int av_frame_get_buffer(AVFrame *frame, int align); 根据AVFrame分配内存
AVFrame *av_frame_clone(const AVFrame *src); 等于av_frame_alloc()+av_frame_ref()
```



## 内存模型

​		从现有的`Packet`拷贝一个新`Packet`的时候，有两种情况：

• ①两个`Packet`的`buf`引用的是同一数据缓存空间，这时 候要注意数据缓存空间的释放问题；

• ②两个`Packet`的`buf`引用不同的数据缓存空间，每个 Packet都有数据缓存空间的copy；

![img](https://developer.qcloudimg.com/http-save/yehe-7620466/d9731beca5b691a76f0919462a838748.png)

​		对于多个AVPacket共享同一个缓存空间，FFmpeg使用的引用计数的机制（reference-count）：

- 初始化引用计数为0，只有真正分配AVBuffer的时候，引用计数初始化为1;
- 当有新的Packet引用共享的缓存空间时，就将引用计数+1；
- 当释放了引用共享空间的Packet，就将引用计数-1；引用计数为0时，就释放掉引用的缓存空间AVBuffer。

> AVFrame也是采用同样的机制。