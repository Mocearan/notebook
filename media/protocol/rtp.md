# RTP

​		Real-time Transport Protocol,实时传输协议

---

​		面向实时应用的网络传输协议，广泛应用于视频会议、流媒体广播和在线游戏等场景。RTP 不仅能够处理音频和视频数据，还能处理模拟数据流，例如模拟传感器数据。

​		IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。

​		RTP通常用于实现多播音频会议和音视频会议等应用。

​		在多播音频会议中，音频数据通过一个多播地址和一对端口传输，其中一个端口用于传输音频数据（RTP），另一个端口用于传输控制包（RTCP）。

> RTP会话使用合法的偶数端口（2n），对应的RTCP包使用下一个奇数端口（2n+1）。

​		一般基于UDP，也可使用TCP

## 应用场景

### 视频会议

RTP协议可以用于实现视频会议系统中的音视频传输，确保音视频数据的实时性和同步性。

###  流媒体

RTP协议可以用于流媒体服务中，如直播、点播、[视频监控](https://cloud.tencent.com/developer/techpedia/2303)等，保证音视频数据的实时传输和播放。

###  IP电话

RTP协议可以用于实现IP电话中的语音传输，确保语音数据的实时传输和质量。

###  语音对讲

RTP协议可以用于实现语音对讲系统中的音频传输，确保音频数据的实时传输和质量。

###  游戏实时语音

RTP协议可以用于游戏实时语音中，保证游戏玩家之间的语音交流的实时性和质量。

​		音频和视频会议中，音频和视频数据通常分别在不同的RTP会话中传输，每个会话使用不同的传输地址和端口。如果在会议中同时使用了音频和视频，通常会使用不同的RTP会话来传输这两种媒体。会议参与者可以根据RTCP包中的规范化名称（CNAME，Canonical Name）来检索关联的音频和视频数据，并根据RTCP包中的时间戳信息来实现音频和视频的同步。





## 概念

### 流媒体

​		流式传输是实现流媒体的关键技术。使用流式传输可以边下载边观看流媒体节目。由于Internet是基于分组传输的，所以接收端收到的数据包往往有延迟和乱序（流式传输构建在UDP上）。要实现流式传输，就是要从降低延迟和恢复数据包时序入手。在发送端，为降低延迟，往往对传输数据进行预处理（降低质量和高效压缩）。在接收端为了恢复时序，采用了接收缓冲；而为了实现媒体的流畅播放，则采用了播放缓冲。



### 混频器 Mixer

​		中间系统。因为RTP是一个多数据源协议，接收端需要处理多个数据来源（视频、音频、多发送端等）。

​		将一个或多个源的RTP数据包重新编码合成一个新的RTP数据包，然后转发出去。混频器可能会改变数据包的数据格式，并对各个流组合的新数据包生成一个新SSRC（混频器作为它们的同步源）。过贡献源列表（CSRC表）可以确认合成源的参与者。



### 转换器

​		中间系统，转发RTP数据包但不改变数据包的同步源标识符，可用于通过IP多播无法直接到达的用户区，如在防火墙两端使用转换器，外侧转换器通过安全连接将数据传输到内侧转换器。

​		![img](https://pic4.zhimg.com/80/v2-0ae7c935f58299315a533a5d5439a1f7_720w.webp)

![img](https://pic1.zhimg.com/80/v2-fd973eef1b3978f7cc5121965dacb0f0_720w.webp)

## 特性机制

1. **实时性**：RTP 是为实时数据传输设计的。虽然 UDP 也提供了低延迟的传输，但 RTP 在此基础上增加了**时间戳和序列号**，这有助于接收端同步和播放乱序到达的数据包。
2. **负载识别**：RTP 头部包含有关负载类型（例如音频、视频、编码格式等）的信息，这使得接收端可以正确地解码和播放流。
   - RTP协议支持多种音频和视频编码格式，包括MPEG、H.264、G.711、G.729等。
3. **性能监控**：与 RTP 一起使用的 RTCP (Real-time Transport Control Protocol) 允许发送端和接收端交换有关传输质量的信息，如丢包率、延迟等。这有助于动态调整传输参数以优化性能。
4. **多媒体同步**：在一个会话中传输多个媒体流（例如音频和视频）时，RTP 的时间戳可以帮助接收端同步这些流。
5. **可扩展性**：RTP协议支持扩展头部，可以在头部中添加一些自定义的信息。



### 实时性

- 时间戳

  ​	RTP协议使用时间戳来标识音视频数据的时间戳，以便在接收端进行同步播放。

  - 在发送端，时间戳的值为音视频数据的采样时间，可以通过采样率计算得到。
  - 在接收端，通过时间戳的值，可以确定音视频数据的播放时间。

- 序列号

  ​	RTP协议使用序列号来标识音视频数据的顺序，以便在接收端进行数据包的排序。

  - 在发送端，每个数据包都有一个唯一的序列号，表示该数据包在音视频[数据流](https://cloud.tencent.com/developer/techpedia/1734)中的位置。
  - 在接收端，通过序列号的值，可以确定音视频数据包的顺序，从而进行数据包的重组和播放。

- 帧同步

  ​	RTP协议可以使用帧同步技术，确保音视频数据在传输过程中的同步性。

  > ​	例如，在视频传输中，可以在I帧（关键帧）的前面添加一个附加信息，标识该帧的时间戳和序列号，以便在接收端正确地播放视频。

- 丢包重传

  ​	RTP协议在传输过程中，可能会发生数据包丢失的情况。RTP协议可以使用丢包重传机制，对丢失的数据包进行重传



### 丢包和延迟

- 丢包重传
  - 当音视频数据包丢失时，RTP协议可以使用丢包重传机制，对丢失的数据包进行重传。接收端可以通过缓存已经接收到的数据包，等待重传的数据包到达，然后进行数据包的重组和播放。
- 前向纠错
  - RTP协议可以使用前向纠错技术，对音视频数据进行冗余编码，以便在接收端检测和纠正错误。例如，可以将相邻的几个数据包进行编码，生成一个冗余数据包，当其中一个数据包丢失时，接收端可以使用冗余数据包来恢复数据。
- 延迟控制
  - RTP协议可以使用延迟控制技术，对数据包的延迟进行控制，以保证音视频数据的实时性。例如，在视频传输中，可以在I帧（关键帧）的前面添加一个附加信息，标识该帧的时间戳和序列号，以便在接收端正确地播放视频。
- 流媒体同步
  - RTP协议可以使用流媒体同步技术，对音视频数据进行同步，以保证音视频数据的同步播放。例如，在视频传输中，可以使用帧同步技术，确保音视频数据在传输过程中的同步性。

### 同步和重排

- 时间戳
  - RTP协议使用时间戳来标识音视频数据的时间戳，以便在接收端进行同步播放。在发送端，时间戳的值为音视频数据的采样时间，可以通过采样率计算得到。在接收端，通过时间戳的值，可以确定音视频数据的播放时间。
- 序列号
  - RTP协议使用序列号来标识音视频数据的顺序，以便在接收端进行数据包的排序。在发送端，每个数据包都有一个唯一的序列号，表示该数据包在音视频数据流中的位置。在接收端，通过序列号的值，可以确定音视频数据包的顺序，从而进行数据包的重组和播放。
- 帧同步
  - RTP协议可以使用帧同步技术，确保音视频数据在传输过程中的同步性。例如，在视频传输中，可以在I帧（关键帧）的前面添加一个附加信息，标识该帧的时间戳和序列号，以便在接收端正确地播放视频。
- 接收缓存
  - RTP协议在接收端使用接收缓存，用于缓存接收到的音视频数据包。接收端可以根据数据包的时间戳和序列号，对数据包进行排序和组合，从而实现音视频数据的同步和顺序播放。



## 协议结构

### RTP头部结构

- 固定头部（Fixed Header，12 byte）
  - 版本号
  - 填充位
  - 扩展位
  - CSRC计数器
  - 负载类型
- 可选头部（Optional Header， 0~32 byte）
  - 扩展头部
  - CSRC列表信息
- 负载数据（Payload Data，0~65535）
  - 实际的传递数据

```c
// 0  2 3 4   8  9      16                32
// ----------------------------------------
// |v |p|x| cc |M|  PT   |     seq        |
//-----------------------------------------
// |		ts						   |
//-----------------------------------------
// |		ssrc					    |
//-----------------------------------------
// |		csrc						|
//------------------------------------------
//|          ....						 |

/*
- 版本号（V）：2比特，用来标志使用的RTP版本
- 填充位（P）：1比特，如果置位,则该RTP包的尾部就包含附加的填充字节。
- 扩展位（X）：1比特，如果置位,RTP固定头部后面就跟有一个扩展头部。
- CSRC计数器（CC）：4比特，含有固定头部后面跟着的CSRC的数目。
- 标记位（M）：1比特,该位的解释由配置文档（Profile）来承担.
- 载荷类型（PT）：7比特，标识了RTP载荷的类型。
- 序列号（SN）：16比特
	- 发送方在每发送完一个RTP包后就将该域的值增加1
	- 接收方可以由该域记录丢包量及恢复包序列
	- 序列号的初始值是随机的
- 时间戳：32比特，记录了该包中数据的第一个字节的采样时刻。
	- 在一次会话开始时，时间戳初始化成一个初始值。
	- 时间戳是去除抖动和实现同步不可缺少的。
	- 即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）
- 同步源标识符(SSRC)：32比特，同步源就是指RTP包流的来源。
	- 在一个RTP会话中，每个数据流的SSRC都不同
	- 该标识符是随机选取的 RFC1889推荐了MD5随机算法。
- 贡献源列表（CSRC List）：0～15项，每项32比特
	- 用来标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。
	- 由混频器将这些有贡献的SSRC标识符插入表中。
	- SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份。
*/

struct rtp_hdr {
	unsigned char cc:4; // CSRC count
	unsigned char x:1; // header extension flag
	unsigned char p:1; // padding flag
	unsigned char version:2;
	unsigned char pt:7; // payload type
	unsigned char m:1; // marker bit
	uint16_t seq; // sequence number
	uint32_t ts; // timestamp
	uint32_t ssrc; // synchronization source
    uint32_t csrc[]; // contribution source list
};
```







RTP 的同步源 (SSRC) 标识符用于标识同步源，即 RTP 流的源。在复杂的场景中，例如视频会议，可能有多个同步源。SSRC 保证了 RTP 流能够被正确地同步和播放。



## RTCP

​		RTP只负责传输数据包，需要与RTCP配合使用，由RTCP来保证RTP数据包的服务质量。

​		RTCP的主要功能是：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。

​		在RTP会话期间，各参与者周期性传送RTCP数据包，RTCP数据包中包含已发送的数据包数量、丢失的数据包数量等信息，各参与者通过这些信息动态改变传输速率或传输的数据类型，甚至改变有效载荷类型。

​		RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。


| 类型 | 缩写                             | 用途       |
| ---- | -------------------------------- | ---------- |
| 200  | SR（Sender Report）              | 发送端报告 |
| 201  | RR（Receiver Report）            | 接收端报告 |
| 202  | SDES（Source Description Items） | 源点描述   |
| 203  | BYE                              | 结束传输   |
| 204  | APP                              | 特定应用   |

![img](https://pic4.zhimg.com/80/v2-1954a33c0a99bc236f928b7d27ff23a7_720w.webp)

### SR

​		发送端报告分组SR（Sender Report）用来使发送端以多播方式向所有接收端报告发送情况。

- 相应的RTP流的SSRC
- RTP流中最新产生的RTP分组的时间戳和NTP，
- RTP流包含的分组数
- RTP流包含的字节数

```c
// 0  2 3     8       16                  32
// ----------------------------------------
// |v |p| RC  |   PT   |     length        |
//-----------------------------------------
// |		SSRC of Sender				 |
//-----------------------------------------
// |		NTP timerstamp,				 |
//-----------------------------------------
// |		RTP Timestamp				 |
//------------------------------------------
//|          Sender’s packet count		   |
//-------------------------------------------
//|			Sender`s octet count		  |
//-------------------------------------------
//|			SSRC_1						 |------------|
//------------------------------------------			|
//|Frac Lost|Cumulative number of pack lost |			|
//------------------------------------------			|
//|  Extended high est seq nunmber received |			|
//-------------------------------------------			|    ssrc_1
//|			Interarrival jitter			  |			   |
//------------------------------------------			|
//|			Last SR(LSR)				 |			  |
//------------------------------------------			|
//|			Delay since last SR(DLSR)	  |--------------
//------------------------------------------
//|			SSRC_2(SSRC of second source)  |------------
//------------------------------------------			   n个 ssrc
//|				....					|-------------
//------------------------------------------
//|			profile-specific extensions   |
//-----------------------------------------

/*
- 版本号（V）：2比特，用来标志使用的RTP版本
- 填充位（P）：1比特，如果置位,则该RTP包的尾部就包含附加的填充字节。
- 接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。
- 包类型（PT）：8比特，SR包是200。
- 长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。
- 同步源（SSRC）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。
- NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。
	- NTP的作用是同步不同的RTP媒体流。
- RTP Timestamp：与NTP时间戳对应
	- 与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。
- Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。
- Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。
- 同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。
- 丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。
- 累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。
- 收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，
- 接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计
- 上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。
- 上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。
*/
```



## 会话

​		当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP发送过程如下，接收过程则相反。

1) RTP协议从上层接收流媒体信息码流（如H.264），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。
2) RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的奇数端口。

注意：

1. 根据*RTP*包的序列号来排序。
2. 根据声音流和图像流的相对时间（即*RTP*包的时间戳），以及它们的绝对时间（即对应的*RTCP*包中的*RTCP*），可以实现声音和图像的同步。
3. 接收缓冲用来排序乱序了的数据包；播放缓冲用来消除播放的抖动，实现等时播放。



## jrtplib

```c++
// 初始化
RTPSession sess; 
sess.Create(5000);

//3.11版jrtplib库的Create方法被修改为Create(sessparams,&transparams)
RTPUDPv4TransmissionParams transparams;
RTPSessionParams sessparams;
sessparams.SetOwnTimestampUnit(1.0/8000.0);/*设置时间戳，1/8000表示1秒钟采样8000次，即录音时的8KHz*/
sessparams.SetAcceptOwnPackets(true);
transparams.SetPortbase(portbase);/*本地通讯端口*/
```



```c++
// 数据发送

//RTP 协议允许同一会话存在多个目标地址
unsigned long addr = ntohl(inet_addr("127.0.0.1"));
sess.AddDestination(addr, 6000);

sess.SetDefaultPayloadType(0);
sess.SetDefaultMark(false);  
sess.SetDefaultTimeStampIncrement(10);

sess.SendPacket((void *)buffer,sizeof(buffer),0,false,8000);
```



```c++
// 数据接收

sess_client.Poll();   //接收发送过来的 RTP 或者RTCP 数据报

sess_client.BeginDataAccess();

if (sess.GotoFirstSourceWithData()) {     //遍历那些携带有数据的源
 do {   
          sess.AddToAcceptList(remoteIP, allports,portbase);
           sess.SetReceiveMode(RECEIVEMODE_ACCEPTSOME);
 
           RTPPacket *pack;         
          pack = sess.GetNextPacket();            // 处理接收到的数据    
           delete pack;   }
 while (sess.GotoNextSourceWithData());
 }

sess_client.EndDataAccess();
```



## 性能优化

###  使用合适的编解码器

编解码器的选择对RTP传输性能影响很大，不同的编解码器对带宽、延迟、丢包容忍等方面的要求不同。因此，选择合适的编解码器是优化RTP性能的重要一步。

###  选择合适的传输协议

RTP通常结合使用UDP或[TCP](https://cloud.tencent.com/developer/techpedia/1603)进行传输。UDP传输速度快，但不可靠，TCP传输可靠，但延迟较高。因此，需要根据具体应用场景选择合适的传输协议。

###  使用前向纠错（FEC）

FEC是一种通过添加冗余数据来恢复丢失数据的技术，可以提高RTP传输的可靠性。但是，FEC也会增加传输的带宽消耗，因此需要根据具体情况进行权衡。

###  使用RTCP

RTCP是RTP的控制协议，可以用来监测网络状态、调整发送速率等，从而优化RTP传输性能。例如，可以通过RTCP的反馈机制实现丢包重传。

###  选择合适的网络拓扑结构

对于多点通信场景，选择合适的网络拓扑结构可以减少[网络延迟](https://cloud.tencent.com/developer/techpedia/1611)和带宽消耗，从而提高RTP传输性能。

###  避免网络拥塞

网络拥塞会导致丢包率增加，从而影响RTP传输性能。因此，需要采取一些措施，如拥塞控制、流量控制等，避免网络拥塞。

###  优化网络质量

优化网络质量可以减少丢包率、延迟等问题，从而提高RTP传输性能。例如，可以采用QoS技术、多路径传输技术等来优化网络质量。



## 安全问题

###  数据泄露

由于RTP不提供[数据加密](https://cloud.tencent.com/developer/techpedia/1565)功能，音频和视频数据在传输过程中可能被窃听或篡改。这可能导致隐私泄露和[数据完整性](https://cloud.tencent.com/developer/techpedia/1767)受损。

###  未经授权的访问

RTP没有内置的访问控制机制，因此攻击者可能会加入到RTP会话中，接收或发送音视频数据。

###  拒绝服务攻击（DoS）

攻击者可以通过发送大量伪造的RTP数据包，消耗目标系统的网络带宽和处理资源，导致服务中断。

###  重放攻击

攻击者可能会截获并重新发送RTP数据包，导致音视频数据的重复播放。

###  信令劫持

攻击者可能会劫持与RTP相关的信令协议（如SIP或SDP），篡改会话参数，影响音视频质量或导致服务中断。



## 解决安全问题

###  使用安全实时传输协议（SRTP）

SRTP是RTP的一个扩展，提供了数据加密、完整性保护和重放攻击防护功能。通过使用SRTP，可以确保音视频数据在传输过程中的安全性。

###  实施访问控制

在应用层实现访问控制机制，以防止未经授权的访问。例如，可以使用密码保护的会议室、令牌认证等方法限制RTP会话的参与者。

###  配置防火墙和入侵检测系统（IDS）

通过[防火墙](https://cloud.tencent.com/developer/techpedia/1671)和IDS，可以阻止恶意流量和拒绝服务攻击。

###  使用安全的信令协议

使用安全版本的信令协议（如SIPS和SDPS），以保护会话参数和防止信令劫持。

###  监控网络流量

实时监控网络流量，及时发现异常行为和潜在攻击。



## rtp/rtsp/rtmp

1. RTP 通常用于 VoIP 和视频会议等实时应用。
2. RTSP 用于流媒体服务，允许客户端控制媒体流的播放、暂停和停止等操作。
3. RTMP 通常用于实时广播和 Flash 视频流传输。