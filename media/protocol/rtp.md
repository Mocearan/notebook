# RTP

​		`Real-time Transport Protocol,`实时传输协议。

> ​		`RTP`的`T`是`transport`，不同于`RTSP/RTMP`的`T`是`Time`
>
> - 一般基于`UDP`，如果需要的话可以使用`TCP`或者 `ATM`等其它协议
> - 如果底层网络支持多路分发，`RTP` 还可以将数据传输给多个目标(多播)

---

​		为实时传输交互的音频和视频提供了端到端传输服务，可以看成是传输层的一个子层。包括载荷的类型确认，序列编码，时间戳和传输监控功能。

​		不提供任何机制以保证数据的实时性和 `QOS `(quality-of-service)，而是依赖底层的服务来提供这些功能。

- 不保证传输的可靠性
- 不保证无序传输
- 不假定底层网络是可信任的和有序的。

> 接收端可以利用 `RTP `中的序列号重排收到的报文。

​		`RTP/RTCP`实际上是流媒体领域中特殊的传输层

- 设计`RTP`协议为了规避`TCP`协议的一些缺点
  - `TCP`协议在操作系统的协议栈上实现了流量和拥塞控制等机制，但是太过通用
  - 流媒体传输`UDP`更适合，但也需要拥塞控制等功能
- `RTP/RTCP`协议，专为解决音视频低延时等场景



​	




​		

## 参考

[RTP/RTCP协议_5g中的rtcp报文-CSDN博客](https://blog.csdn.net/guoyunfei123/article/details/106261215?ops_request_misc=%7B%22request%5Fid%22%3A%22166149958616782414924248%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=166149958616782414924248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-2-106261215-null-null.article_score_rank_blog&utm_term=RTP%2FRTCP&spm=1018.2226.3001.4450)

[RFC 6184 - RTP Payload Format for H.264 Video (ietf.org)](https://datatracker.ietf.org/doc/html/rfc6184)

[ RTP Payload Format for High Efficiency Video Coding (HEVC)](https://mirrors.nju.edu.cn/rfc/rfc7798.html)

[Real-Time Transport Protocol (RTP) Parameters (iana.org)](https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml)

系统性学习，直接看RFC3550规范即可

[H.264 RTPpayload 格式------ H.264 视频 RTP 负载格式（包含AAC部分解析） - DoubleLi - 博客园 (cnblogs.com)](https://www.cnblogs.com/lidabo/p/7233279.html)

[音视频传输：RTP协议详解和H.264打包方案_rtsp和h264的关系-CSDN博客](https://blog.csdn.net/weixin_41422027/article/details/101530795)

[使用FFmpeg命令行进行UDP、RTP推流（H264、TS），ffplay接收-腾讯云开发者社区-腾讯云 (tencent.cn)](https://cloud.tencent.cn/developer/article/2038204)



## 概念

### 混频器 `Mixer`

​		中间系统。`RTP`是一个多数据源协议，接收端需要处理多个数据来源（视频、音频、多发送端等）。混频器将一个或多个媒体源的`RTP`数据包重新编码合成一个新的`RTP`数据包，然后转发出去。

- 混频器可能会改变数据包的数据格式
- 组合的新数据包生成一个以混频器作为同步源的新`SSRC`
  - 过贡献源列表（`CSRC`表）可以确认合成源的参与者

> ​		混频器将来自一个源或多个源的音频包进行重构，并把重构后的多个音频合并，采用另一种音频编码进 行编码后，再转发这个新的RTP包。从一个混合器出来的所有数据包要用混合器作为它们的同步源（SSRC，见RTP的封装）来识别，可以通过贡献源列表（CSRC表，见RTP的封装）可以确认谈话者。

### 转换器 `translator`

​		中间系统，用于通过IP多播无法直接到达的用户区，如在防火墙两端使用转换器，外侧转换器通过安全连接将数据传输到内侧转换器。

​		转发RTP数据包但不改变数据包的同步源标识符。

​		![img](https://pic4.zhimg.com/80/v2-0ae7c935f58299315a533a5d5439a1f7_720w.webp)

![img](https://pic1.zhimg.com/80/v2-fd973eef1b3978f7cc5121965dacb0f0_720w.webp)



### 序列号

​		用来区分`RTP`报文，检测丢包和乱序。是一个16位的二进制整数，以1递增，达到最大时自动恢复为0。

​		因为序列号永远连续递增，可以根据检测序列号递增判断是否丢包：接收到的包序列号大于1的跳跃认为丢包，根据序列号是否被打乱判断是否乱序。

### 时间戳

​		 时间戳反映了RTP分组中的数据的第一个字节的采样时刻。在一次会话开始时的时间戳初值也是随机选择的。即使是没有信号发送时，时间戳的数值也要随时间不断的增加。接收端使用时间戳可准确知道应当在什么时间还原哪一个数据块，从而消除传输中的抖动。时间戳还可用来使视频应用中声音和图像同步。

​		在RTP协议中并没有规定时间戳的粒度，这取决于有效载荷的类型。因此RTP的时间戳又称为媒体时间戳，以强调这种时间戳的粒度取决于信号的类型。例如，对于8kHz采样的话音信号，若每隔20ms构成一个数据块，则一个数据块中包含有160个样本（0.02×8000=160）。因此每发送一个RTP分组，其时间戳的值就增加160。

- 时间戳单位，采样频率的倒数
  - 采样频率90000Hz时间戳单位为1/90000s，帧率25则每帧占90000/25=3600个时间戳单位。
  - 即一个采样间隔的时间
    - 比如一般的音频是8K的采样频率，也就是一毫秒采集8次数据，也就是每次采样间隔是1/8MS
    - timestamp增加1也就意味着增加了一个采样间隔。也就是过了1/8MS
    - 同一个系统中，对不同编码，虽然使用同一个时钟，但timestamp的增长速度是不同的
  
- 首先，时间戳就是一个值，用来反映某个数据块的产生（采集）时间点的，后采集的数据块的时间戳肯定是大于先采集的数据块的。有了这样一个时间戳，就可以标记数据块的先后顺序。   
- 第二，在实时流传输中，数据采集后立刻传递到RTP模块进行发送，那么，其实，数据块的采集时间戳就直接作为RTP包的时间戳。   
- 第三，如果用RTP来传输固定的文件，则这个时间戳就是读文件的时间点，依次递增。这个不再我们当前的讨论范围内，暂时不考虑。   
- 第四，时间戳的单位采用的是采样频率的倒数，例如采样频率为8000Hz时，时间戳的单位为1 / 8000 ，在Jrtplib库中，有设置时间戳单位的函数接口，而ORTP库中根据负载类型直接给定了时间戳的单位（音频负载1/8000，视频负载1/90000）   
- 第五，时间戳增量是指两个RTP包之间的时间间隔，详细点说，就是发送第二个RTP包相距发送第一个RTP包时的时间间隔（单位是时间戳单位）。  

> 如果采样频率为90000Hz，则由上面讨论可知，时间戳单位为1/90000，我们就假设1s钟被划分了90000个时间块，那么，如果每秒发送25帧，那么，每一个帧的发送占多少个时间块呢？当然是 90000/25 = 3600。因此，我们根据定义“时间戳增量是发送第二个RTP包相距发送第一个RTP包时的时间间隔”，故时间戳增量应该为3600。

### 同步信源

​		同步信源是产生媒体流的信源，如麦克风、摄像机、RTP混合器等。是RTP包头中一个32位数字SSRC标识符，不依赖于网络地址，接收者将根据SSRC标识符来区分不同的信用，进行RTP报文的分组。

​		SSRC相当于一个RTP传输session的ID，即RTP包发出方的标识。同一个RTP会话中不会有两个相同的SSRC值，所以当RTP发送者传输地址改变时，SSRC会重新生成。

​		SSRC是随机产生的，并且保证唯一。



### 贡献信源

​		RTP 的同步源 (SSRC) 标识符用于标识同步源，即 RTP 流的源。在复杂的场景中，例如视频会议，可能有多个同步源。SSRC 保证了 RTP 流能够被正确地同步和播放。

​		当混合器接收到一个或多个同步信源的RTP报文后，经过混合处理产生一个新的组合RTP报文，并把混合器作为组合后的RTP报文的SSRC。原来所有的SSRC都作为贡献信源（CSRC）传送给接收者，使得接收者知道组成组合报文的各个SSRC。

​		一个RTP包所属源，对RTP混频器生成的组合流起了作用，它就是一个贡献源。对生成包起作用的源的SSRC标识符会被混频器添加到RTP包头贡献源列表，这个列表叫做CSRC表。

​		一般混合的RTP流中，每隔一段时间，就会有一个RTP报文包含了完整的CSRC表。



### 有效载荷

​		由`RFC3551`指定，有些负载类型诞生的较晚，没有具体的PT值，智能使用动态PT值，即96到127，H264被普遍指定为96.



## 特点


- 乱序重排：在UDP低延迟传输基础上增加了时间戳和序列号，在接收端重排数据包
  - 时间戳，标识音视频数据的时间戳，在接收端进行音视频同步
    - 在发送端，时间戳的值为音视频数据的采样时间，可以通过采样率计算得到
    - 在接收端，通过时间戳的值，可以确定音视频数据的播放时间
  - 序列号，标识音视频数据的顺序，以便在接收端进行数据包的重排
    - 在发送端，每个数据包都有一个唯一的序列号，表示该数据包在音视频[数据流](https://cloud.tencent.com/developer/techpedia/1734)中的位置。
    - 在接收端，通过序列号的值，可以确定音视频数据包的顺序，从而进行数据包的重组和播放
- 丢包重传，RTP协议可以使用丢包重传机制，对丢失的数据包进行重传

- 负载识别：RTP 头部包含有关负载类型（例如音频、视频、编码格式等）的信息
- 支持多种音频和视频编码格式
  - 包括MPEG、H.264、G.711、G.729等。
- 性能监控：通过`RTCP`在收发两端交换传输质量信息，如丢包率、延迟等
  - 动态调整传输参数以优化性能
  - 使用延迟控制技术，对数据包的延迟进行控制，以保证音视频数据的实时性
- 多媒体同步：时间戳能够让接收端同步在一个会话中传输多个媒体流（例如音频和视频）
- 可扩展性：支持扩展头部
  - 可以在头部中添加一些自定义的信息，扩展功能
- 前向纠错：对音视频数据进行冗余编码，以便在接收端检测和纠正错误
  - 可以将相邻的几个数据包进行编码，生成一个冗余数据包，当其中一个数据包丢失时，接收端可以使用冗余数据包来恢复数据





## 协议结构

### 协议栈

![在这里插入图片描述](https://img-blog.csdnimg.cn/dcb599171e054b88b1459aac5c07e1d9.png)

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/bripengandre/%E6%B5%81%E5%AA%92%E4%BD%93%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.JPG)

​		`RTP`端口用于传输音视频数据，`RTCP`端口用于传输控制信息

- `RTP`会话使用合法的偶数端口（`2n）`，对应的RTCP包使用下一个奇数端口（`2n+1`）

- `RTP`提供低延时的数据传输

- `RTCP` 来完成流量控制和拥塞监控
  - 进行服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识
  - 基于`RTCP`增加`GCC / BBR`等拥塞控制算法提高网络传输性能

### RTP



```c
// 0  2 3 4   8  9      16                32
// ----------------------------------------
// |v |p|x| cc |M|  PT   |     seq        |
//-----------------------------------------
// |		ts						   |
//-----------------------------------------
// |		ssrc					    |
//------------------------------------------------|
// | defined by profile | Extension header length|| 
//-----------------------------------------|	optional header 
// |  0~4 byte Extension header		      |      |
//         .....
//------------------------------------------------|
// |		csrc						|
//------------------------------------------
//|          ....						 |
//------------------------------------------
//|           payload data				  |
//------------------------------------------
//|padding len|        padding             |
//------------------------------------------

/*
- 版本号（V）：2比特，用来标志使用的RTP版本
- 填充位（P）：1比特，如果置位（== 1）,则该RTP包的尾部就包含附加的填充字节（optional header）。
- 扩展位（X）：1比特，如果置位, RTP固定头部后面就跟有一个扩展头部。
- CSRC计数器（CC）：4比特，含有固定头部后面跟着的CSRC的数目。
- 标记位（M）：1比特,该位的解释由配置文档（Profile）来承担.
	- 不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。
- 载荷类型（PT）：7比特，标识了RTP载荷的类型。
	- 如GSM音频、JPEM图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。
- 序列号（SN）：16比特, 标识发送者所发送的RTP报文的序列号
	- 发送方在每发送完一个RTP包后就将该域的值增加1
	- 接收方可以由该域检测并记录丢包量(UDP弱网) 及 恢复包序列（网络抖动）
	- 序列号的初始值是随机的
		- 在helix服务器中这个字段是从0开始的，同时音频包和视频包的sequence是分别记数的。
- 时间戳：32比特，记录了该包中数据的第一个字节的采样时刻。
	- 根据发送端的时钟生成的，并且与 PTS/DTS 有关联但不完全相同
		- 反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。
	- 在一次会话开始时，时间戳初始化成一个初始值。
	- 时间戳是去除抖动和实现同步不可缺少的。
	- 即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）
- 同步源标识符(SSRC)：32比特，同步源就是指RTP包流的来源。
	- 在一个RTP会话中，每个数据流的SSRC都不同
	- 该标识符是随机选取的 RFC1889推荐了MD5随机算法。
- 贡献源列表（CSRC List）：0～15项，每项32比特
	- 标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。
	- 由混频器将这些有贡献的SSRC标识符插入表中。
	- SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份。
- 负载数据 payload data： 0~65535
*/

// 在实时音视频传输中，音频和视频数据通常是分开发送的。RTP 时间戳可以帮助接收端同步这两种类型的媒体流，确保音频和视频能够同时播放，从而提供更好的用户体验。
// RTP 时间戳的主要目的是为了在接收端同步音视频流的播放。接收端可以通过比较音频和视频 RTP 数据包的时间戳来同步音频和视频的播放。
// 在实际应用中，RTP 时间戳可能是基于编码中的 PTS 或 DTS 生成的，但经过了一定的转换。RTP 时间戳可能是 PTS 或 DTS 的一个简化版本，或者是经过缩放的版本，以适应 RTP 协议的需要。
// RTP 时间戳还用于处理网络抖动。由于网络的不稳定性，数据包可能会在不同的时间到达接收端。RTP 时间戳允许接收端重新排序数据包，确保音视频数据的连续播放。
// PTS/DTS 主要用于解码和显示视频帧，而 RTP 时间戳用于同步和排序 RTP 数据包。RTP 时间戳通常是基于发送端的时钟生成的，而 PTS/DTS 是基于编码的时间基准。
/*
    if (audioPacket->getTimestamp() < videoPacket->getTimestamp()) {
        // 如果音频 RTP 数据包的时间戳较小，可能需要延迟视频的播放，以实现同步
    } else if (audioPacket->getTimestamp() > videoPacket->getTimestamp()) {
        // 如果音频 RTP 数据包的时间戳较大，可能需要延迟音频的播放，以实现同步
    } else {
        // 如果 RTP 时间戳相等，音频和视频可以同时播放
    }
*/

```





#### 固定头部 `12bytes`

​		`Fixed Header，12 byte`

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dc59599c01744d923bb93080cdea0091.png#pic_center)

- `v`：`2bit`，用来标志使用的RTP版本
- `P`：`1bit`，填充标识，如果该位为 1，则该RTP包的尾部就包含附加的填充字节
  - 填充字节的第一字节的值表示填充的字节数（包含该长度字节本身）
  - 一般在一些需要固定块大小的加密算法中才需要填充
- `X`：`1bit`，扩展标识，如果该位为 `1`，RTP固定头部后面就跟有一个扩展头部
- `CC`：`4bit`，`CSRC`计数器，共享媒体源个数，一般用于混音和混屏中
  - 构成混合媒体源的各个部分
  - 四位说明则最大支持15个CSRC，一般默认为0
- `M`： `1bit`，Mark 标记位，该位的解释由配置文档（Profile`）`来负责。
  - 使用 `RTP `荷载 `H264 `码流时，如果帧分包传输，可以用该位标记是否为帧的最后一个包
    - 视频的`I frame`比较大，需要通过多个`NALU`来传输，当看到`M`位为1时就认为是这个`I frame`结束
    - 一般不进行组合传输，一个`RTP`包荷载一个`NALU`
- `PT`：`7bit`，标识了`RTP`载荷的类型
  - 对应的编解码类型参考[该文档](https://www.rfc-editor.org/rfc/rfc3551.html#page-32)
  - https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/RTP_payload_formats%25E3%2580%2582
- `Sequence number`：`16bit`，每发送一个 `RTP `数据包，序列号增加1
  - 序列号初始值是随机的
  - 当达到最大值后，则重新从0开始
  - UDP是不可靠传输协议，通过这个字段进行重新排序，收到RTP数据第一件事就是排序
  - 发送端的音频和视频都是通过`RTP`传输的，但是两组独立的序列号
- `Timestamp`：`4byte`，记录了该包中数据的第一个字节的采样时刻
  - 时间戳是采样率的倒数，不是真实的时间
    - 反应的RTP报文第一个八位组的采样时刻，目的是为了接收端计算延迟、抖动和音视频同步
  - 一个帧的数据可能被分成多个 `RTP `包发送
    - 同一个帧的多个RTP包的时间戳是相同的，不同帧的时间戳是不相同的
- `SSRC`：`4 byte`，同步源就是指RTP包流的来源
  - 不同的 `SSRC `标识不同的媒体源
    - 例如不同用户的音频就属于不同的媒体源，具有不同的 `SSRC`
    - 相当于一个RTP传输session的ID
  - 在会话中标识RTP负载流的身份，给一个唯一标记值
    - 不依赖于网络地址，接收者将根据`SSRC`标识符来区分不同的信源，进行RTP报文的分组
  - 只要保证在一路音视频会话里面值不相同即可
    - 随机产生，并且要保证唯一
    - RFC1889推荐了MD5随机算法
- `CSRC identifiers`：`4 byte group`，贡献媒体源列表，用来标志对`RTP`混频器产生的混合包有贡献的所有源
  - `CSRC `最多 `15 `个，每项`32bit`
  - 具体数量由`CC`指定
  - 前面的`12`个字节是固定存在于每个`rtp`中，而后面的`CSRC`只有当混频器存在时才会被插入
  - 如果是1对1的流媒体传输，这个字段就不用处理，直接忽略该字段
  - 混流和混音时，则需要把各方的RTP同步信号源列出来，这样接收端就能正确指出交谈双方的身份





```c
// 按小端定义
struct rtp_hdr {
	unsigned char cc:4; // CSRC count
	unsigned char x:1; // header extension flag
	unsigned char p:1; // padding flag
	unsigned char version:2;
    
	unsigned char pt:7; // payload type
	unsigned char m:1; // marker bit
    
	uint16_t seq; // sequence number
	uint32_t ts; // timestamp
	uint32_t ssrc; // synchronization source
    // non-optional header
    uint32_t csrc[]; // contribution source list
};  // sizeof(rtp_hdr) 返回的结构大小不包括柔性数组的内存。
```



#### 可选头部 `0~32bytes`

![img](https://raw.githubusercontent.com/Mocearan/picgo-server/main/68e5d0721d7873901f9d5a9001187119.jpeg)

​		`Optional Header`， `0~32 byte`

-  `profile `定义，`2 byte`

  - `Profile`：RTP 扩展头部有两种类型
    - `one-byte header`
      - 当` Profile = 0xBEDE` 时表示使用 `one-byte header `
    -  `two-byte header`
      - `Profile = 0x1000` 时表示使用` two-byte header`
    - 扩展头部个数由 Extension header length 决定
  
- `Extension header length`， `2 byte`

  - 表示后面的 `Extension header` 共有几个字节，长度以 4 字节为单位

    > 例如 length = 3 表示 Extension header 一共占 3*4=12 个字节

  - 0~32 byte之间，不包括扩展头的4字节
  
- `Extension header`, `0~4 byte`

  -  最多7个
    -  32 字节 - 4 字节 = 28 字
    -  28 字节 ÷ 4 字节 = 7 块



#### 拓展头部 `4bytes/per`

​		`Extension header`，每个拓展头部4字节

- 由 `ID / Length / data` 组成

- 可以是 `one-byte header` 或者` two-byte header `组织方式



##### one-byte header  

​		由` ID，L，data` 三部分组成

- ID 和 L 分别占 `4 bit`，加起来等于 `one-byte`

- ID 表示扩展头部 ID 标记，

- L 表示 ` extension data` 所占字节数减1

  > ​	例如 L = 0 时实际 `data `占一个字节，由于头部需要按 4 字节对齐，因此中间补充了 `padding `数据。`extension header `占 4 字节。
  >
  > ![img](https://raw.githubusercontent.com/Mocearan/picgo-server/main/1793bc0b92ad4b91b70c1b136093ef51.png)

##### two-byte header 

​		由 `ID, L, data `三部分组成

- `ID`，`L `各占`1`字节，共`2`字节
- `L `表示 `extension data` 所占的字节数（不同于` one-byte header `需要减一）
- ![img](https://raw.githubusercontent.com/Mocearan/picgo-server/main/2bbe4dd31dec41cfb487e212aeedf85d.png)

##### header extension ID 

​		关于具体某个扩展头部的含义可以参考 RFC 或者 [webrtc 文档](https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext)。

```cpp
enum RTPExtensionType : int {
kRtpExtensionNone,
kRtpExtensionTransmissionTimeOffset,
kRtpExtensionAudioLevel,
kRtpExtensionInbandComfortNoise,
kRtpExtensionAbsoluteSendTime,
kRtpExtensionAbsoluteCaptureTime,
kRtpExtensionVideoRotation,
kRtpExtensionTransportSequenceNumber,
kRtpExtensionTransportSequenceNumber02,
kRtpExtensionPlayoutDelay,
kRtpExtensionVideoContentType,
kRtpExtensionVideoTiming,
kRtpExtensionFrameMarking,
kRtpExtensionRtpStreamId,
kRtpExtensionRepairedRtpStreamId,
kRtpExtensionMid,
kRtpExtensionGenericFrameDescriptor00,
kRtpExtensionGenericFrameDescriptor = kRtpExtensionGenericFrameDescriptor00,
kRtpExtensionGenericFrameDescriptor02,
kRtpExtensionColorSpace,
kRtpExtensionNumberOfExtensions  // Must be the last entity in the enum.
};
```



```c
static int parsingRTPPacket(uint8_t *data, size_t size) 
{  
    if (size < 12) {  
        //Too short to be a valid RTP header.  
        return -1;  
    }  
  
    if ((data[0] >> 6) != 2) {  
        //Currently, the version is 2, if is not 2, unsupported.  
        return -1;  
    }  
  
    if (data[0] & 0x20) {  
        // Padding present.  
        size_t paddingLength = data[size - 1];  
        if (paddingLength + 12 > size) {  
            return -1;  
        }  
        size -= paddingLength;  
    }  
  
    int numCSRCs = data[0] & 0x0f;  
    size_t payloadOffset = 12 + 4 * numCSRCs;  
  
    if (size < payloadOffset) {  
        // Not enough data to fit the basic header and all the CSRC entries.  
        return -1;  
    }  
  
    if (data[0] & 0x10) {  
        // Header extension present.  
        if (size < payloadOffset + 4) {  
            // Not enough data to fit the basic header, all CSRC entries and the first 4 bytes of the extension header.  
            return -1;  
        }  
  
        const uint8_t *extensionData = &data[payloadOffset];  
        size_t extensionLength = 4 * (extensionData[2] << 8 | extensionData[3]);  
  
        if (size < payloadOffset + 4 + extensionLength) {  
            return -1;  
        }  
        payloadOffset += (4 + extensionLength);  
    }  
  
    uint32_t rtpTime = data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7];  
    uint32_t srcId = data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11];  
    uint32_t seqNum = data[2] << 8 | data[3];  
  
    return 0;  
}  
```



#### RTP over TCP

​		[RTSP - RTP over TCP - DoubleLi - 博客园 (cnblogs.com)](https://www.cnblogs.com/lidabo/p/4483497.html)



​		`RTP `默认是采用 `UDP `发送的，格式为 `RTP` 头+`RTP `载荷，**如果是使用 `TCP`，那么需要在 `RTP `头之前再加上四个字节**

- `byte 1`：`Magic(0x24)`，辨识符
- `byte 2`：`Channel`，通道。在 `SETUP `的过程中获取
- `byte 3/4`：`Length`，`RTP `包的大小
  - `RTP`头部+载荷
  - 最多只能 12 位
  - 第三个字节保存高 4 位，第四个字节保存低 8 位


![rtpExample](https://raw.githubusercontent.com/Mocearan/picgo-server/main/d06dcc585a0c0353d91be3d0f277ab6e.png)



### RTCP

​		`RTCP`保证`RTP`数据包服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。

- 动态调整服务质量
- 有效控制网络拥塞
- `RTCP`数据报采用的是多播方式
  - 会话中的所有成员都可以通过`RTCP`数据报返回的控制信息，来了解其他参与者的当前情况。

> ​		在`RTP`会话期 间，各参与者周期性地传送`RTCP`包。
>
> ​		`RTCP`包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。
>
> ​		`RTP`和`RTCP`配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。



| 类型 | 缩写                             | 用途                                                         |
| ---- | -------------------------------- | ------------------------------------------------------------ |
| 200  | SR（Sender Report）              | 发送端报告<br />所谓发送端是指发出RTP数据报的应用程序或者终端，发送端同时也可以是接收端。 |
| 201  | RR（Receiver Report）            | 接收端报告<br />所谓接收端是指仅接收但不发送RTP数据报的应用程序或者终端。 |
| 202  | SDES（Source Description Items） | 源点描述<br />主要功能是作为会话成员有关标识信息的载体，如用户名、邮件地址、电话号码等，此外还具有向会话成员传达会话控制信息的功能。 |
| 203  | BYE                              | 结束传输<br />主要功能是指示某一个或者几个源不再有效，即通知会话中的其他成员自己将退出会话。 |
| 204  | APP                              | 特定应用<br />由应用程序自己定义，解决了RTCP的扩展性问题，并且为协议的实现者提供了很大的灵活性。 |

![img](https://pic4.zhimg.com/80/v2-1954a33c0a99bc236f928b7d27ff23a7_720w.webp)



#### SR

​		发送端报告分组`SR（Sender Report）`用来使发送端以多播方式向所有接收端报告发送情况。主要内容有：

- 相应的`RTP`流的`SSRC`
- `RTP`流中最新产生的`RTP`分组的时间戳和`NTP`，
- `RTP`流包含的分组数
- `RTP`流包含的字节数

> 只讲述SR类型，而其它类型请参考RFC3550

```c
// 0  2 3     8       16                  32
// ----------------------------------------
// |v |p| RC  |   PT   |     length        |
//-----------------------------------------
// |		SSRC of Sender				 |
//-----------------------------------------
// |		NTP timerstamp,				 |
//-----------------------------------------
// |		RTP Timestamp				 |
//------------------------------------------
//|          Sender’s packet count		   |
//-------------------------------------------
//|			Sender`s octet count		  |
//-------------------------------------------
//|			SSRC_1						 |------------|
//------------------------------------------			|
//|Frac Lost|Cumulative number of pack lost |			|
//------------------------------------------			|
//|  Extended highest seq nunmber received  |			|
//-------------------------------------------			|    ssrc_1
//|			Interarrival jitter			  |			   |
//------------------------------------------			|
//|			Last SR(LSR)				 |			  |
//------------------------------------------			|
//|			Delay since last SR(DLSR)	  |--------------
//------------------------------------------
//|			SSRC_2(SSRC of second source)  |------------
//------------------------------------------			   n个 ssrc
//|				....					|-------------
//------------------------------------------
//|			profile-specific extensions   |
//-----------------------------------------

/*
- 版本号（V）：2比特，用来标志使用的RTP版本
- 填充位（P）：1比特，如果置位,则该RTP包的尾部就包含附加的填充字节。
- 接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。
- 包类型（PT）：8比特，SR包是200。
- 长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。
- 同步源（SSRC）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。
- NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。
	- NTP的作用是同步不同的RTP媒体流。
- RTP Timestamp：与NTP时间戳对应
	- 与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。
- Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。
- Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。

- 同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。
- 丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP丢包率。
- 累计的包丢失数目(Cumulative number of pack lost)：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。
- 收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号，
- 接收抖动（Interarrival jitter）：RTP数据包接收时间的统计方差估计
- 上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。
- 上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。
*/
```





#### 时间戳

​		在`RTCP`中，还有两个比较重要的东西，一个64位的绝对时间戳和一个32位的相对时间戳。

​		`64 `位时间戳也叫`NTP`时间戳：它的前32位是从1900 年1 月1 日0 时开始到现在的以秒为单位的整数部分，后32 位是此时间的小数部，因此，它可以肯定的表示了数据发送出去的绝对时间。

​		32位的时间戳和RTP中的时间戳是一样的，没有任何区别。



#### `RTCP `组合包

​		`RTCP`封装的仅仅是一些控制信息，分组很短，可以将多个`RTCP`分组封装在一个`UDP`包中。

​		不需要插入任何分隔符就可以将多个`RTCP`包连接起来形成一个`RTCP`组合包，然后由低层协议用单一包发送出去。由于需要低层协议提供整体长度来决定组合包的结尾，在组合包中没有单个`RTCP`包的显式计数。

​		组合包中每个`RTCP`包可独立处理，而不需要按照包组合的先后顺序处理。在组合包中有以下几条强制约束：

1、只要带宽允许，在`SR`包或`RR`包中的接收统计应该经常发送，因此每个周期发送的组合`RTCP `包中应包含报告包。

2、每个组合包中都应该包含`SDES CNAME`，因为新接收者需要通过接收`CNAME`来识别源，并与媒体联系进行同步。

3、组合包前面是包类型数量，其增长应该受到限制。





### profile

​		定义了一系列负载类型和对应的负载格式，也定义了特定于具体应用的 RTP 扩展和修改。

- **RFC3551**(RTP/AVP)在 RFC3550 的基础上针对 RTP 档次进行补充形成 RTP/APVP 档次，被用在具有最小会话控制的音视频会议中，是其它扩展档次的基础。该档次在没有参数协商和成员控制的会话中非常有用。该档次也为音视频定义一系列编码和负载格式。对于具体的流媒体负载格式，IETF 也定义一系列协议详细描述，如 VP8 视频负载格式[6]和 H264 视频负载格式[7]，等等。
- RFC3711(SRTP，也即 RTP/SAVP)是 RTP/AVP 在安全方面进行扩展形成的档次，为 RTP/RTCP 提供数据加密、消息认证、重放保护等功能。SRTP 具有高吞吐量和低数据膨胀等特点，是异构环境下对 RTP/RTCP 数据的有效保护。
- RFC4585(RTP/AVPF)是 RTP/AVP 在及时反馈方面进行扩展形成的档次，使得接收端能够向发送端提供及时反馈，实现短时调整和基于反馈的修复机制。该协议定义早期 RTCP 报文以实现及时反馈，并定义一系列通用 RTCP 反馈报文和特定于应用的反馈报文，如 NACK、PLI、SLI、RPSI 等。
- RFC5124(RTP/SAVPF)则是 RTP/SAVP 和 RTP/AVPF 的综合。SAVP 和 AVPF 在使用时，需要参与者借助于 SDP 协议[8]就档次和参数信息达成一致。但是对一个 RTP 会话来说，这两种档次不能同时被协商。而实际应用中，我们有同时使用这两种档次的需要。因此，RTP/SAVPF 档次应运而生，它能够使得 RTP 会话同时具有安全和及时反馈两方面的特性。



## 应用场景

​		RTP 原先的设计是用来满足多参与者的多媒体会议的需要，它没有限定于专门的应用。连续数据的储存，交互分布式仿真，动态标记，以及控制和测量应用程序也可能会适合使用 RTP

​		多播音频会议中，语音通信通过一个多播地址和一对端口来实现。一个用于音频数据（RTP），另一个用于控制包（RTCP）。

​		音频和视频会议。如果在一次会议中同时使用了音频和视频会议：

- 这两种媒体将分别在不同的RTP会话中传送
- 每一个会话使用不同的传输地址（IP地址＋端口）
- 如果一个用户同时使用了两个会话，则每个会话对应的RTCP包都使用规范化名字`CNAME`（Canonical Name）
- 与会者可以根据`RTCP`包中的`CNAME`来获取相关联的音频和视频，然后根据`RTCP`包中的计时信息(Network time protocol)来实现音频和视频的同步



​		在视频监控、实时直播、语音电话、视频会议都能看到应用。

- `webRTC / GB28181 / ONVIF`将`RTP`作为传输协议。在视频监控和实时视频传输领域`RTP`因其特点而具有统治地位。
- `RTSP`虽然与`RTP/RTCP`关联不深，但`RTSP`仍旧是基于`RTP/RTCP`拓展而来

> - `RTSP`提供了对实时流的会话管理和媒体控制
> - 视频监控中摄像机、`NVR`、前后端之间都是用这个协议和`RTP`协议配合进行流媒体传输
> - 开始播放，暂停、快播这些播放功就需要靠`RTSP`来支持
> - 传输数据的仍然是`RTP`协议，质量保证的是``RTCP``

​		由`RTP`数据传输协议和`RTCP`控制协议构成。数据通过一个多播地址和一对端口传输。



## 性能优化

- 使用合适的编解码器：不同的编解码器对带宽、延迟、丢包容忍等方面的要求不同
- 选择合适的传输协议：根据具体应用场景选择合适的传输协议
  - UDP传输速度快，但不可靠，TCP传输可靠，但延迟较高
- 使用前向纠错（FEC）：通过添加冗余数据来恢复丢失数据，可以提高RTP传输的可靠性
  - 但FEC也会增加传输的带宽消耗，因此需要根据具体情况进行权衡
- 使用RTCP：监测网络状态、调整发送速率等，从而优化RTP传输性能
- 选择合适的网络拓扑结构：，选择合适的网络拓扑结构可以减少网络延迟和带宽消耗
- 避免网络拥塞：拥塞控制、流量控制等，避免网络拥塞
- 优化网络质量：采用QoS技术、多路径传输技术等来优化网络质量。



## 安全问题

- 数据泄露：RTP不提供数据加密功能，数据在传输过程中可能被窃听或篡改
- 未经授权的访问：RTP没有内置的访问控制机制，攻击者可能会加入到RTP会话中，接收或发送音视频数据
- 拒绝服务攻击（DoS）：攻击者可以发送大量伪造的RTP数据包，消耗目标系统的网络带宽和处理资源，导致服务中断。
- 重放攻击：攻击者可能会截获并重新发送RTP数据包，导致音视频数据的重复播放。
- 信令劫持：攻击者可能会劫持与RTP相关的信令协议（如SIP或SDP），篡改会话参数，影响音视频质量或导致服务中断。

​		 解决安全问题

- 使用安全实时传输协议（SRTP）
  - SRTP是RTP的一个扩展，提供了数据加密、完整性保护和重放攻击防护功能
  - 通过使用SRTP，可以确保音视频数据在传输过程中的安全性
- 实施访问控制：在应用层实现访问控制机制，以防止未经授权的访问
  - 例如，可以使用密码保护的会议室、令牌认证等方法限制RTP会话的参与者
- 配置防火墙和入侵检测系统（IDS）
  - 可以阻止恶意流量和拒绝服务攻击
- 使用安全的信令协议：如SIPS和SDPS，以保护会话参数和防止信令劫持
- 监控网络流量：及时发现异常行为和潜在攻击。



## Q&A

### 序列号的作用

- 乱序重排
- 丢包检测

> ​		只表示了包发出的先后顺序，它表示不了任何时间上的其它概念，所有严格的说，序列号并不能作为流内的同步标志。但是，由于一般来说，包的发送时间都会有严格限制，比如音频包是每秒种发送30个数据包，也就是说，每个包间隔1000/30MS，而这个时间就可以作为一个同步时间来播放。也就是说，按照序列号，每1000/30MS间隔播放一个数据包，这样也能保证同步，但是这时候请考虑丢包问题。

### 时间戳的作用

- 乱序重排
- 重组UDP包
- 延迟检测

​		取得绝对时间后，我们就可以根据这个绝对时间来播放这些数据包。这个绝对时间，加上我们需要的延时（用于数据传输，解码等等的时间）就是我们的播放时间，这样我们可以保证时间的严格同步（相当于把对方的动作延时一段时间后原原本本的再现出来）。目前，在RTP中，能得到这个绝对时间的办法只有RTCP。

​    	对于相对时间戳，我们更关心的是两个时间戳之间的时间间隔，依靠这个时间间隔，来确定两个包的播放时间间隔。

- `TimeStamp`

  - 反映了RTP数据包中第一个字节的采样时间

    > 时间戳就是一个值，用来反映某个数据块的产生（采集）时间点的

  - 初始值是随即生成的

  - 然后每一帧数据固定增加一 个增量

    > 几个连续的RTP包如果（逻辑上）是同时产生的，如：属于同一个视频帧的RTP包，将有相同的序列号。

  - 客户端在接收到数据时，根据这个时间戳就能以正确的时间恢复（其中被分包的视频帧是没有时间戳增加的）

    > 采样时钟必须来源于一个及时的单调、线性递增时钟，以便允许同步和去除网络引起的数据包抖动。
    >
    > 如果数 据并不是以它采样的顺序进行传输，那么连续的RTP包可以包含不是单调递增（或递减）的时间戳（RTP包的序列号仍然是单调变化的）。
    >
    > 该时钟的分辨率必须满足理想的同步精度和测量数据包到来时的抖动的需要（一种典型的时钟分辨率不满足情况是每个视频帧仅一个时钟周期）时钟 频率依赖于负载数据的格式，并在描述文件（profile）中或者是在负载格式描述中（payload format speci_cation）进行静态描述。
    >
    > 也可以通过非RTP方法（non-RTP means）对负载格式动态描述。

- `RTCP`的`SR`包里面除了这个时间戳，还 有一个`NTP`时间
  - 距1900年1月1日的秒数，允许每个系统存在差异，只要同一个系统不同流生成值的方式相同就行
  - 以时钟频率为90KHz的视 频为例，若其帧率为30帧，则每一帧的时间戳增量为90000/30=3000
  - RTCP的SR包的时间戳也可以相应计算出来：
    - 增量=（现在时间-上一次 RTP包发送时间）*单位时间增量
    - `单位时间增量=90000*1000000/(2^32)`
      - SR包中的微秒时间形式是`NTP_frac`，因此 要做“`/（2^32）`”这样一个转化

> RFC中说时间戳增量需要满足线性增长，实际上没必要严格按照诸如3000增量来增长，我是按照实际的帧的时间间隔来打的这个时间戳：
>
> `时间戳 = 上一次时间戳 + 采样频率（典型值为90000）*0.000001 *  两帧时间差（单位毫秒）`来计算的
>
> 如果RTP包是周期性产生的，那么将使用由采样时钟决定的名义上的采样时刻，而不是读取系统时间。例如，对一个固定速率的音频，采样时钟（时间戳时钟）将 在每个周期内增加1。如果一个音频从输入设备中读取含有160个采样周期的块，那么对每个块，时间戳的值增加160，而不考虑该块是否用一个包传递或是被 丢弃。

 

- 时间戳单位：时间戳计算的单位不为秒之类的单位，而是由采样频率所代替的单位

  - 这样做的目的就是为了是时间戳单位更为精准
    - 比如说一个音频的采样频率为8000HZ，那么我们可以把时间戳单位设为1/8000
  - RTP协议并没有规定时间戳的粒度，取决于有效载荷的类型
    - 因此RTP的时间戳又称为媒体时间戳，以强调这种时间戳的粒度取决于信号的类型
  - 数据块的采集时间戳就直接作为RTP包的时间戳
  - RTP传输文件，时间戳是读文件的时间点
  - 时间戳单位是采样频率的倒数

  > 例如， 对于8kHz采样的话音信号，若每隔20ms构成一个数据块，则一个数据块中包含有160个样本（0.02&times;8000=160）。因 此每发送一个RTP分组，其时间戳的值就增加160个单位。

- 时间戳增量：相邻两个RTP包之间的时间差（以时间戳单位为基准）

  - 时间戳增量是指两个RTP包之间的时间间隔

  > 　　时间戳增量计算：
  >
  > - 摄像头帧率25 fps，每帧间隔1/25 s
  >
  > - RTP协议中时间戳单位一般为采样频率倒数 `1/90000s`
  >
  >   >     为什么一般都用90000作为视频采样频率呢？
  >   >     90k是用于视频同步的时间尺度(TimeScale),就是每秒90k个时钟tick。为什么采用90k呢？目前视频的帧速率主要有25fps、29.97fps、30fps等，而90k刚好是它们的倍数，所以就采用了90k。
  >
  > - 时间戳增量为 `1/25s / 1/9000s = 3600`
  >
  >   > ​		数据采集的速率与数据网络传输的速率尽量保持一致。时间戳增量的设置影响的是RTP包的网络传输的速率，时间戳增量越小，发送速度越快。
  >   >
  >   > - 如果采样频率为90000Hz，时间戳单位为1/90000s，
  >   > - 每秒发送25 帧，每帧的发送占 `90000/25 = 3600`个时间戳单位



### RTCP的作用

- 通过反馈分配数据的传送质量来进行拥塞控制、监视网络和诊断网络中的问题
- SSRC（同步源标识）变化通知
  - 当网络拥塞发生时或者与会者程序发生变化时SSRC多会随之更新
  - 需要为RTP源提供额外的传送层标志
- 调整RTCP包的发送速度
  - 保证数据包能顺利到达接收端，因此需要依据参与者的数据来进行调整
- 传送会话控制信息

​		在一个典型的**应用场合**下：

- 发送媒体流的应用程序周期性地产生发送端报告SR
  - 含有不同媒体流间的同步信息
  - 和已经发送的数据报和字节的计数
  - 接收端根据这些信息可以估计出实际的数据传输速率
- 另一方面，接收端会向所有已知的发送端发送接收端报告RR
  - 含有已接收 数据报的最大序列号、丢失的数据报数目、延时抖动和时间戳等重要信息
  - 发送端应用根据这些信息可以估计出往返时延
    - 可以根据数据报丢失概率和时延抖动情况动态调整发送速率，以改善网络拥塞状况
    - 或者根据网络状况平滑地调整应用程序的服务质量



### RTP会话

1. 根据*RTP*包的序列号来排序。
2. 根据声音流和图像流的相对时间（即*RTP*包的时间戳），以及它们的绝对时间（即对应的*RTCP*包中的*RTCP*），可以实现声音和图像的同步。
3. 接收缓冲用来排序乱序了的数据包；播放缓冲用来消除播放的抖动，实现等时播放。

   > ​		将接收到的数据包缓存起来，然后根据数据包的封装信息（如包序号和时戳等），将乱序的包重新排序，最后将重新排序了的数据包放入播放缓冲播放。
   >
   > ​		由于网络不可能很理想，并且对数据包排序需要处理时耗，我们得到排序好的数据包的时间间隔是不等的。如果不用播放缓冲，那么播放节目会很卡，这叫时延抖动。相反，使用播放缓冲，在开始播放时，花费几十秒钟先将播放缓冲填满（例如PPLIVE），可以有效地消除时延抖动，从而在不太损失实时性的前提下实现流媒体的顺畅播放。



### RTP传输地址的确定

​		依赖于会话协议进行协商，如`RTSP / SIP / HTTP`等

- 协商过程中，会确定发送端`RTP`和`RTCP`的目的地址
  - 其中`RTSP`协议传输端口通过`SetUP`方法
- 通过`SDP`协议来进行媒体信息协商



### RTP 的荷载类型

​		RTP的荷载类型相当丰富

- 音频、视频、其他信息
- 编码后的数据：H264、H265、AAC、G7xx等
- 封装后的数据：PS，TS等
  - 安防中的国标流就是`RTP + PS`



### 拓展头部的作用

[RTP扩展头部AudioLevel的应用（mediasoup显示当前通话Speaker）](https://blog.csdn.net/weixin_38102771/article/details/124222681?spm=1001.2014.3001.5502)

[RTP扩展头部AbsoluteSendTime的应用（REMB GCC拥塞控制） ](https://blog.csdn.net/weixin_38102771/article/details/127780907?spm=1001.2014.3001.5502)

[RTP扩展头部TransportSequenceNumber的应用（TCC GCC拥塞控制）](https://blog.csdn.net/weixin_38102771/article/details/128218672?spm=1001.2014.3001.5502)

[RTP扩展头部RtpStreamId的应用（simulcast）](https://blog.csdn.net/weixin_38102771/article/details/140647968)



​		为RTP传输协议增加扩展性，方便扩展版本功能，同时允许用户增加私有信息。

- 大部分音视频场景都没有启用RTP扩展部分
- 但`WebRTC`中利用`RTP`扩展部分做了`FEC`的算法处理，当发生RTP丢包可以快速恢复包，在网络不好的时候特别有用
  - 前向纠错，核心思想就是一些异或运算



### 媒体同步

​		不同媒体之间同步比单媒体同步要复杂得多，除了要保证本身的播放要和时间同步外，还要保证两个或多个媒体间同步（比如音视频的同步）。

- 这种不同更关心的两个时间戳时间的换算统一，不同编码有不同的采样频率，那么时间戳的增长速度就不同。
- 另外，两个时间戳也需要有一个标准时间来表示时间戳的同步。最简单的方法是两个媒体的第一个时间戳相同，表示两个流的采集开始时间统一。
- 另外还可以通过RTCP来做不同流之间的同步。



​		 在RTP协议中，我们取得时间戳的方法有两个：一个是RTP包中的时间戳，另外一个是RTCP包中的绝对时间戳和相对时间戳。

​		绝对时间戳可以表示系统的绝对时间。而RTCP包中的相对时间就是RTP包中的时间。根据这两个时间，不同流都可以纠正自己播放时间和真正时间的偏差以达到和绝对时间同步的目的。

​		反过来说，如果没有办法拿到这个绝对时间，只有RTP包中的相对时间，那需要确定两个流在某一时间点的时间戳的数值。通俗的说，就是在某个时间点，流A的timestamp是多少，B是多少，然后根据这个时间两个流播放的延时时间，以达到同步的目的。实现这个目的最简单的办法是在两个流开始的时候，使用相同的stamp，拿音视频来说，在某一绝对时刻，采集相应的数据，并打上相同的时间戳，以后的播放，都以这个时间做基准时间，以保证同步