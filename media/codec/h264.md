# H264

​		`H.264`由`ITU-T`视频编码专家组（`VCEG`）和`ISO/IEC`动态图像专家组（`MPEG`）联合组成的联合视频组（`JVT，Joint Video Team`）提出的高度压缩数字视频编解码器)标准。

---

​		ISO针对视频指定了标准：`Motion JPEG`即`MPEG`（动态JPEG编码）。同时也是`MPEG-4`第十部分，通常被称之为`H.264/AVC`明确的说明它两方面的开发者。

> 或`AVC/H.264`或者`H.264/MPEG-4 AVC`或`MPEG-4/H.264 AVC`

- 对单幅图像进行编码
- 利用图像序列的相关性原则去除冗余，大大提高视频压缩比
  - 减少网络传输对网络带宽的占用

​		H.264创造了多参考帧、多块类型、整数变换、帧内预测等新的压缩技术，使用了更精细的分像素运动矢量（1/4、1/8）和新一代的环路滤波器，这使得压缩性能得到大大提高，系统也变得更加完善。H264在H263的基础上增加了如下压缩技术

- 双向运动补偿 
- 以小块进行的可变块运动补偿 
- 四分之一像素运动补偿 
- 环路滤波器 
- 变长编码 
- 加权预测 
- 可伸缩视频编码 
- 多视点编码等

​		H264编码器实际上有两个功能分层的任务：

- `VCL`：视频编码层，用于实际压缩编码采集到的视频数据
- `NAL`：网络抽象层，为了便于存储和传输，将`VCL`数据封装为`NAL`数据单元



## 参考

[视频编解码_取次花丛懒回顾的博客-CSDN博客](https://yinwenjie.blog.csdn.net/category_1914693.html)

[先进视频压缩编码(Advanced Video Coding, H.264/AVC)_取次花丛懒回顾的博客-CSDN博客](https://blog.csdn.net/shaqoneal/category_9267755.html)

[H.264 : Advanced video coding for generic audiovisual services](https://www.itu.int/rec/T-REC-H.264)

[H.264 NALU详解_h264 nalu-CSDN博客](https://blog.csdn.net/weixin_39399492/article/details/133165018?csdn_share_tail={"type"%3A"blog"%2C"rType"%3A"article"%2C"rId"%3A"133165018"%2C"source"%3A"weixin_39399492"})

1. 图书 《视频编码全角度详解》
2. 图书 《新一代视频压缩编码标准 — H.264/AVC》
3. 李超-H264基本原理(https://zhuanlan.zhihu.com/p/31056455)
4. 深入浅出理解视频编码H264结构(https://philm.gitbook.io/philm-ios-wiki/mei-zhou-yue-du/shen-ru-qian-chu-li-jie-shi-pin-bian-ma-h264-jie-gou)
5. 视频和视频帧：H264编码格式整理(https://zhuanlan.zhihu.com/p/71928833)
6. H264编码总结(https://www.jianshu.com/p/0c296b05ef2a)
7. VCL & NAL (H.264/AVC)(https://www.jianshu.com/p/eeecb0eb2c6e)



## 标准组成

​		H.264标准各主要部分有

- Access Unit delimiter（访问单元分割符），SEI（附加增强信息）
- primary coded picture（基本图像编码）
- Redundant Coded Picture（冗余图像编码）
- 还有Instantaneous Decoding Refresh（IDR，即时解码刷新）
- Hypothetical Reference Decoder（HRD，假想参考解码）
- Hypothetical Stream Scheduler（HSS，假想码流调度器）



## 帧类型

- I帧，为关键帧
  - 采用帧内压缩技术。
  - 将全帧图像信息进行JPEG压缩编码及传输
  - 不依赖其前后帧数据，直接可以解压成raw数据
  - I帧描述了图像背景和运动主体的详情
  - I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧; 
- P帧，为向前参考帧
  - 采用帧间压缩技术
  - P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差); 
  - P帧解码不能单独解析，需要参考前面的I帧或P帧
  - 如果其前面帧有丢失，会导致花屏。
- B帧，为双向参考帧
  - 采用帧间压缩技术
  - B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;
  - 解码是需要前面帧及后面帧同时参与

​		在baseline编码规格下，无B帧；在main profile规格下一般有B帧，通常来说B帧参与编码会提高压缩率，降低帧大小，但是会增加编解码复杂性。

- IDR（instantaneous Decoding Refresh），即时刷新帧

  ​		I帧和IDR帧都是使用帧内预测的，是同一个东西，在编码和解码中为了方便。首个I帧和其他I帧区别开，所以才把首个I帧叫IDR帧，方便控制编码和解码的流程。

  ​		![在这里插入图片描述](https://img-blog.csdnimg.cn/dd2f694073544d74931dd4b9839b324a.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/52b2b2e01e314ced9dd9dd5ccaf9f06b.png)



​	



- NAL层(网络提取层)

  - 网络抽象层。
  - 负责把网络视频流进行打包和传送.

  > 对于开发来说，VCL层不怎么需要去关心



##  VCL

​		视频编码层，包括核心压缩引擎和块，宏块和片的语法级别定义。设计目标是对视频原始数据进行压缩，不考虑存储传输要解决的封装问题。

​		H.264的码流分层结构：

- 序列（GOP）
- 图片（Picture）
- 切片（Slice）
- 宏块（Macroblock）
- 子块（Subblock）

> ​		从 H.261 到 H.263 视频编码标准中，将码流的结构划分为四个层次：
>
> - 图像层（picture layer）
> - 块组层（GOB layer）
> - 宏块层（macroblock layer）
> - 块层（block layer）

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/df235230a9c149bb850d2f883d0d4e06.png)





### slice 切片

​		切片是为了限制传输误码的范围。编码图片后切分，通过高效的方式整合出来的概念，一张图片至少有一个或多个片（slice）。

​		切片承载宏块，并被 `NALU `装载并进行网络传输的。每个片（slice）都应该是互相独立被传输的，某片的预测（片内预测和片间预测）不能以其它片中的宏块（Macroblock）为参考图像。

- `NALU `内不一定是VCL数据切片， `NALU `还有可能装载着其他用作描述视频的信息(`SPS/PPS`)。

>  在以太网每个包大小是 1500 字节，而一帧往往会大于这个值。所以就需要用于按照一定格式，对 VCL 视像编码层输出的数据拆成多个包传输，并提供包头（header）等信息，以在不同速率的网络上传输或进行存储，所有的拆包和组包都是 NAL 层去处理的。覆盖了所有片级以上的语法级别。

​		每个分片也包含着头和数据两部分：

1. 分片头中包含着分片类型、分片中的宏块类型、分片帧的数量、分片属于那个图像以及对应的帧的设置和参数等信息。
2. 分片数据中则是宏块，这里就是我们要找的存储像素数据的地方。

![在这里插入图片描述](https://img-blog.csdnimg.cn/9099e938aba544f6b78a4a1d79abd8f9.png#pic_center)

​		**切片（slice）类型跟宏块类型的关系**

> I片：只包 I宏块，I 宏块利用从当前片中已解码的像素作为参考进行帧内预测(不能取其它片中的已解码像素作为参考进行帧内预测)。
>
>  P片：可包 P和I宏块，P 宏块利用前面已编码图像作为参考图象进行帧内预测，一个帧内编码的宏块可进一步作宏块的分割:即 16×16、16×8、8×16 或 8×8 亮度像素块(以及附带的彩色像素);如果选了 8×8 的子宏块，则可再分成各种子宏块的分割，其尺寸为 8×8、8×4、4×8 或 4×4 亮度像素块(以及附带的彩色像素)。 
>
> B片：可包 B和I宏块，B 宏块则利用双向的参考图象(当前和 来的已编码图象帧)进行帧内预测。 
>
> SP片(切换P)：用于不同编码流之间的切换，包含 P 和/或 I 宏块 
>
> SI片：扩展档次中必须具有的切换，它包 了一种特殊类型的编码宏块，叫做 SI 宏块，SI 也是扩展档次中的必备功能。

### macroblock 宏块

​		宏块是视频信息的主要承载者，因为它包含着每一个像素的亮度和色度信息。视频解码最主要的工作则是提供高效的方式从码流中获得宏块中的像素阵列。

​		一个宏块由一个 16×16 亮度像素和附加的一个8×8 Cb和一个 8×8 Cr 彩色像素块组成。每个图象中，若干宏块被排列成片的形式。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d63d8ec0acb44b659c46b3a6955c20c6.png#pic_center)





### 编码流程

​		通过摄像头采集到的视频帧，被送到 H.264 编码器的缓冲区中。（帧率假使为30）

- 第一步：逐帧划分宏块
  - 划分好宏块后，计算宏块的像素值
- 第二步：逐帧划分子块
  - 对比较平坦的图像使用 16x16 大小的宏块。
    - 但为了更高的压缩率，还可以在 16x16 的宏块上更划分出更小的子块。
    - 子块的大小可以是 8x16､ 16x8､ 8x8､ 4x8､ 8x4､ 4x4非常的灵活
  - 再经过帧内压缩，可以得到更高效的数据
- 第三步：帧分组
  - 分组，相关帧通过预测的方法来压缩数据
  - 编码器会按顺序，每次取出两幅相邻的帧进行宏块比较，计算两帧的相似度
  - 一组帧中，经过编码后，只保留第一帧的完整数据，其它帧都参考上一帧计算出来
    - 称第一帧为` I `帧，其它帧我们称为 `P/B` 帧
  - 编码后的数据帧组称为 `GOP`
- 第四步：运动估计与补偿
  - 计算帧组内物体的运动矢量
  - 去除帧间相同部分，得到补偿数据
  - 只需要将补偿数据进行压缩保存，以后在解码时就可以恢复原图
- 第五步：帧内压缩
  - 去除一幅图像中人眼不敏感的数据
  - H.264的帧内压缩与JPEG相似
    - 一幅图像被划分好宏块后，对每个宏块可以进行 9 种模式的预测
    - 找出与原图最接近的一种预测模式
    - 将原始图像与帧内预测后的图像相减，得到残差值
    - 将之前得到的预测模式信息一起保存起来，这样我们就可以在解码时恢复原图
- 第六步：对残差数据做DCT
  - 将残差数据做整数离散余弦变换，去掉数据的相关性，进一步压缩数据
- 第七步：CABAC压缩
  - 无损压缩技术
  - 最熟悉的可能就是哈夫曼编码了，给高频的词一个短码，给低频词一个长码从而达到数据压缩的目的
  - CABAC也是给高频数据短码，给低频数据长码。同时还会根据上下文相关性进行压缩，这种方式又比VLC高效很多



![图片](https://ask.qcloudimg.com/http-save/3985899/3c4324fb058cd434c1e8c541e7f3bf14.webp)



![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/efbfb431d6d8abffa80f45fc02c3541d.webp?x-oss-process=image/format,png#pic_center)





## NALU

​		`H.264`的编码帧序列包括一系列的`NAL`单元，每个`NAL`单元包含一个`RBSP`，单元的信息头定义了`RBSP`单元的类型，NAL单元其余部分为`RBSP`数据。

### 结构

​		通常来说，一个原始的H.264 NALU 单元常由三部分组成

​			` [StartCode] [NALU Header] [NALU Payload]`

- StartCode 必须是` 0x00 00 00 01` 或者 `0x00 00 01`
  - 如果NALU对应的Slice为一帧的开始就用`0x00 00 00 01`，否则就用`0x00 00 01`。
- 紧接着就是一个字节的`nalu header`，标示这是一个NALU 单元的开始。

```c
/*
0 1   3			8
-----------------
|F|NRI|  Type	|
-----------------
*/
```

- `F (forbidden_zero_bit)`， 屏蔽位，1bit

  - 正常状态下应该为0，如果1应该舍弃
  - 在 H.264 规范中规定了这⼀位必须初始为 0，当网络发现NAL单元有比特错误时可设置该比特为1，以便接收方纠错或丢掉该单元。

- `NRI (nal_ref_idc)`， 标识当前NALU的重要性等级，2比特

  - 取值 0-3
  - 值越大标识当前NALU越重要，如果取 00则可以丢弃
  - 如果当前NALU属于参考帧的数据，或者是序列参数集，图像参数集等重要信息，则该值必须大于0

- `Type`，数据类型（`nal_unit_type`），5bit

  - 取值 0 ~ 31

    - `1~12`由h264使用
  
    - `24~31`由外部应用使用
  
  - ```c
    0x67 (0 11 00111) SPS		非常重要     		type = 7
    0x68 (0 11 01000) PPS		非常重要     		type = 8
    0x65 (0 11 00101) IDR  		关键帧  非常重要	  type = 5
    0x61 (0 10 00001) I帧      	重要             	 type = 1
    0x41 (0 10 00001) P帧      	重要             	 type = 1
    0x01 (0 00 00001) B帧      	不重要           	type = 1
    0x06 (0 00 00110) SEI      	不重要           	 type = 6
    ```

![在这里插入图片描述](https://img-blog.csdnimg.cn/24108af7d6274f40a70c81715a52246d.png)



### NALU包类型

> **00 00 00 01 06 05 SEI数据**：是视频的附加增强信息，它包含了一些用户自定义的数据，如时间戳，字幕，弹幕等信息。SEI信息一般放在编码图像之前，很多时候SEI可以被忽略。
>
> **00 00 00 01 67 SPS数据**：指的是序列参数集，它保存了一组编码视频序列的全局参数。编码视频序列指的是原始数据经过编码后组成的一系列序号集。
>
> **00 00 00 01 68 PPS数据**：指的是图像参数集，主要用于保存图像序列集中一个或者多个独立的图像。一般情况下，配合SPS和PPS都是H264开头的两个NALU头。
>
> **00 00 00 01 65 IDR数据**：IDR指的是H264的一帧完整的图像数据，也就是我们经常说的关键帧。

​		H.264码流第一个NALU是SPS，第二个NALU是PPS。

​		SPS、PPS的内容都是编码器写入的。解码时，解码器一开始要收到SPS、PPS来做初始化，如果H.264码流中没有SPS或PPS的话，解码器是无法解析码流数据，自然是无法播放。如果编码参数改变，则还需要一组新的SPS、PPS。

​		在标准文档中，都是用三列表格描述SPS/PPS：

- 第一列，写的是语法元素和语法规则；
- 第二列，写的是分类信息。
- 第三列，写的是该行语法元素的描述信息，就是这个元素采用什么编码方式，占用多少空间，又被称作描述子。
  - u(n)：无符号整数，n bit长度。
  - ue(v)：无符号指数哥伦布熵编码。
  - se(v)：有符号指数哥伦布熵编码。

> 码流中读到的SPS、PPS中的某些字段数据是经过一次编码之后的数据，并不是原始数据。这个过程被称之为熵编码。
>
> 熵编码是一类编码的总称，在SPS和PPS中主要使用的是一种叫做指数哥伦布编码的熵编码算法。
>
> 第三列是ue(v)或se(v)字样，则说明对应字段的数据经过编码，读到数据之后需要先解码，然后才能获得真实的数据。如果第三列是u(8)，则说明此字段没有经过编码，读取的数据就是原始数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4ff50a5d9a5341e5ad7df9cb93b3cbc2.png#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b847fc0fb6d34bb49787d11f9ef7f4ca.png)

#### SPS

​		Sequence Paramater Set，又称作序列参数集。

​		对应的是针对一段连续编码视频序列的参数。包含 帧数、POC的约束、参考帧数目、解码图像尺寸和帧场编码模式选择标识等信息。

​		[H.264 SPS、PPS详解_sps pps-CSDN博客](https://blog.csdn.net/weixin_39399492/article/details/133165059)

#### PPS

​		Picture Parameter Set，又称作图像参数集。

​		对应的是一个序列中某一副图像或者某几幅图像的参数。包含 熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等信息。



#### 指数哥伦布熵编码

​		https://blog.csdn.net/u012188065/article/details/53590641/

​		https://www.zzsin.com/article/golomb.html



### 分片NALU

​	`7C`开头是分片NALU，后面一般为`85/05/45`

- `7C 85`，转化为65并加入包头
- `7C 45`，直接去除
- `7C 05`，直接去除



### 码流负载处理

- `SODB `：Stateless Object Data Bitstream，数据比特串

  - 不包括额外的元数据或者控制信息
  - 是编码时生成的原始数据，即VCL数据
  - 直接传输编码的数据块，简化编码和解码过程

- `RBSP`：Raw ByteSequence Payload。原始字节序列载荷

  - 在SODB的后面填加了结尾比特（RBSP trailing bits），一个bit“1”，若干bit “0”，以便字节对齐；
  - RBSP 通常对配对的 NAL 单元进行封装。

- `EBSP`：EncapsulationByte Sequence Packets，扩展字节序列载荷

  - 在`RBSP`基础上填加了仿校验字节（0X03）。

  - 控制信息、码流结构

  - 通常会在视频信息传输或存储时使用

    > ​		在NALU加到Annexb上时，需要添加每组`NALU`之前的开始码StartCode，如果该NALU对应的`slice`为一帧的开始则用4位字节表示，`0x00 00 00 01`，否则用3位字节表示`0x00 00 01`（是一帧的一部分）。
    >
    > ​		解码器检测每个起始码，作为一个NAL的起始标识，当检测到下一个起始码时，当前NAL结束。对于NAL中数据出现`0x000001`或`0x000000`时，H.264引入了防止竞争机制，如果编码器遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉，也称为脱壳操作。

![图片](https://ask.qcloudimg.com/http-save/3985899/d9c48c08fc1cab3c5739ac7e2c6b2c44.webp)



### 实例

![IDR](https://raw.githubusercontent.com/Mocearan/picgo-server/main/241d2a02f0b9601233f143be3da2fa19.png)

- `00 00 00 01 09`，其中00000001是帧起始位标识，09是nalu header，二进制为00001001，F(7位）为0标识非禁止，NRI（56位）为0标识可丢弃帧，type（04位）为9，表示分隔符，此帧可丢弃，表示分隔符
- `00000001 67`，同上面的分析，NALU头为67，二进制为01100111，F=0，NRI=3，type=7，帧类型为SPS帧，非常重要不可丢弃
- `00000001 68`，NALU头为68，二进制为01101000，F=0，NRI=3，type=8，帧类型为PPS帧，非常重要不可丢弃
- `00000001 06`，NALU头为06，二进制为00000110，F=0，NRI=0，type=6，帧类型为SEI，可丢弃
- `00000001 65`，NALU头为65，二进制为01100101，F=0，NRI=3，type=5，帧类型为I帧，非常重要不可丢弃

> 从上面的分析可以看出，IDR（SPS/PPS/I)帧通常一起出现，极少数编码单独出现I帧，但是IDR与I帧单独出现也符合规范。









## h264流封装

​		存储h264编码后的视频流方式有两种`annex-b`和`avcc`。

> 编码后的视频数据和音频数据，分别按照编码的格式封装。然后再和其他信息一起复合封装为一个容器文件如ps/ts/mp4
>
> 这种结构化的分层封装方式使得多媒体内容在不同环境下都能得到有效的管理和播放。

​		H.264有两种封装，二者都以NAL作为基本封装单位

-  `AnnexB `模式，将 H.264 视频数据以 NAL 单元的形式进行封装，适合实时传输和容错。
  - 对于编码出来的码流，一般都是`annex-b`方式
  - 有`startcode`，用`0x00000001`标识起始
    - `0x00000001`标识下一个`nalu`的开始和上一个`nalu`的结束
    - 如果编码本身出现了`0x00000001`，就使用防竞争码方式让编码不会出现`0x00000001`
  - `SPS`和`PPS`是在`ES`中，由`nalu`负载的单独的数据包
    - `nalu header->nal_unit_type=7`时，nalu payload中是SPS
    - `nalu header->nal_unit_type=8`时，nalu payload中是PPS
    - 这种格式下SPS、PPS通常放在关键帧之前
- `AVCC`模式，mp4、mkv模式，以更高效的方式存储视频，便于随机访问和播放。
  - `avcc`这种方式在mp4格式中常见
  - 没有`startcode`，用1-4个字节加在`nalu`前面表示`nalu`的长度，表示字节的个数需要单独指定
    - 每个frame前4个字节是这个frame的⻓度
  - `SPS`和PPS`以及`其它信息被封装在`container`的`extradata`中
    - 这种格式下`SPS/PPS`的存放位置和帧数据无关

![图片](https://ask.qcloudimg.com/http-save/3985899/034446e6065ac9b24f1944e7922baa56.webp)



## parser

[H264Analysis/H264Analysis_02/H264Analysis/nalu.h at master · Gosivn/H264Analysis (github.com)](https://github.com/Gosivn/H264Analysis/blob/master/H264Analysis_02/H264Analysis/nalu.h)

[从零实现一个h264解码器（一）-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1960566)

[h264bitstream/h264_sei.h at master · aizvorski/h264bitstream (github.com)](https://github.com/aizvorski/h264bitstream/blob/master/h264_sei.h)

[SimpleH264Analyzer/SimpleH264Analyzer/SimpleH264Analyzer/Macroblock.cpp at master · yinwenjie/SimpleH264Analyzer (github.com)](https://github.com/yinwenjie/SimpleH264Analyzer/blob/master/SimpleH264Analyzer/SimpleH264Analyzer/Macroblock.cpp)

[最简单的 H.264 视频码流解析程序_h264码流分析程序-CSDN博客](https://blog.csdn.net/ProgramNovice/article/details/137258394)

[simplest_mediadata_test:samples to handling multimedia data - GitCode](https://gitcode.com/leixiaohua1020/simplest_mediadata_test/blob/master/simplest_mediadata_test/simplest_mediadata_h264.cpp)

[视音频数据处理入门：H.264视频码流解析_视频码流分析-CSDN博客](https://blog.csdn.net/leixiaohua1020/article/details/50534369)